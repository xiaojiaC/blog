<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>java并发编程的艺术</title>
    <url>/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF.html</url>
    <content><![CDATA[<h2 id="并发编程的挑战"><a href="#并发编程的挑战" class="headerlink" title="并发编程的挑战"></a>并发编程的挑战</h2><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>上下文切换：CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</p>
<a id="more"></a>

<div class="tabs" id="上下文切换"><ul class="nav-tabs"><li class="tab active"><a href="#上下文切换-1">减少方法</a></li><li class="tab"><a href="#上下文切换-2">实践案例</a></li><li class="tab"><a href="#上下文切换-3">分析工具</a></li></ul><div class="tab-content"><div class="tab-pane active" id="上下文切换-1"><ul>
<li>无锁并发编程</li>
<li>CAS算法</li>
<li>使用最少线程</li>
<li>使用协程</li>
</ul></div><div class="tab-pane" id="上下文切换-2"><ul>
<li>减少<span class="label warning">WAITTING</span>线程数，因为每一次从<span class="label warning">WAITTING</span>到<span class="label danger">RUNNABLE</span>都会进行一次上下文的切换。</li>
</ul></div><div class="tab-pane" id="上下文切换-3"><p><code>vmstat</code></p></div></div></div>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁：多个进程在执行过程中，因争夺同类资源且资源分配不当而造成的一种互相等待的现象，若无外力作用，它们都将永远无法继续执行，这种状态称为死锁。</p>
<div class="tabs" id="死锁"><ul class="nav-tabs"><li class="tab active"><a href="#死锁-1">产生原因</a></li><li class="tab"><a href="#死锁-2">必要条件</a></li><li class="tab"><a href="#死锁-3">规避方法</a></li><li class="tab"><a href="#死锁-4">分析工具</a></li></ul><div class="tab-content"><div class="tab-pane active" id="死锁-1"><ul>
<li>不可剥夺资源的竞争<blockquote>
<p>可剥夺资源：某进程在获得该类资源时，该资源同样可以被其他进程或系统剥夺。<br>不可剥夺资源：系统把该类资源分配给某个进程时不能强制收回，只能在该进程使用完成后自动释放。</p>
</blockquote>
</li>
<li>进程推进顺序不当</li>
</ul></div><div class="tab-pane" id="死锁-2"><ul>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul></div><div class="tab-pane" id="死锁-3"><ul>
<li>避免一个线程同时获取多个锁</li>
<li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源</li>
<li>尝试使用定时锁来替代使用内部锁机制</li>
<li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况</li>
<li>避免对长时间的计算任务和阻塞的I/O操作加锁</li>
</ul></div><div class="tab-pane" id="死锁-4"><p><code>jps</code>, <code>jstack $pid</code></p></div></div></div>

<h3 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h3><p>硬件资源限制：可以考虑使用集群并行执行程序。<br>软件资源限制：可以考虑使用资源池将资源复用。</p>
<h2 id="java并发机制的底层实现原理"><a href="#java并发机制的底层实现原理" class="headerlink" title="java并发机制的底层实现原理"></a>java并发机制的底层实现原理</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><table>
<thead>
<tr>
<th>术语</th>
<th>释义</th>
</tr>
</thead>
<tbody><tr>
<td>内存屏障</td>
<td>一组处理器指令，由于实现对内存操作的顺序限制。</td>
</tr>
<tr>
<td>原子操作</td>
<td>不可中断的一个或一系列操作。</td>
</tr>
<tr>
<td>缓存行</td>
<td>缓存中可以分配的最小存储单位。处理器填写缓存线时会加载整个缓存线，需要使用多个主内存读周期。</td>
</tr>
<tr>
<td>缓存行填充</td>
<td>当处理器识别到从主存中读取的操作数是可缓存的，处理器读取整个缓存行到适当的缓存中（L1,L2,L3或所有）。</td>
</tr>
<tr>
<td>缓存命中</td>
<td>如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的内存地址，处理器从缓存中读取操作数，而不是从主存中读取。</td>
</tr>
<tr>
<td>写命中</td>
<td>当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存，这个操作被称为写命中。</td>
</tr>
<tr>
<td>写缺失</td>
<td>一个有效的缓存行被写入到不存在的内存区域。</td>
</tr>
<tr>
<td>CPU流水线</td>
<td>工作方式就像工业生产中的装配流水线，在CPU中由5<del>6个不同功能的电路单元组成一条指令处理流水线，然后将一条x86指令拆分为5</del>6步再由这些电路单元分别执行，这样就能实现一个CPU时钟周期内完成一条指令，因此提高CPU的运算速度。</td>
</tr>
<tr>
<td>内存顺序冲突</td>
<td>一般由假共享引起，假共享是指多个CPU同时修改同一个缓存行的不同部分而引起其中一个CPU操作无效，当出现这个内存顺序冲突时，CPU必须清空流水线。</td>
</tr>
</tbody></table>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p><code>volatile</code>变量修饰的共享变量进行写操作的时候会多出一个<em>lock前缀的指令</em>，该指令在多核处理器下会引发：</p>
<ol>
<li>将当前处理器缓存行的数据回写到系统内存。</li>
<li>这个回写内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li>
</ol>
<p>实现原理：</p>
<blockquote>
<p>声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p>
</blockquote>
<p>为什么<code>LinkedTransferQueue</code>中头、尾volatile变量追加64字节能够提高并发编程的效率呢？</p>
<p>大部分处理器高速缓存行是64个字节宽，且不支持部分填充缓存行。使用追加到64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，使头、尾节点在修改时不会互相锁定。</p>
<p>是不是在使用<code>volatile</code>变量时都应该追加到64字节呢？<strong>并非如此</strong>，在两种场景下不应该使用这种方式：</p>
<ul>
<li>缓存行非64字节宽的处理器</li>
<li>共享变量不会被频繁地写</li>
</ul>
<div class="note warning">
            <p>不过这种追加字节的方式在Java 7下可能不生效，因为Java 7变得更加智慧，它会淘汰或重新排列无用字段，需要使用其他追加字节的方式。</p>
          </div>

<div class="note info">
            <p>你可能想看这里: <a href="https://blog.csdn.net/aigoogle/article/details/41517213" target="_blank" rel="noopener">神奇的缓存行填充</a></p>
          </div>

<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>实现原理：</p>
<blockquote>
<p>JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用<code>monitorenter</code>和<code>monitorexit</code>指令实现的，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。<code>monitorenter</code>指令是在编译后插入到同步代码块的开始位置，而<code>monitorexit</code>是插入到方法结束处和异常处，JVM要保证每个<code>monitorenter</code>必须有对应的<code>monitorexit</code>与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到<code>monitorenter</code>指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。</p>
</blockquote>
<p><code>synchronized</code>用的锁是存在Java对象头里的。其存储结构如下示：</p>
<p>第一部分：</p>
<img src="/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/markword-32bit-vm.PNG" class="">
<img src="/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/markword-64bit-vm.PNG" class="">

<p>第二部分：<br>类型指针，即对象指向类元数据的指针，虚拟机通过这个指针来确定对象是哪个类的实例。但并不是所有虚拟机实现都需要在对象头上保持类型指针。因为有的虚拟机使用<em>句柄</em>进行对象访问定位，而不是<em>直接指针</em>访问。</p>
<p>第三部分：<br>如果对象是一个java数组，那么在对象头中还必须有一块用于记录数组长度的数据。可能是对齐填充，并不是必要存在的，也没有特别含义，仅起占位符的作用。</p>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：<strong>无锁状态</strong>、<strong>偏向锁状态</strong>、<strong>轻量级锁状态</strong>和<strong>重量级锁</strong>状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。</p>
<img src="/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/synchonized.png" class="">

<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>原子操作：不可被中断的一个或一系列操作。</p>
<p>处理器如何实现原子操作：</p>
<ul>
<li>通过总线锁保证原子性（总线上声明<code>lock#</code>信号）</li>
<li>通过缓存锁定来保证原子性（修改内部的内存地址+缓存一致性机制使<em>单个</em>缓存行无效）</li>
</ul>
<p>Java如何实现原子操作：</p>
<ul>
<li>使用循环CAS<ul>
<li>ABA问题：解决方法追加版本号，可参考<code>AtomicStampedReference</code></li>
<li>循环时间长开销大</li>
<li>只能保证一个共享变量的原子操作：解决方法使用锁替换或把多个共享变量合并成一个共享变量来操作，可参考<code>AtomicReference</code></li>
</ul>
</li>
<li>使用锁机制</li>
</ul>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h3><p>命令式编程中，线程之间的通信机制有两种：<strong>共享内存</strong>和<strong>消息传递</strong>。</p>
<p>从源代码到指令序列可能发生哪些重排序？</p>
<ul>
<li>编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序：如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。<blockquote>
<p>如果两个操作访问<em>同一个变量</em>，且这两个操作中<em>有一个为写操作</em>，此时这两个操作之间就存在数据依赖性。</p>
</blockquote>
</li>
<li>内存系统的重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ul>
<img src="/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/code-to-instruction-reorder.PNG" class="" title="源代码到指令序列的重排序">

<p>Java线程之间的通信由<em>Java内存模型</em>控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。确保在不同的编译器和不同的处理器平台之上，为程序员提供一致的内存可见性保证。</p>
<p>对于编译器重排序，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。<br>对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入内存屏障指令来禁止特定类型的处理器重排序。</p>
<div class="note info">
            <p>常见的处理器（基本都有写缓冲区）都允许Store-Load重排序；都不允许对存在数据依赖的操作做重排序。</p>
          </div>

<h3 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h3><p>happens-before规则：</p>
<ul>
<li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li>
<li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li>
<li><code>start()</code>规则：如果线程A执行操作<code>ThreadB.start()</code>（启动线程B），那么A线程的<code>ThreadB.start()</code>操作happens-before于线程B中的任意操作。</li>
<li><code>join()</code>规则：如果线程A执行操作<code>ThreadB.join()</code>并成功返回，那么线程B中的任意操作happens-before于线程A从<code>ThreadB.join()</code>操作成功返回。</li>
<li>中断法则：一个线程调用另一个线程的<code>interrupt()</code> happens-before于被中断的线程发现中断。</li>
<li>终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。</li>
<li>传递性规则：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
</ul>
<div class="note warning">
            <p>两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。</p>
          </div>

<h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><p>as-if-serial语义：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</p>
<h3 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h3><p>顺序一致性内存模型有哪些特性？</p>
<ul>
<li>一个线程中的所有操作必须按照程序的顺序串行执行。</li>
<li>（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li>
</ul>
<p>在JMM中，临界区内的代码可以重排序（但JMM不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。<br>JMM不保证对64位的long型和double型变量的写操作具有原子性。</p>
<h3 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h3><p>理解volatile特性的一个好方法是：把对volatile变量的单个读/写，看成是使用<strong>同一个锁</strong>对这些<strong>单个</strong>读/写操作做了同步。</p>
<p>这意味着，1. 对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。2. 即使是64位的long型和double型变量，只要它是volatile变量，对该变量的单个读/写就具有原子性。</p>
<p>内存屏障：</p>
<p>硬件层的内存屏障分为两种：<code>Load Barrier</code> 和 <code>Store Barrier</code> 即读屏障和写屏障。</p>
<div class="tabs" id="内存屏障"><ul class="nav-tabs"><li class="tab active"><a href="#内存屏障-1">作用</a></li><li class="tab"><a href="#内存屏障-2">分类</a></li><li class="tab"><a href="#内存屏障-3">java中的分类</a></li></ul><div class="tab-content"><div class="tab-pane active" id="内存屏障-1"><ol>
<li>阻止屏障两侧的指令重排序；</li>
<li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效（必须从主内存从新加载）。</li>
</ol></div><div class="tab-pane" id="内存屏障-2"><ul>
<li>对于<code>Load Barrier</code>来说，在指令前插入<code>Load Barrier</code>，可以让高速缓存中的数据失效，强制从新从主内存加载数据；</li>
<li>对于<code>Store Barrier</code>来说，在指令后插入<code>Store Barrier</code>，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。</li>
</ul></div><div class="tab-pane" id="内存屏障-3"><img src="/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/java-memory-barrier.PNG" class=""></div></div></div>

<p>volatile的编译器重排序规则：</p>
<ul>
<li>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</li>
<li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。</li>
<li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。</li>
</ul>
<p>volatile的处理器内存屏障插入策略：</p>
<ul>
<li>在每个volatile写操作的前面插入一个<code>StoreStore</code>屏障。</li>
<li>在每个volatile写操作的后面插入一个<code>StoreLoad</code>屏障。</li>
<li>在每个volatile读操作的后面插入一个<code>LoadLoad</code>屏障。</li>
<li>在每个volatile读操作的后面插入一个<code>LoadStore</code>屏障。</li>
</ul>
<div class="note ">
            <p>我的疑惑：为什么不需要在每个volatile写操作的前面插入一个LoadStore屏障，来防止第一个普通读和第二个volatile写操作重排序？？？</p>
          </div>

<h3 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h3><p>在<code>ReentrantLock</code>中，调用<code>lock()</code>方法获取锁；调用<code>unlock()</code>方法释放锁。</p>
<p>加锁方法首先读volatile变量<code>state</code>，在释放锁的最后写volatile变量<code>state</code>。根据volatile的happens-before规则，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变得对获取锁的线程可见。</p>
<p>获取锁中的CAS又如何同时具有volatile读和volatile写的内存语义？</p>
<p>从编译器角度：<br>编译器不会对volatile读与volatile读后面的任意内存操作重排序；编译器不会对volatile写与volatile写前面的任意内存操作重排序。组合这两个条件，意味着为了同时实现volatile读和volatile写的内存语义，编译器不能对CAS与CAS前面和后面的任意内存操作重排序。</p>
<p>从处理器角度：<br>在常见的intel X86处理器中，源码中会根据当前处理器的类型来决定是否为<code>cmpxchg</code>指令添加<code>lock</code>前缀。lock前缀的第2点和第3点所具有的内存屏障效果，足以同时实现volatile读和volatile写的内存语义。</p>
<blockquote>
<p>intel的手册对lock前缀的说明: 1. 确保对内存的读-改-写操作原子执行。2. 禁止该指令，与之前和之后的读和写指令重排序。3. 把写缓冲区中的所有数据刷新到内存中。</p>
</blockquote>
<p>综上述，可见<code>ReentrantLock</code>内存语义实现利用了volatile变量的写-读所具有的内存语义和CAS所附带的volatile读和volatile写的内存语义。</p>
<hr>
<ul>
<li><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization" target="_blank" rel="noopener">Synchronization</a></li>
<li><a href="https://blog.dreamtobe.cn/2015/11/13/java_synchronized/" target="_blank" rel="noopener">Java Synchronised机制</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrency</tag>
      </tags>
  </entry>
</search>
