<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>java并发编程实战</title>
    <url>/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98.html</url>
    <content><![CDATA[<h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><p>要编写线程安全的代码，核心在于<span class="label primary">要对状态访问操作进行管理</span>，特别是对<strong>共享的</strong>和<strong>可变的</strong>状态的访问。</p>
<p>当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。</p>
<p>如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：</p>
<ul>
<li>不在线程之间共享该状态变量。</li>
<li>将状态变量修改为不可变的变量。</li>
<li>在访问状态变量时使用同步。</li>
</ul>
<a id="more"></a>

<p>在编写并发程序时，一种正确的编程方法就是：<span class="label success">首先使代码正确运行，然后再提高代码的速度。</span>即便如此，最好也只是当性能测试结果和应用需求告诉你必须提高性能，以及测量结果表明这种优化在实际环境中确实能带来性能提升时，才进行优化。</p>
<h3 id="线程安全性-1"><a href="#线程安全性-1" class="headerlink" title="线程安全性"></a>线程安全性</h3><p>在线程安全性的定义中，最核心的概念是<span class="label primary">正确性</span>（某个类的行为与其规范完全一致）。</p>
<blockquote>
<p>当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。</p>
</blockquote>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>竞态条件：</p>
<ul>
<li><span class="label info">先检查后执行</span> eg: 单例延迟初始化</li>
<li><span class="label info">读取-修改-写入</span> eg: i++

</li>
</ul>
<p>原子操作：对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。</p>
<p>当在无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的。在实际情况中，应尽可能地使用现有的线程安全对象（eg: <code>AtomicLong</code>）来管理类的状态。</p>
<h3 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h3><p>当在不变性条件涉及多个变量时，各个变量之间并不是彼此独立的，而是某个变量的值会对其他变量的值产生约束。因此，当更新某一个变量时，需要在同一个原子操作中对其他变量同时进行更新。</p>
<span class="label danger">要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。</span>

<h3 id="用锁来保护状态"><a href="#用锁来保护状态" class="headerlink" title="用锁来保护状态"></a>用锁来保护状态</h3><span class="label warning">如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步。而且，当使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同一个锁。</span>

<p>每个共享的和可变的变量都应该只由一个锁类保护，从而使维护人员知道是哪一个锁。</p>
<span class="label danger">每个包含多个变量的不变性条件，其中涉及的所有变量都需要同一个锁来保护。</span>

<h3 id="活跃性与性能"><a href="#活跃性与性能" class="headerlink" title="活跃性与性能"></a>活跃性与性能</h3><span class="label warning">通常，在简单性与性能之间存在着相互制约因素。当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性（这可能会破坏安全性）。</span>

<p>当使用锁时，你应该清楚代码块中实现的功能，以及在执行该代码块时是否需要很长的时间，无论是执行计算密集的操作，还是执行某个可能阻塞的操作，如果锁持有的时间过长，那么都会带来活跃性或性能问题。</p>
<span class="label danger">当执行时间较长的计算或可能无法快速完成的操作(eg: I/O)时，一定不要持有锁。</span>

<h2 id="对象的共享"><a href="#对象的共享" class="headerlink" title="对象的共享"></a>对象的共享</h2><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，想要对内存操作的执行顺序进行判断，几乎无法得出正确的结论。有一种简单的方法能避免这些复杂的问题：<span class="label success">只要有数据在多个线程间共享，就使用正确的同步。</span></p>
<p>当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证称为最低安全性。它适用于绝大多数变量，但是存在一个例外：<span class="label primary">非volatile类型的64位数值变量。</span></p>
<p>JMM要求变量的读取和写入操作都必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读或写操作分解为两个32位的操作。因此在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非用volatile来声明它们，或用锁保护起来。</p>
<p>加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。</p>
<span class="label danger">加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。</span>

<p>什么时候使用volatile变量？仅当同时满足以下<strong>所有</strong>条件时。</p>
<ul>
<li>对变量的写入操作不依赖变量的当前值，或者能确保只有单个线程更新变量的值。</li>
<li>该变量不会与其他变量一起纳入不变性条件中。</li>
<li>在访问变量时不需要加锁。</li>
</ul>
<h3 id="发布与逸出"><a href="#发布与逸出" class="headerlink" title="发布与逸出"></a>发布与逸出</h3><p>发布：使对象能够在当前作用域之外的代码中使用。</p>
<p>发布的方式：</p>
<ul>
<li>将对象引用保存到一个公有的静态变量。</li>
<li>发布对象时间接地发布了其他对象（eg:非私有域中引用的所有对象）。</li>
<li>发布一个内部类实例。</li>
</ul>
<p>逸出：某个不应该发布的对象被发布。当某个对象逸出时，你必须假设某个类或线程可能会误用该对象，误用该引用的风险始终存在。</p>
<p>逸出的例子：</p>
<ul>
<li>构造函数中发布内部类实例，导致<code>this</code>引用逸出。</li>
<li>构造函数中创建线程后使用<code>start()</code>启动，导致<code>this</code>引用逸出。</li>
</ul>
<span class="label danger">不要在构造过程中使this引用逸出。</span>

<h3 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h3><p>当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步，这种技术被称为线程封闭。</p>
<ul>
<li>Ad-hoc线程封闭：维护封闭性的职责完全由程序实现来承担。<blockquote>
<span class="label warning">在volatile变量上存在一种特殊的线程封闭。只要你能确保只有单个线程对共享的volatile变量执行写入操作，那么就可以安全地在这些共享的volatile变量上执行“读取-修改-写入”的操作。</span></blockquote>
</li>
<li>栈封闭</li>
<li><code>ThreadLocal</code></li>
</ul>
<h3 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h3><p>不可变的对象一定是线程安全的。</p>
<p>不可变性并不等于将对象中所有的域都声明为final类型，即使对象中所有的域都是final类型的，这个对象也仍然是可变的，因为final类型的域中可以保存对可变对象的引用。</p>
<p>当满足以下所有条件时，对象才是不可变的：</p>
<ul>
<li>对象创建以后其状态就不能修改。</li>
<li>对象的所有域都是final类型。</li>
<li>对象是正确创建的（在对象的创建期间，this引用没有逸出）。</li>
</ul>
<span class="label success">除非需要更高的可见性，否则应将所有的域都声明为私有域。除非需要某个域是可变的，否则应将其声明为final域。</span>

<h3 id="安全发布"><a href="#安全发布" class="headerlink" title="安全发布"></a>安全发布</h3><p>安全发布：要安全发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象，可以通过以下方式安全发布：</p>
<ul>
<li>在静态初始化函数中初始化一个对象引用。</li>
<li>将对象的引用保存到volatile类型的域或<code>AtomicReferance</code>对象中。</li>
<li>将对象的引用保存到某个正确构造对象的final类型域中。</li>
<li>将对象的引用保存到一个由锁保护的域中。</li>
</ul>
<p>在没有额外同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。</p>
<p>对象的发布取决于它的可变性：</p>
<ul>
<li>不可变对象可以通过任意机制来发布。</li>
<li>事实不可变对象必须通过安全方式来发布。</li>
<li>可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。</li>
</ul>
<span class="label warning">如果final类型的域指向的是可变对象，那么在访问这些域所指向的对象的状态时仍然需要同步。</span>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>并发程序中使用和共享对象时，有以下一些实用的策略，包括：</p>
<ul>
<li><strong>线程封闭</strong>。线程封闭的对象只能有一个线程持有，对象被封闭在该线程中，并且只能由这个线程修改。</li>
<li><strong>只读共享</strong>。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。</li>
<li><strong>线程安全共享</strong>。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来访问而不需要进一步的同步。</li>
<li><strong>保护对象</strong>。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。</li>
</ul>
<h2 id="对象的组合"><a href="#对象的组合" class="headerlink" title="对象的组合"></a>对象的组合</h2><h3 id="设计线程安全类"><a href="#设计线程安全类" class="headerlink" title="设计线程安全类"></a>设计线程安全类</h3><p>在设计线程安全类的过程中，需要包含以下三个基本要素：</p>
<ol>
<li>找出构成对象状态的所有变量。</li>
<li>找出约束变量的不变性条件。</li>
<li>建立对象状态的并发访问管理策略。</li>
</ol>
<p>同步策略定义了如何在不违背对象不变条件或后验条件的情况下对其状态的访问操作进行协同。同步策略规定了如何将不可变性，线程封闭与加锁机制等结合起来以维护线程的安全性，并且还规定了哪些变量由哪些锁来保护。要确保开发人员可以对这个类进行分析与维护，就必须将同步策略写为正式文档。</p>
<span class="label warning">如果在一个不变性条件中包含多个变量，那么在执行任何访问相关变量的操作时，都必须持有保护这些变量的锁。</span>

<p>类的不变性条件与后验条件约束了在对象上有哪些状态和状态转换是有效的。在某些对象的方法中还包含一些基于状态的先验条件（例如：不能从空队列移除一个元素）。如果某个操作中包含有基于状态的先验条件，那么这个操作就称为依赖状态的操作。</p>
<h3 id="实例封闭"><a href="#实例封闭" class="headerlink" title="实例封闭"></a>实例封闭</h3><p>封装可简化线程安全类的实现过程。通过将封闭机制与合适的加锁策略结合起来，可以确保以线程安全的方式来使用非线程安全的对象。</p>
<p>将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。</p>
<span class="label success">优先使用私有的锁对象而不是对象的内置锁（或任何其他可通过公有方式访问的锁）。</span>

<h3 id="线程安全性委托"><a href="#线程安全性委托" class="headerlink" title="线程安全性委托"></a>线程安全性委托</h3><p>线程安全性委托：</p>
<ul>
<li>单个状态变量：可以将线程的安全性委托给单个线程安全的状态变量。</li>
<li>独立的多个状态变量：可以将线程的安全性委托给多个线程安全的状态变量，只要这些变量是彼此独立的，即组合而成的类并不会在其包含的多个状态变量上增加任何不变性条件。</li>
<li>有不变性条件的多个状态变量：<span class="label warning">某个类含有复合操作，那么仅靠委托并不足以实现线程安全性。这个类必须提供自己的加锁机制以保证这些复合操作都是原子操作，除非整个复合操作都可以委托给状态变量。</span></li>
</ul>
<p>如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全地发布这个变量。</p>
<h3 id="在现有的线程安全类中添加功能"><a href="#在现有的线程安全类中添加功能" class="headerlink" title="在现有的线程安全类中添加功能"></a>在现有的线程安全类中添加功能</h3><p>在现有的线程安全类中添加功能有以下几种方式：</p>
<ul>
<li>修改原始的类：通常无法做到。</li>
<li><del>扩展这个类</del>：比较脆弱，底层类改变同步策略选择不同的锁来保护它的状态变量时，子类会被破坏。</li>
<li><del>将扩展代码放入一个辅助类</del>：更加脆弱，必须谨慎确保和线程安全类使用同一个锁，客户端加锁还会破坏同步策略的封装性。</li>
<li>使用组合构建自己的锁</li>
</ul>
<h3 id="将同步策略文档化"><a href="#将同步策略文档化" class="headerlink" title="将同步策略文档化"></a>将同步策略文档化</h3><p>在文档中说明客户代码需要了解的线程安全性保证，以及代码维护人员需要了解的同步策略。</p>
<h2 id="基础构建模块"><a href="#基础构建模块" class="headerlink" title="基础构建模块"></a>基础构建模块</h2><h3 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h3><p>同步容器类都是线程安全的，但在某些情况下可能需要额外的客户端加锁来保护复合操作。</p>
<p>同步容器类通过其<strong>自身的锁</strong>来保护它的每个方法。</p>
<p>虽然加锁可以防止迭代器抛出<code>ConcurrentModificationException</code>，但你必须记住在所有对共享容器进行迭代的地方都需要加锁。尤其要小心隐式迭代器的场景（容器的<code>toString</code>方法，以及<code>hasCode</code>和<code>equals</code>方法会间接地执行迭代器）。</p>
<span class="label success">正如封装对象的状态有助于维持不变性条件一样，封装对象的同步机制同样有助于确保实施同步策略。</span>

<h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><p>通过并发容器来代替同步容器，可以极大地提高伸缩性并降低风险。</p>
<p><code>ConcurrentHashMap</code>：只有当应用程序需要加锁Map以进行独占访问时，才应该放弃使用<code>ConcurrentHashMap</code>。<br><code>CopyOnWriteArrayList</code>：仅当迭代操作远远多于修改操作时，才应该使用“写时复制”容器。<br><code>ArrayBlockingQueue</code>：在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于<code>LinkedBlockingQueue</code>。<br><code>LinkedBlockingQueue</code>：对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<br><code>SynchronousQueue</code>：仅当有足够多的的消费者，并且总是有一个消费者准备好获取交付的工作时，才适合用同步队列。<br><code>LinkedBlockingDeque</code>：双端队列，适用于工作密取。</p>
<span class="label success">在设计初期就使用阻塞队列建立对资源的管理</span>（提早做这件事会比以后再修复容易的多）。

<p>在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具：它们能抑制防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮。</p>
<h3 id="阻塞和可中断的方法"><a href="#阻塞和可中断的方法" class="headerlink" title="阻塞和可中断的方法"></a>阻塞和可中断的方法</h3><p>当一个方法能够抛出<code>InterruptedException</code>时，是在告诉你这个方法是一个可阻塞方法，进一步看，如果它被中断，将可以提前结束阻塞状态。<br>当你在代码中调用了一个会抛出<code>InterruptedException</code>的方法时，你自己的方法就成为了一个阻塞方法，要为响应中断做好准备。在类库代码中，有两种基本选择：</p>
<ul>
<li><strong>传递<code>InterruptedException</code></strong>：1. 不捕获继续抛出。2. 先捕获，然后对其中特定活动进行简洁清理后，再抛出。</li>
<li><strong>恢复中断</strong>：有时候不能抛出<code>InterruptedException</code>，比如当你的代码是<code>Runnable</code>的一部分时。在这种情况下，你必须捕获<code>InterruptedException</code>，并且在当前线程中调用<code>interrupt</code>从中断中恢复，这样调用栈中更高层的代码才可以发现中断已经发生。</li>
</ul>
<span class="label warning">你不应该捕获InterruptedException，但不做任何响应。只有一种情况允许掩盖中断：你扩展了Thread，并因此控制了所有处于调用栈上层的代码。</span>

<h3 id="同步工具"><a href="#同步工具" class="headerlink" title="同步工具"></a>同步工具</h3><p>闭锁(<code>CountDownLatch</code>/<code>FutureTask</code>)：可以用来确保特定活动直到其他的活动完成后才发生。</p>
<ul>
<li>确保一个计算不会执行，直到它需要的资源被初始化。</li>
<li>确保一个服务不会开始，直到它依赖的其他服务都已经开始。</li>
<li>等待，直到活动的所有部分都为继续处理做好充分准备，比如：多玩家游戏中的所有玩家是否都准备就绪。</li>
</ul>
<p>信号量(<code>Semaphore</code>)：控制同时访问某个特定资源的线程数量或同时执行某个指定操作的数量。还可以用来实现某种资源池，或者对容器施加边界。</p>
<p>屏障(<code>CyclicBarrier</code>)：与闭锁类似，都能阻塞一组线程，直到某些事件发生。它们的不同之处在于：所有线程必须同时到达同步点，才能够继续处理。<span class="label primary">闭锁等待的是事件，屏障等待的是其他线程。</span></p>
<p>交换机(<code>Exchanger</code>)：用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul>
<li>可变状态是至关重要的。<blockquote>
<p>所有并发问题都可以归结为如何协调对并发状态的访问。可变状态越少就越容易确保线程安全性。</p>
</blockquote>
</li>
<li>尽量将域声明为final类型，除非需要它们是可变的。</li>
<li>不可变对象一定是线程安全的。<blockquote>
<p>不可变对象能极大地降低并发编程的复杂性。它们更为简单而且安全，可以任意共享而无需使用加锁或保护性复制等机制。</p>
</blockquote>
</li>
<li>封装有助于管理复杂性。<blockquote>
<p>在编写线程安全的程序时，虽然可以将所有数据都保存在全局变量中，但为什么要这样做？将数据封装在对象中，更易于维持不变性条件：将同步机制封装在对象中，更易于遵循同步策略。</p>
</blockquote>
</li>
<li>用锁来保护每个可变变量。</li>
<li>当保护同一个不变性条件中的所有变量时，要使用同一个锁。</li>
<li>在执行复合操作时，要持有锁。</li>
<li>如果从多个线程中访问同一个可变变量时没有同步机制，那么程序会出现问题。</li>
<li>不要故作聪明地推断出不需要使用同步。</li>
<li>在设计过程中考虑线程安全，或者在文档中明确地指出它不是线程安全的。</li>
<li>将同步策略文档化。</li>
</ul>
<h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><p><code>Executor</code>：一个简单的接口，它提供了一种标准的方法将任务的提交过程与执行过程解耦开来，并用<code>Runnable</code>来表示任务。</p>
<p><code>Executor</code>的实现通常会创建线程来执行任务，但JVM只有在所有非守护线程全部终止才会退出。因此，如果无法正确的关闭<code>Executor</code>，那么JVM将无法结束。</p>
<p><code>ExecutorService</code>扩展了<code>Executor</code>接口，添加了一些用于生命周期管理的方法（同时还提供一些用于任务提交的便利方法）。</p>
<p><code>ExecutorService</code>的生命周期有三种状态：运行、关闭和终止。<code>ExecutorService</code>最初创建后的初始状态是运行状态。当它被关闭后提交到<code>ExecutorService</code>的任务，会被拒绝执行处理器处理。它可能只是简单抛弃任务，或者引起<code>execute</code>方法抛出一个<code>RejectedExecutionException</code>等。一旦所有的任务全部完成后，<code>ExecutorService</code>会进入终止状态。可以调用<code>awaitTermination</code>来等待<code>ExecutorService</code>到达终止状态，或者通过<code>isTerminated</code>来轮询检查<code>ExecutorService</code>是否已经终止。通常在调用<code>shutdown</code>之后会立即调用<code>awaitTermination</code>阻塞等待，从而产生同步地关闭<code>ExecutorService</code>的效果。</p>
<blockquote>
<p><code>shutdown</code>方法将执行平缓的关闭过程：<span class="label primary">不再接受新的任务，同时等待已经提交的任务执行完毕——包括尚未开始执行的任务。</span><br><code>shutdownNow</code>方法将执行粗暴的关闭过程：<span class="label primary">尝试取消所有运行中的任务，并且不再启动排在队列中尚未开始的任务。</span></p>
</blockquote>
<p>在Executor框架中，已提交但尚未开始的任务可以取消，但对于那些已经开始执行的任务，只有当它们能够响应中断时，才能取消。取消一个已经完成的任务不会有任何影响。</p>
<h3 id="Executors中的静态方法"><a href="#Executors中的静态方法" class="headerlink" title="Executors中的静态方法"></a>Executors中的静态方法</h3><p><code>newFixedThreadPool</code>：创建一个定长的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大长度，这时线程池的规模将不再变化（<em>如果某个线程由于发生了未预期的exception而结束，那么线程池会补充一个新的线程</em>）。</p>
<p><code>newCachedThreadPool</code>：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，当需求增加时，它可以灵活地添加新线程，而并不会对池的长度做任何限制。</p>
<p><code>newSingleThreadExecutor</code>：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO, LIFO, 优先级）执行。<em>如果这个线程异常结束会创建一个新的线程来替代</em>。</p>
<p><code>newScheduledThreadPool</code>：创建一个定长线程池，支持定时及周期性任务执行。类似于<code>Timer</code>。</p>
<blockquote>
<span class="label warning">Timer存在一些缺陷，你应该考虑使用ScheduledThreadPoolExecutor来替代它。</span>
<ol>
<li>只创建唯一的线程来执行所有的任务，如果一个任务执行很耗时，会导致其他任务的时效准确性出现问题。</li>
<li>如果任务执行中抛出未检查的异常，将产生无法预料的行为（抛出未检查的异常会终止线程，不会重新恢复线程的执行，已经被安排但尚未执行的任务永远不再执行，新的任务也不能被调度，即发生线程泄露）。</li>
</ol>
</blockquote>
<p>如果你向<code>Executor</code>提交了一个批处理任务，并且希望在它们完成后获得结果。为此你可以保存与每个任务相关联的<code>Future</code>，然后不断地调用timeout为零的<code>get</code>，来检验<code>Future</code>是否完成。这样做固然可以，但却相当乏味。幸运的是，还有一个更好的方法：完成服务。</p>
<p><code>CompletionService</code>整合了<code>Executor</code>和<code>BlockingQueue</code>的功能。你可以将<code>Callable</code>任务提交给它去执行，然后使用类似于队列中的<code>take</code>和<code>poll</code>方法，在结果完整可用时获得这个结果，像一个打包的<code>Future</code>。<code>ExecutorCompletionService</code>是实现<code>CompletionService</code>接口的一个类，并将计算任务委托给一个<code>Executor</code>。</p>
<h2 id="取消与关闭"><a href="#取消与关闭" class="headerlink" title="取消与关闭"></a>取消与关闭</h2><p>java没有提供任何机制来安全地终止线程。但它提供了中断，这是一种协作机制，能够使一个线程终止另一个线程的当前工作。</p>
<h3 id="取消策略"><a href="#取消策略" class="headerlink" title="取消策略"></a>取消策略</h3><p>一个可取消的任务必须拥有取消策略，这个策略详细定义取消操作的“How”、“When”、“What”，即代码如何（How）请求取消该任务，任务在何时（When）检查是否已经请求了取消，以及在响应时执行那些（What）操作。</p>
<p>应用程序可以不间断定期的检查标志位的状态是否被改变，来实现取消。但是 <span class="label warning">如果程序调用了一个阻塞方法（例如：BlockingQueu.put()）那么可能会出现一个严重的问题，即任务可能永远无法检查取消标志。</span></p>
<h3 id="中断策略"><a href="#中断策略" class="headerlink" title="中断策略"></a>中断策略</h3><p>一个中断策略决定线程如何应对中断请求——当发现中断请求时，应该做哪些工作，哪些工作单元对中断来说是原子操作，以及以多快速度来响应中断。</p>
<p>每个<code>Thread</code>都有一个boolean类型的中断状态。当中断线程时，该状态会被置为true。<code>Thread</code>中包含的中断方法：<code>inturrept()</code>会将中断状态置为true，<code>isInterrupted()</code>方法会返回当前的中断状态，而<code>interrupted()</code>方法则会清除当前状态，并返回它之前的值。</p>
<p>阻塞库函数：<code>Object.wait()</code>、<code>Thread.sleep()</code>和<code>Thread.join()</code>等，都会去检查线程何时中断，并且在发生中断时提前返回。它们在响应中断时执行的操作包括：清除中断状态，并抛出<code>InterruptedException</code>异常，表示阻塞操作由于中断而提前结束。</p>
<p>当线程在非阻塞状态下中断时，它的中断状态将被设置，然后根据将被取消的操作来检查中断状态以判断发生了中断。通过这样的方法，中断操作将变得“有黏性”——如果不触发<code>InterruptedException</code>，那么中断状态将一直保持，直到明确地清除中断状态。</p>
<span class="label danger">调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。</span>

<p>对中断的正确理解是：它并不会真正地中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己（这些时刻也被称为取消点）。</p>
<p>使用<code>interrupted()</code>静态方法应该小心，因为它会清除并发线程的中断状态。如果你调用了interrupted，并且它返回了true，你必须对其进行处理，除非你想掩盖这个中断——你可以抛出<code>InterruptedException</code>，或者通过再次调用<code>interrupt</code>来恢复中断状态。</p>
<span class="label success">通常中断是实现取消的最合理方式。</span>

<h3 id="响应中断"><a href="#响应中断" class="headerlink" title="响应中断"></a>响应中断</h3><p>在调用可中断的阻塞函数时，例如<code>Thread.sleep</code>或<code>BlockingQueue.put</code>等，有两种实用策略可用于处理<code>InterruptedException</code>：</p>
<ul>
<li>传递异常（可能在执行某个特定于任务的清除操作之后），从而使你的方法也称为可中断的阻塞方法。</li>
<li>恢复中断状态，从而使调用栈中的上层代码能够对其进行处理。</li>
</ul>
<p>只有实现了线程中断策略的代码才可以屏蔽中断请求。在常规的任务和库代码中都不应该屏蔽中断请求。</p>
<p>对于一些<strong>不支持取消</strong>但仍可以调用可中断阻塞方法的操作，它们必须在循环中调用这些方法，并在发现中断后重新尝试。在这种情况下，它们应该在本地保存中断状态，并在返回前恢复状态而不是在捕获<code>InterruptedException</code>时恢复状态。</p>
<p>如果代码不会调用可中断的阻塞方法，那么仍然可以通过在任务代码中轮询当前线程的中断状态来响应中断。</p>
<p>执行任务的线程拥有自己的执行策略，即使任务不响应中断，限时运行的方法仍然能返回到它的调用者。</p>
<h3 id="通过Future取消"><a href="#通过Future取消" class="headerlink" title="通过Future取消"></a>通过Future取消</h3><p><code>ExecutorService.submit</code>会返回一个<code>Future</code>来描述任务。<code>Future</code>有一个<code>cancel</code>方法,它需要一个<code>boolean</code>类型的参数: <code>mayInterruptIfRunning</code>，它的返回值表示取消尝试是否成功（这仅仅告诉你它是否能够接收中断，而不是任务是否检测并处理了中断）。当<code>mayInterruptIfRunning</code>为true，并且任务当前正在某个线程中运行，那么这个线程能被中断。把这个参数设置成false意味着“如果还没有启动的话，不要运行这个任务”，这应该用于那些不处理中断的任务中。</p>
<p>当<code>Future.get</code>抛出<code>InterruptedException</code>或<code>TimeoutException</code>时，如果你知道不再需要结果，那么就可以调用<code>Future.cancel</code>来取消任务。</p>
<h3 id="处理不可中断阻塞"><a href="#处理不可中断阻塞" class="headerlink" title="处理不可中断阻塞"></a>处理不可中断阻塞</h3><p><strong>java.io中的同步Socket I/O</strong>：Socket中的<code>InputStream</code>和<code>OutputStream</code>中的read和write方法都不响应中断，但是通过关闭底层的Socket，可以让read或write所阻塞的线程抛出一个<code>SocketException</code>。</p>
<p><strong>java.nio中的同步I/O</strong>：中断一个等待<code>InterruptibleChannel</code>的线程，会导致抛出<code>ClosedByInterruptException</code>，并关闭链路（也会导致其他线程在这条链路的阻塞，抛出<code>ClosedByInterruptException</code>）。关闭一个<code>InterruptibleChannel</code>导致多个阻塞在链路操作上的线程抛出<code>AsynchronousCloseException</code>。大多数标准<code>Channel</code>都实现了<code>InterruptibleChannel</code>。</p>
<p><strong>Selector的异步I/O</strong>：如果一个线程阻塞于<code>Selector.select</code>方法，<code>close</code>方法会导致它通过抛出<code>ClosedSelectorException</code>提前返回。</p>
<p><strong>获取某个锁</strong>：如果一个线程由于等待某个内置锁而阻塞，那么将无法响应中断，因为线程认为它肯定会获得锁，所以将不会理会中断请求。然而显式<code>Lock</code>类提供了<code>lockInterruptibly</code>方法，允许你等待一个锁，并仍然能够响应中断。</p>
<p>采用<code>newTaskFor</code>来封装非标准的取消：<br><code>newTaskFor</code>是一个工厂方法，它将创建<code>Future</code>来代表任务。<code>newTaskFor</code>还能返回一个<code>RunnableFuture</code>接口，该接口扩展了<code>Future</code>和<code>Runnable</code>（并由<code>FutureTask</code>实现）。</p>
<h3 id="停止基于线程的服务"><a href="#停止基于线程的服务" class="headerlink" title="停止基于线程的服务"></a>停止基于线程的服务</h3><p>线程池拥有它的工作者线程，如果需要中断这些线程，那么应该由线程池负责。<code>ExecutorService</code>提供两种关闭方法：使用<code>shutdown</code>平滑关闭，以及使用<code>shutdownNow</code>强行关闭。在进行强行关闭时，会首先关闭当前正在执行的任务，然后返回所有尚未启动的任务清单。</p>
<p>配合使用<code>exec.shutdown()</code>和<code>exec.awaitTermination(timeout,unit)</code>来关闭线程服务。</p>
<p>另一种关闭生产者消费者服务的方法是使用“毒丸”对象。“毒丸”是指一个放在队列上的对象，其含义是：当你得到它时，停止一切工作。注意只有在无界队列中，毒丸对象才能够可靠地工作（要保证一定会被放置进去）。</p>
<h3 id="处理非正常的线程终止"><a href="#处理非正常的线程终止" class="headerlink" title="处理非正常的线程终止"></a>处理非正常的线程终止</h3><p>导致线程提前死亡的最主要原因是<code>RuntimeException</code>。由于这些异常表示出现了某种编程错误或者其他不可修复的错误，因此它们通常不会被捕获。它们不会在调用栈中逐层传递，而是默认地在控制台输出栈追踪消息，并终止线程。</p>
<span class="label primary">当一个线程因为未捕获异常而退出时，JVM会把这个事件报告给应用程序提供的UncaughtExceptionHandler。如果处理器不存在，默认的行为是向System.err打印出栈追踪信息。</span>

<p>为了给线程池设置<code>UncaughtExceptionHandler</code>，需要向<code>ThreadPoolExecutor</code>的构造函数提供一个<code>ThreadFactory</code>。标准线程池允许未捕获的任务异常去结束池线程，但是使用一个<code>try-finally</code>块来接收通知的话，当池线程被终结后，能够有新的线程取代它。如果没有非捕获异常的处理器，或者其他失败通知机制，任务会无声无息地失败，这会导致混乱。如果你想在任务因为异常而失败时获得通知，并且执行一些特定于任务的恢复操作，那么可以将任务封装在能捕获异常的<code>Runnable</code>与<code>Callable</code>中，或者改写<code>ThreadPoolExecutor</code>的<code>afterExecute</code>方法。</p>
<p><strong>令人困惑的是</strong>：只有通过<code>execute</code>提交的任务，才能将它抛出的异常送交给未捕获异常的处理器；而通过<code>submit</code>提交的任务，抛出的任何异常无论是否为受检查的，都被认为是任务返回状态的一部分。如果有<code>submit</code>提交的任务由于抛出了异常而结束，那么这个异常将被<code>Future.get</code>包装在<code>ExecutionException</code>中重新抛出。</p>
<h3 id="JVM关闭"><a href="#JVM关闭" class="headerlink" title="JVM关闭"></a>JVM关闭</h3><p>JVM的关闭方式可以分为三种：</p>
<ul>
<li>正常关闭：当最后一个非守护线程结束或者调用了<code>System.exit</code>或者通过其他特定平台的方法关闭（发送<code>SIGINT</code>，<code>SIGTERM</code>信号或者键入<code>Ctrl-C</code>等）。</li>
<li>强制关闭：通过调用<code>Runtime.halt</code>方法或者是在操作系统中直接(发送<code>SIGKILL</code>信号)kill掉JVM进程。</li>
<li>异常关闭：运行中遇到<code>RuntimeException</code>异常，OOM等。</li>
</ul>
<h4 id="关闭钩子"><a href="#关闭钩子" class="headerlink" title="关闭钩子"></a>关闭钩子</h4><p>在正常关闭中，JVM首先调用所有已注册的关闭钩子，关闭钩子是指通过<code>Runtime.addShutdownHook</code>注册的但尚未开始的线程。JVM并不能保证关闭钩子的调用顺序。在关闭应用程序线程时，如果有（守护或非守护）线程仍然在运行，那么这些线程接下来将与关闭进程并发执行。当所有关闭钩子都执行结束时，如果<code>runFinalizersOnExit</code>为true，那么JVM将运行终结器，然后再停止。JVM并不会停止或中断任何在关闭时仍然运行的应用程序线程。当JVM最终结束时，这些线程将被强行结束。如果关闭钩子或终结器没有执行完成，那么正常关闭进程“挂起”并且JVM必须被强行关闭。当被强行关闭时，只是关闭JVM，而不会运行关闭钩子。</p>
<span class="label danger">关闭钩子应该是线程安全的：它们在访问共享数据时必须使用同步，并应该小心地避免死锁。</span>

<p>关闭钩子可以用于实现服务或应用程序的清理工作（比如：删除临时文件，清除无法由操作系统自动清除的资源等）。</p>
<span class="label warning">关闭钩子不应该依赖于可能被应用程序或其他关闭钩子关闭的服务。</span>因为所有钩子都是并发执行的且不能保证顺序，如果关闭一个服务依赖于另一个服务的时候这会出现竞态条件或死锁等问题。对所有的服务使用唯一的关闭钩子，让它执行一系列的关闭操作，而不是每个服务使用一个可以避免这个问题。

<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>线程可分为两种：普通线程和守护线程。在JVM启动时创建的所有线程中，除了主线程以外，其它的线程都是守护线程（例如：垃圾回收器以及其它执行辅助工作的线程）。当创建一个新线程时，新线程将继承创建它的线程的守护状态。因此在默认情况下，主线程创建的所有线程都是普通线程。</p>
<p>普通线程与守护线程之间的差异仅在于当线程退出时发生的操作。当一个线程退出时，JVM会检查其他正在运行的线程，如果这些线程都是守护线程，那么JVM会正常退出操作。<span class="label warning">当JVM停止时，所有仍然存在的守护线程都将被抛弃——既不会执行finally代码块，也不会执行回卷栈，而JVM只是直接退出。</span></p>
<p>我们应尽可能少地使用守护线程——很少有操作能够在不进行清理的情况下被安全地抛弃。特别是，<span class="label danger">如果在守护线程中执行可能包含I/O操作的任务，那么将是一种危险的行为。</span>守护线程最好用于执行“内部任务”，例如：周期性地从内存的缓存中移除逾期的数据。</p>
<h4 id="终结器"><a href="#终结器" class="headerlink" title="终结器"></a>终结器</h4><p>由于终结器可以在某个由JVM管理的线程中运行，因此终结器访问的任何状态都可能被多个线程访问，这样就<span class="label danger">必须对其访问操作进行同步。终结器并不能保证它们将在何时运行甚至是否会运行，</span>并且复杂的终结器通常还会在对象上产生巨大的性能开销。要编写正确的终结器是非常困难的。在大多数情况下，通过使用finally代码块和显示的close方法，能够比使用终结器更好地管理资源。唯一例外情况在于：<span class="label info">当需要管理对象，并且该对象持有的资源是通过本地方法获得的。</span></p>
<span class="label success">避免使用终结器。</span>

<h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="在任务与执行策略之间的隐性耦合"><a href="#在任务与执行策略之间的隐性耦合" class="headerlink" title="在任务与执行策略之间的隐性耦合"></a>在任务与执行策略之间的隐性耦合</h3><span class="label warning">只有当线程本地值的生命周期受限于任务的生命周期时，在线程池的线程中使用ThreadLocal才有意义，而在线程池的线程中不应该使用ThreadLocal在任务之间传递值。</span>
<br/>
<span class="label primary">只有当任务是同类型的并且相互独立时，线程池的性能才能达到最佳。</span>如果将运行时间较长的与运行时间较短的任务混合在一起，那么除非线程池很大，否则将可能造成<span class="label danger">拥塞</span>。如果提交的任务依赖于其他任务，那么除非线程池无限大，否则将可能造成<span class="label danger">死锁</span>。

<p>只要线程池中的任务需要无限期地等待一些必须由池中其他任务才能提供的资源或条件，例如某个任务等待另一个任务的返回值或执行结果，那么除非线程池足够大，否则将发生线程<span class="label danger">饥饿死锁</span>。</p>
<p>执行时间较长的任务不仅会造成线程池堵塞，甚至还会增加执行时间较短任务的服务时间。有一项技术可以缓解执行时间较长任务造成的影响，即限定任务等待资源的时间，而不要无限地等待。如果在线程池中总是充满了被阻塞的任务，那么也可能表明线程池的规模过小。</p>
<h3 id="设置线程池的大小"><a href="#设置线程池的大小" class="headerlink" title="设置线程池的大小"></a>设置线程池的大小</h3><p>对于<strong>计算密集型任务</strong>，在拥有Ncpu个处理器的系统上，当线程池的大小为Ncpu+1时，通常能实现最优的利用率（即使当计算密集型的线程偶尔由于页缺失故障或其他原因而暂停时，这个额外的线程也能确保CPU的时钟周期不会被浪费）。</p>
<p>对于<strong>包含I/O操作或其他阻塞操作的任务</strong>，由于线程并不会一直执行，因此线程池的规模应该更大。要正确的设置线程池的大小，你必须估算出任务的等待时间与计算时间的比值。这种估算不需要很精确，并且可以通过分析或监控工具获得。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ncpu &#x3D; cpu的数量</span><br><span class="line">Ucpu &#x3D; 目标cpu的利用率，0 ≤ Ucpu ≤ 1</span><br><span class="line">W&#x2F;C &#x3D; 等待时间与计算时间的比率</span><br><span class="line">为保持处理器达到期望的利用率，最优的线程池大小等于：Nthreads &#x3D; Ncpu * Ucpu * (1 + W&#x2F;C)</span><br></pre></td></tr></table></figure>

<p>也可以通过另一种方法来调节线程池大小：在某个基准负载下，分别设置不同大小的线程池来运行应用程序，并观察CPU利用率的水平。</p>
<p>当然，CPU周期并不是唯一影响线程池大小的资源，还包括内存、文件句柄、套接字句柄、数据库连接等。计算这些资源对线程池的约束条件更容易：计算每个任务对该资源的需求量，然后用该资源的可用总量除以每个任务的需求量，所得结果就是线程池大小的上限。</p>
<h3 id="配置ThreadPoolExecutor"><a href="#配置ThreadPoolExecutor" class="headerlink" title="配置ThreadPoolExecutor"></a>配置ThreadPoolExecutor</h3><p>对于<code>Executor</code>，<code>newCachedThreadPool</code>工厂方法是一种很好的默认选择，它能提供比固定大小的线程池更好的排队性能。当需要限制当前任务的数量以满足资源管理需求时，那么可以选择固定大小的线程池，就像在接受网络客户请求的服务器应用程序中，如果不进行限制，那么很容易发生过载问题。</p>
<span class="label primary">只有任务相互独立时，为线程池或者工作队列设置界限才是合理的。</span>如果任务之间存在依赖性，那么有界的线程池或队列就可能导致线程“饥饿”死锁问题。此时应该使用无界的线程池。

<h4 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h4><p>中止（Abort）策略：是默认的饱和策略，该策略将抛出未检查的<code>RejectedExecutionException</code>。<br>抛弃（Discard）策略：会悄悄抛弃该任务。<br>抛弃最旧的（Discard-Oldest）策略：则会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。（<span class="label warning">如果工作队列是一个优先队列，那么“抛弃最旧的”策略将导致抛弃优先级最高的任务，因此最好不要将“抛弃最旧的”饱和策略和优先级队列放在一起使用</span>）。<br>调用者运行（Caller-Runs）策略：实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。它不会在线程池的某个线程中执行新提交的任务，而是在一个调用了<code>execute</code>的线程中执行该任务。由于执行任务需要一定的时间，因此主线程至少在一段时间内不能提交任何任务，从而使得工作者线程有时间来处理正在执行的任务。在这期间，主线程不会调用<code>accept</code>，因此到达的请求将被保存在TCP层的队列而不是在应用程序的队列中。如果持续过载，那么TCP层将最终发现它的请求队列被填满，因此同样会开始抛弃请求。当服务器过载时，这种过载情况会逐渐向外蔓延开来，从线程池到工作队列到应用程序再到TCP层，最终达到客户端，导致服务器在高负载下实现一种平缓的性能降低。</p>
<h4 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h4><p>线程池需要创建一个线程，都要通过线程工厂方法来完成。默认的线程工厂创建一个新的、非守护的线程，并且不包含特殊的配置信息。<code>ThreadFactory</code>只有唯一的方法：<code>newThread</code>，每当线程池需要创建一个新线程时都会调用该方法。</p>
<p>许多情况下都需要使用定制的线程工厂方法：为线程池中的线程指定<code>UncaughtExceptionHandler</code>；实例化一个定制的<code>Thread</code>类用于执行调试信息的记录；给线程取一个更有意义的名称等。</p>
<p>如果在应用程序中需要利用安全策略来控制对某些特殊代码库的访问权限，那么可以通过<code>Executor</code>中的<code>privilegedThreadFactory</code>工厂来定制自己的线程工厂。</p>
<p>如果<code>Executor</code>是通过<code>Executors</code>中的某个工厂方法创建的，那么可以将结果的类型强转为<code>ThreadPoolExecutor</code>以访问设置器，在构造后更改其属性。</p>
<p>在<code>Executors</code>中包含一个<code>unconfigurableExecutorService</code>工厂方法，该方法对一个现有的<code>ExecutorService</code>进行包装，使其只暴露出<code>ExecutorService</code>的方法，因此不能对其进行配置。</p>
<h3 id="扩展ThreadPoolExecutor"><a href="#扩展ThreadPoolExecutor" class="headerlink" title="扩展ThreadPoolExecutor"></a>扩展ThreadPoolExecutor</h3><p><code>ThreadPoolExecutor</code>是可扩展的，它提供了<code>beforeExecute</code>，<code>afterExecute</code>和<code>terminated</code>方法可用于扩展其行为。</p>
<p>无论任务是从<code>run</code>中正常返回，还是抛出一个异常而返回，<code>afterExecute</code>都会被调用（如果任务在完成后带有一个<code>Error</code>，那么就不会调用<code>afterExecute</code>）。如果<code>beforeExecute</code>抛出一个<code>RuntimeException</code>，那么任务将不被执行，并且<code>afterExecute</code>也不会被调用。</p>
<span class="label success">当串行循环中的各个迭代操作之间彼此独立，并且每个迭代操作执行的工作量比管理一个新任务时带来的开销更多，那么这个串行循环就适合并行化。</span>

<hr>
<ul>
<li><em>《Java并发编程实战》</em></li>
</ul>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发编程的艺术</title>
    <url>/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF.html</url>
    <content><![CDATA[<h2 id="并发编程的挑战"><a href="#并发编程的挑战" class="headerlink" title="并发编程的挑战"></a>并发编程的挑战</h2><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>上下文切换：CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</p>
<a id="more"></a>

<div class="tabs" id="上下文切换"><ul class="nav-tabs"><li class="tab active"><a href="#上下文切换-1">减少方法</a></li><li class="tab"><a href="#上下文切换-2">实践案例</a></li><li class="tab"><a href="#上下文切换-3">分析工具</a></li></ul><div class="tab-content"><div class="tab-pane active" id="上下文切换-1"><ul>
<li>无锁并发编程</li>
<li>CAS算法</li>
<li>使用最少线程</li>
<li>使用协程</li>
</ul></div><div class="tab-pane" id="上下文切换-2"><ul>
<li>减少<span class="label warning">WAITTING</span>线程数，因为每一次从<span class="label warning">WAITTING</span>到<span class="label danger">RUNNABLE</span>都会进行一次上下文的切换。</li>
</ul></div><div class="tab-pane" id="上下文切换-3"><p><code>vmstat</code></p></div></div></div>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁：多个进程在执行过程中，因争夺同类资源且资源分配不当而造成的一种互相等待的现象，若无外力作用，它们都将永远无法继续执行，这种状态称为死锁。</p>
<div class="tabs" id="死锁"><ul class="nav-tabs"><li class="tab active"><a href="#死锁-1">产生原因</a></li><li class="tab"><a href="#死锁-2">必要条件</a></li><li class="tab"><a href="#死锁-3">规避方法</a></li><li class="tab"><a href="#死锁-4">分析工具</a></li></ul><div class="tab-content"><div class="tab-pane active" id="死锁-1"><ul>
<li>不可剥夺资源的竞争<blockquote>
<p>可剥夺资源：某进程在获得该类资源时，该资源同样可以被其他进程或系统剥夺。<br>不可剥夺资源：系统把该类资源分配给某个进程时不能强制收回，只能在该进程使用完成后自动释放。</p>
</blockquote>
</li>
<li>进程推进顺序不当</li>
</ul></div><div class="tab-pane" id="死锁-2"><ul>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul></div><div class="tab-pane" id="死锁-3"><ul>
<li>避免一个线程同时获取多个锁</li>
<li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源</li>
<li>尝试使用定时锁来替代使用内部锁机制</li>
<li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况</li>
<li>避免对长时间的计算任务和阻塞的I/O操作加锁</li>
</ul></div><div class="tab-pane" id="死锁-4"><p><code>jps</code>, <code>jstack $pid</code></p></div></div></div>

<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>活锁：任务或者执行者没有被阻塞，但由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败，……</p>
<p>规避方法:</p>
<ul>
<li>引入一些随机性</li>
<li>约定重试机制避免再次冲突</li>
</ul>
<h3 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h3><p>硬件资源限制：可以考虑使用集群并行执行程序。<br>软件资源限制：可以考虑使用资源池将资源复用。</p>
<h2 id="java并发机制的底层实现原理"><a href="#java并发机制的底层实现原理" class="headerlink" title="java并发机制的底层实现原理"></a>java并发机制的底层实现原理</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><table>
<thead>
<tr>
<th>术语</th>
<th>释义</th>
</tr>
</thead>
<tbody><tr>
<td>内存屏障</td>
<td>一组处理器指令，由于实现对内存操作的顺序限制。</td>
</tr>
<tr>
<td>原子操作</td>
<td>不可中断的一个或一系列操作。</td>
</tr>
<tr>
<td>缓存行</td>
<td>缓存中可以分配的最小存储单位。处理器填写缓存线时会加载整个缓存线，需要使用多个主内存读周期。</td>
</tr>
<tr>
<td>缓存行填充</td>
<td>当处理器识别到从主存中读取的操作数是可缓存的，处理器读取整个缓存行到适当的缓存中（L1,L2,L3或所有）。</td>
</tr>
<tr>
<td>缓存命中</td>
<td>如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的内存地址，处理器从缓存中读取操作数，而不是从主存中读取。</td>
</tr>
<tr>
<td>写命中</td>
<td>当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存，这个操作被称为写命中。</td>
</tr>
<tr>
<td>写缺失</td>
<td>一个有效的缓存行被写入到不存在的内存区域。</td>
</tr>
<tr>
<td>CPU流水线</td>
<td>工作方式就像工业生产中的装配流水线，在CPU中由5<del>6个不同功能的电路单元组成一条指令处理流水线，然后将一条x86指令拆分为5</del>6步再由这些电路单元分别执行，这样就能实现一个CPU时钟周期内完成一条指令，因此提高CPU的运算速度。</td>
</tr>
<tr>
<td>内存顺序冲突</td>
<td>一般由假共享引起，假共享是指多个CPU同时修改同一个缓存行的不同部分而引起其中一个CPU操作无效，当出现这个内存顺序冲突时，CPU必须清空流水线。</td>
</tr>
</tbody></table>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p><code>volatile</code>变量修饰的共享变量进行写操作的时候会多出一个<em>lock前缀的指令</em>，该指令在多核处理器下会引发：</p>
<ol>
<li>将当前处理器缓存行的数据回写到系统内存。</li>
<li>这个回写内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li>
</ol>
<p>实现原理：</p>
<blockquote>
<p>声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p>
</blockquote>
<p>为什么<code>LinkedTransferQueue</code>中头、尾volatile变量追加64字节能够提高并发编程的效率呢？</p>
<p>大部分处理器高速缓存行是64个字节宽，且不支持部分填充缓存行。使用追加到64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，使头、尾节点在修改时不会互相锁定。</p>
<p>是不是在使用<code>volatile</code>变量时都应该追加到64字节呢？<strong>并非如此</strong>，在两种场景下不应该使用这种方式：</p>
<ul>
<li>缓存行非64字节宽的处理器</li>
<li>共享变量不会被频繁地写</li>
</ul>
<div class="note warning">
            <p>不过这种追加字节的方式在Java 7下可能不生效，因为Java 7变得更加智慧，它会淘汰或重新排列无用字段，需要使用其他追加字节的方式。</p>
          </div>

<div class="note info">
            <p>你可能想看这里: <a href="https://blog.csdn.net/aigoogle/article/details/41517213" target="_blank" rel="noopener">神奇的缓存行填充</a></p>
          </div>

<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>实现原理：</p>
<blockquote>
<p>JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用<code>monitorenter</code>和<code>monitorexit</code>指令实现的，而方法同步是使用另外一种方式实现的（方法修饰符上的<code>ACC_SYNCHRONIZED</code>），细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。<code>monitorenter</code>指令是在编译后插入到同步代码块的开始位置，而<code>monitorexit</code>是插入到方法结束处和异常处，JVM要保证每个<code>monitorenter</code>必须有对应的<code>monitorexit</code>与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到<code>monitorenter</code>指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。</p>
</blockquote>
<p><code>synchronized</code>用的锁是存在Java对象头里的。其存储结构如下示：</p>
<p>第一部分：</p>
<img src="/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/markword-32bit-vm.PNG" class="">
<img src="/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/markword-64bit-vm.PNG" class="">

<p>第二部分：<br>类型指针，即对象指向类元数据的指针，虚拟机通过这个指针来确定对象是哪个类的实例。但并不是所有虚拟机实现都需要在对象头上保持类型指针。因为有的虚拟机使用<em>句柄</em>进行对象访问定位，而不是<em>直接指针</em>访问。</p>
<p>第三部分：<br>如果对象是一个java数组，那么在对象头中还必须有一块用于记录数组长度的数据。可能是对齐填充，并不是必要存在的，也没有特别含义，仅起占位符的作用。</p>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：<strong>无锁状态</strong>、<strong>偏向锁状态</strong>、<strong>轻量级锁状态</strong>和<strong>重量级锁</strong>状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。</p>
<img src="/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/synchonized.png" class="">

<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>原子操作：不可被中断的一个或一系列操作。</p>
<p>处理器如何实现原子操作：</p>
<ul>
<li>通过总线锁保证原子性（总线上声明<code>lock#</code>信号）</li>
<li>通过缓存锁定来保证原子性（修改内部的内存地址+缓存一致性机制使<em>单个</em>缓存行无效）</li>
</ul>
<p>Java如何实现原子操作：</p>
<ul>
<li>使用循环CAS<ul>
<li>ABA问题：解决方法追加版本号，可参考<code>AtomicStampedReference</code></li>
<li>循环时间长开销大</li>
<li>只能保证一个共享变量的原子操作：解决方法使用锁替换或把多个共享变量合并成一个共享变量来操作，可参考<code>AtomicReference</code></li>
</ul>
</li>
<li>使用锁机制</li>
</ul>
<h2 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h2><h3 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h3><p>命令式编程中，线程之间的通信机制有两种：<strong>共享内存</strong>和<strong>消息传递</strong>。</p>
<p>从源代码到指令序列可能发生哪些重排序？</p>
<ul>
<li>编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序：如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。<blockquote>
<p>如果两个操作访问<em>同一个变量</em>，且这两个操作中<em>有一个为写操作</em>，此时这两个操作之间就存在数据依赖性。</p>
</blockquote>
</li>
<li>内存系统的重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ul>
<img src="/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/code-to-instruction-reorder.PNG" class="" title="源代码到指令序列的重排序">

<p>Java线程之间的通信由<em>Java内存模型</em>控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。确保在不同的编译器和不同的处理器平台之上，为程序员提供一致的内存可见性保证。</p>
<p>对于编译器重排序，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。<br>对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入内存屏障指令来禁止特定类型的处理器重排序。</p>
<div class="note info">
            <p>常见的处理器（基本都有写缓冲区）都允许Store-Load重排序；都不允许对存在数据依赖的操作做重排序。</p>
          </div>

<h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><p>as-if-serial语义：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</p>
<h3 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h3><p>顺序一致性内存模型有哪些特性？</p>
<ul>
<li>一个线程中的所有操作必须按照程序的顺序串行执行。</li>
<li>（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li>
</ul>
<p>在JMM中，临界区内的代码可以重排序（但JMM不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。<br>JMM不保证对64位的long型和double型变量的写操作具有原子性。</p>
<h3 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h3><p>理解volatile特性的一个好方法是：把对volatile变量的单个读/写，看成是使用<strong>同一个锁</strong>对这些<strong>单个</strong>读/写操作做了同步。</p>
<p>这意味着，1. 对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。2. 即使是64位的long型和double型变量，只要它是volatile变量，对该变量的单个读/写就具有原子性。</p>
<p>内存屏障：</p>
<p>硬件层的内存屏障分为两种：<code>Load Barrier</code> 和 <code>Store Barrier</code> 即读屏障和写屏障。</p>
<div class="tabs" id="内存屏障"><ul class="nav-tabs"><li class="tab active"><a href="#内存屏障-1">作用</a></li><li class="tab"><a href="#内存屏障-2">分类</a></li><li class="tab"><a href="#内存屏障-3">java中的分类</a></li></ul><div class="tab-content"><div class="tab-pane active" id="内存屏障-1"><ol>
<li>阻止屏障两侧的指令重排序；</li>
<li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效（必须从主内存从新加载）。</li>
</ol></div><div class="tab-pane" id="内存屏障-2"><ul>
<li>对于<code>Load Barrier</code>来说，在指令前插入<code>Load Barrier</code>，可以让高速缓存中的数据失效，强制从新从主内存加载数据；</li>
<li>对于<code>Store Barrier</code>来说，在指令后插入<code>Store Barrier</code>，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。</li>
</ul></div><div class="tab-pane" id="内存屏障-3"><img src="/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/java-memory-barrier.PNG" class=""></div></div></div>

<p>volatile的编译器重排序规则：</p>
<ul>
<li>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</li>
<li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。</li>
<li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。</li>
</ul>
<p>volatile的处理器内存屏障插入策略：</p>
<ul>
<li>在每个volatile写操作的前面插入一个<code>StoreStore</code>屏障。</li>
<li>在每个volatile写操作的后面插入一个<code>StoreLoad</code>屏障。</li>
<li>在每个volatile读操作的后面插入一个<code>LoadLoad</code>屏障。</li>
<li>在每个volatile读操作的后面插入一个<code>LoadStore</code>屏障。</li>
</ul>
<div class="note ">
            <p>我的疑惑：为什么不需要在每个volatile写操作的前面插入一个LoadStore屏障，来防止第一个普通读和第二个volatile写操作重排序？？？</p>
          </div>

<h3 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h3><p>在<code>ReentrantLock</code>中，调用<code>lock()</code>方法获取锁；调用<code>unlock()</code>方法释放锁。</p>
<p>加锁方法首先读volatile变量<code>state</code>，在释放锁的最后写volatile变量<code>state</code>。根据volatile的happens-before规则，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变得对获取锁的线程可见。</p>
<p>获取锁中的CAS又如何同时具有volatile读和volatile写的内存语义？</p>
<p>从编译器角度：<br>编译器不会对volatile读与volatile读后面的任意内存操作重排序；编译器不会对volatile写与volatile写前面的任意内存操作重排序。组合这两个条件，意味着为了同时实现volatile读和volatile写的内存语义，编译器不能对CAS与CAS前面和后面的任意内存操作重排序。</p>
<p>从处理器角度：<br>在常见的intel X86处理器中，源码中会根据当前处理器的类型来决定是否为<code>cmpxchg</code>指令添加<code>lock</code>前缀。lock前缀的第2点和第3点所具有的内存屏障效果，足以同时实现volatile读和volatile写的内存语义。</p>
<blockquote>
<p>intel的手册对lock前缀的说明: 1. 确保对内存的读-改-写操作原子执行。2. 禁止该指令，与之前和之后的读和写指令重排序。3. 把写缓冲区中的所有数据刷新到内存中。</p>
</blockquote>
<p>综上述，可见<code>ReentrantLock</code>内存语义实现利用了volatile变量的写-读所具有的内存语义和CAS所附带的volatile读和volatile写的内存语义。</p>
<h3 id="final域的内存语义"><a href="#final域的内存语义" class="headerlink" title="final域的内存语义"></a>final域的内存语义</h3><p>final域的编译器重排序规则：</p>
<ul>
<li>在构造函数内对一个final域/final域引用的对象成员域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
<li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</li>
</ul>
<p>final域的处理器内存屏障插入策略：</p>
<ul>
<li>编译器会在final域的写之后，构造函数return之前，插入一个<code>StoreStore</code>屏障。禁止处理器把final域的写重排序到构造函数之外。</li>
<li>编译器会在读final域操作的前面插入一个<code>LoadLoad</code>屏障。禁止处理器把存在间接依赖关系的操作做重排序。</li>
</ul>
<p>final域为引用类型时，若多个线程同时访问其内的可变状态变量，仍需要使用同步原语（lock或volatile）来确保内存可见性。</p>
<div class="note danger">
            <p><code>final</code>引用不能从构造函数内“逸出”。</p>
          </div>

<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>happens-before定义：</p>
<p>JMM对程序员的<span class="label danger">承诺</span>：如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</p>
<p>JMM对编译器和处理器重排序的约束原则：两个操作之间存在happens-before关系，<u>并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行</u>。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（即JMM允许这种重排序）。</p>
<p>happens-before规则：</p>
<ul>
<li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li>
<li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li>
<li><code>start()</code>规则：如果线程A执行操作<code>ThreadB.start()</code>（启动线程B），那么A线程的<code>ThreadB.start()</code>操作happens-before于线程B中的任意操作。</li>
<li><code>join()</code>规则：如果线程A执行操作<code>ThreadB.join()</code>并成功返回，那么线程B中的任意操作happens-before于线程A从<code>ThreadB.join()</code>操作成功返回。</li>
<li>中断法则：一个线程调用另一个线程的<code>interrupt()</code> happens-before于被中断的线程发现中断。</li>
<li>终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。</li>
<li>传递性规则：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
</ul>
<a class="btn" href="#as-if-serial语义">
            as-if-serial语义
          </a>保证单线程内程序的执行结果不被改变，<a class="btn" href="#happens-before">
            happens-before关系
          </a>保证正确同步的多线程程序的执行结果不被改变。

<h2 id="java并发编程的基础"><a href="#java并发编程的基础" class="headerlink" title="java并发编程的基础"></a>java并发编程的基础</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><div class="note danger">
            <p>线程优先级不能作为程序正确性的依赖，因为操作系统可以完全不用理会Java线程对于优先级的设定。</p>
          </div>

<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><table>
<thead>
<tr>
<th><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html" target="_blank" rel="noopener">线程状态</a></th>
<th>含义</th>
<th>诱发动作</th>
</tr>
</thead>
<tbody><tr>
<td>NEW</td>
<td>新建线程对象，但尚未启动（<code>start()</code>）</td>
<td><code>new Thread()</code></td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>一个可运行的线程，包含就绪（等待系统调度分配cpu时间片）和运行中（获得cpu时间片开始运行）两种状态。</td>
<td>Ready: <code>Thread.yield()</code>, Running: 被线程调度器选择</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>被阻塞等待监视器锁。</td>
<td>IO阻塞, 等待进入同步代码块或方法</td>
</tr>
<tr>
<td>WAITING</td>
<td>无限期等待另一个线程执行一个特定操作（通知或中断）。</td>
<td><code>Object.wait()</code>, <code>Thread.join()</code>, <code>LockSupport.park()</code></td>
</tr>
<tr>
<td>TIMED_WAITING</td>
<td>具有指定等待时间，可以在指定的时间内自行返回。</td>
<td><code>Thread.sleep(long)</code>,  <code>Object.wait(long timeout)</code>,  <code>Thread.join(long timeout)</code>,  <code>LockSupport.parkNanos(Object blocker, long nanos)</code>, <code>LockSupport.parkUntil(Object blocker, long deadline)</code></td>
</tr>
<tr>
<td>TERMINATED</td>
<td>线程已经执行完毕。</td>
<td><code>run()</code>退出, <code>Thread.stop()</code>, 线程中断退出,  阻塞IO被关闭</td>
</tr>
</tbody></table>
<img src="/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/thread-state-transition.png" class="" title="线程状态变迁图">

<h4 id="Daemon线程"><a href="#Daemon线程" class="headerlink" title="Daemon线程"></a>Daemon线程</h4><p>可以通过调用<code>Thread.setDaemon(true)</code>将线程设置为Daemon线程，<u>但需要在启动线程之前设置</u>。</p>
<p>当Java虚拟机中不存在非Daemon线程时，虚拟机将会退出。Java虚拟机中的所有Daemon线程都需要立即终止。因此在构建Daemon线程时，<u>不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑</u>。</p>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p><code>thread.start()</code>：启动线程。启动一个线程前，<span class="label primary">最好为这个线程设置线程名称</span>，因为这样便于使用jstack分析程序或者进行问题排查。<br><code>thread.isInterrupted()</code>：判断线程是否被中断。</p>
<ul>
<li>如果线程已经处于终结状态，即使被中断过，在调用该线程对象的<code>isInterrupted()</code>时依旧会返回false。</li>
<li>从Java的API中可以看到，许多声明抛出<code>InterruptedException</code>的方法（例如：<code>Thread.sleep(long millis)</code>方法）在抛出<code>InterruptedException</code>之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出<code>InterruptedException</code>，此时调用<code>isInterrupted()</code>方法将会返回false。</li>
</ul>
<p><code>Thread.interrupted()</code>：对当前线程的中断标识位进行复位。<br><del><code>thread.suspend()</code></del>：在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。<br><del><code>thread.stop()</code></del>：在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。<br><del><code>thread.sleep()</code></del>：也是占有着资源进入睡眠状态，而<code>Object.wait()</code>则相反。<br><code>thread.yield()</code>：使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。cpu调度器会从众多的可执行态里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到了。<br>threadA执行<code>threadB.join()</code>：当前线程A等待线程B终止之后才从<code>threadB.join()</code>返回。原理利用了等待/通知机制，threadB终止之后会调用线程自身的<code>notifyAll()</code>方法，通知所有等待在该线程对象上的线程。</p>
<h4 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h4><ol>
<li>使用<code>wait()</code>、<code>notify()</code>和<code>notifyAll()</code>时需要先对调用对象加锁。</li>
<li>调用<code>wait()</code>方法后，线程状态由<code>RUNNING</code>变为<code>WAITING</code>，并将当前线程放置到对象的<strong>等待队列</strong>。</li>
<li><code>notify()</code>或<code>notifyAll()</code>方法调用后，等待线程依旧不会从<code>wait()</code>返回，需要调用<code>notify()</code>或<br><code>notifAll()</code>的线程释放锁之后，等待线程才有机会从<code>wait()</code>返回。</li>
<li><code>notify()</code>方法将等待队列中的一个等待线程从<strong>等待队列</strong>中移到<strong>同步队列</strong>中，而<code>notifyAll()</code>方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由<code>WAITING</code>变为<code>BLOCKED</code>。</li>
<li>从<code>wait()</code>方法返回的前提是获得了调用对象的锁。</li>
</ol>
<p>等待/通知的经典范式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (对象) &#123;</span><br><span class="line">    <span class="keyword">while</span> (条件不满足) &#123;</span><br><span class="line">        对象.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    对应的处理逻辑</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (对象) &#123;</span><br><span class="line">    改变条件</span><br><span class="line">    对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="管道输入-输出流"><a href="#管道输入-输出流" class="headerlink" title="管道输入/输出流"></a>管道输入/输出流</h4><p>管道输入/输出流主要用于线程之间的数据传输，而传输的媒介为内存。</p>
<p>对于Piped类型的流，必须先要进行绑定，也就是调用<code>connect()</code>方法，如果没有将输入/输出流绑定起来，对于该流的访问将会抛出异常。</p>
<h2 id="java中的锁"><a href="#java中的锁" class="headerlink" title="java中的锁"></a>java中的锁</h2><p>锁的经典范式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    对应的处理逻辑</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放。<span class="label danger">不要</span>将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致莫名的锁释放。</p>
<h3 id="显示锁和隐式锁的区别"><a href="#显示锁和隐式锁的区别" class="headerlink" title="显示锁和隐式锁的区别"></a>显示锁和隐式锁的区别</h3><table>
<thead>
<tr>
<th>synchronized</th>
<th><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/Lock.html" target="_blank" rel="noopener">Lock</a></th>
</tr>
</thead>
<tbody><tr>
<td>关键字，隐式获取/释放锁</td>
<td>接口，显式获取/释放锁</td>
</tr>
<tr>
<td>代码简单，被大多程序员广泛使用，默认推荐</td>
<td>代码稍复杂，在try块外获取锁，在finally块中释放锁，迫于性能调优时再用</td>
</tr>
<tr>
<td>-</td>
<td>可尝试非阻塞获取锁（线程尝试获取锁，若锁未被其他线程持有，则成功获取并持有锁）</td>
</tr>
<tr>
<td>-</td>
<td>可中断获取锁（获取到锁的线程能够响应中断，当该线程被中断时，中断异常将被抛出，同时锁释放）</td>
</tr>
<tr>
<td>-</td>
<td>可超时获取锁（在指定的截止时间之前获取锁，若超时仍无法获取锁，则返回）</td>
</tr>
</tbody></table>
<p>锁是<strong>面向使用者</strong>的，它定义了使用者与锁交互的接口(比如可以允许两个线程并行访问),隐藏了实现细节;<br>同步器<strong>面向锁的实现者</strong>,它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。</p>
<img src="/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/concurrent-pkg-impl.png" class="" title="concurrent包的实现示意图">

<h3 id="同步器可重写的方法"><a href="#同步器可重写的方法" class="headerlink" title="同步器可重写的方法"></a>同步器可重写的方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean tryAcquire(int arg)</code></td>
<td>独占式获取同步状态。实现该方法需要查询当前同步状态并判断是否符合预期，然后再进行CAS设置同步状态。</td>
</tr>
<tr>
<td><code>boolean tryRelease(int arg)</code></td>
<td>独占式释放同步状态。等待获取同步状态的线程将有机会获取同步状态。</td>
</tr>
<tr>
<td><code>int tryAcquireShared(int arg)</code></td>
<td>共享式获取同步状态。返回大于等于0的值表示获取成功，否则获取失败。</td>
</tr>
<tr>
<td><code>boolean tryReleaseShared(int arg)</code></td>
<td>共享式释放同步状态。</td>
</tr>
<tr>
<td><code>boolean isHeldExclusively()</code></td>
<td>同步状态是否在独占模式下被线程占用。</td>
</tr>
</tbody></table>
<h3 id="同步器提供的便捷方法"><a href="#同步器提供的便捷方法" class="headerlink" title="同步器提供的便捷方法"></a>同步器提供的便捷方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>void acquire(int arg)</code></td>
<td>独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回。否则，将会进入同步队列等待，该方法<strong>忽略中断</strong>。</td>
</tr>
<tr>
<td><code>void acquireInterruptibly(int arg) throws InterruptedException</code></td>
<td>同上，但该方法响应中断，在同步队列中等待的线程可以被中断，会抛出InterruptedException并返回。</td>
</tr>
<tr>
<td><code>boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException</code></td>
<td>同上且增加了超时限制，如果在超时时间内没有获取到同步状态将返回false，否则返回true。</td>
</tr>
<tr>
<td><code>boolean release(int arg)</code></td>
<td>独占式释放同步状态。释放后会唤醒同步队列中的第一个节点所包含的线程。</td>
</tr>
<tr>
<td><code>void acquireShared(int arg)</code></td>
<td>共享式获取同步状态，若同步未获取获取成功则会进入同步队列等待。与独占式获取主要区别在<strong>同一时刻可以有多个线程</strong>获取同步状态。</td>
</tr>
<tr>
<td><code>void acquireSharedInterruptibly(int arg) throws InterruptedException</code></td>
<td>同上，但该方法响应中断</td>
</tr>
<tr>
<td><code>boolean tryAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException</code></td>
<td>同上且增加了超时限制</td>
</tr>
<tr>
<td><code>boolean releaseShared(int arg)</code></td>
<td>共享式释放同步状态。</td>
</tr>
</tbody></table>
<h3 id="同步器中节点的含义"><a href="#同步器中节点的含义" class="headerlink" title="同步器中节点的含义"></a>同步器中节点的含义</h3><table>
<thead>
<tr>
<th><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html" target="_blank" rel="noopener">AQS</a>#Node的属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>int waitStatus</code></td>
<td>状态字段，仅可能取以下几种值：状态字段，仅可能取以下几种值：<br/><br/><code>0</code>: 初始化状态。<br/><code>CANCELLED(1)</code>: 由于取消或中断，节点取消获取同步状态，节点进入该状态后将不会再发生变化。注意取消节点的线程永远不会再阻塞。<br/><code>SIGNAL(-1)</code>: 当前节点的后继节点是(或不久的将来)阻塞的(通过park)，因此当前节点释放或取消同步状态时必须通知(通过unpark)后继节点，为了避免竞争激烈，acquire方法必须首先表明他们需要一个启动信号，然后原子性重试获取同步状态，最后在失败时阻塞。<br/><code>CONDITION(-2)</code>: 此节点当前处于条件队列中。直到被转移(signal/signalAll)才会被加入到同步队列中，转移后状态将被设置为0。<br/><code>PROPAGATE(-3)</code>: releaseShared应该传播给其他节点。在doReleaseShared中设置（仅限头节点）以确保继续传播，即使其他操作已经介入。</td>
</tr>
<tr>
<td><code>Node prev</code></td>
<td>前驱节点，当节点加入到同步队列时被设置（CAS尾部加入）</td>
</tr>
<tr>
<td><code>Node next</code></td>
<td>后继节点</td>
</tr>
<tr>
<td><code>Thread thread</code></td>
<td>获取同步状态的线程</td>
</tr>
<tr>
<td><code>Node nextWaiter</code></td>
<td>条件队列中的后继节点，或特殊值<code>SHARED</code>。因为条件队列只有在保持独占模式时才被访问，所以我们只需要一个简单的链接队列来在节点等待条件时保存节点。然后将它们转移到同步队列中以重新获取同步状态。并且因为condition只能是独占的，所以我们通过使用SHARED特殊值来指示共享模式。</td>
</tr>
</tbody></table>
<h3 id="Object的监视器方法与Condition接口对比"><a href="#Object的监视器方法与Condition接口对比" class="headerlink" title="Object的监视器方法与Condition接口对比"></a>Object的监视器方法与Condition接口对比</h3><table>
<thead>
<tr>
<th>对比项</th>
<th>Object监视器方法</th>
<th><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/Condition.html" target="_blank" rel="noopener">Condition</a></th>
</tr>
</thead>
<tbody><tr>
<td>前置条件</td>
<td>获取对象的监视器锁</td>
<td>调用<code>Lock.lock()</code>获取锁<br/> 调用<code>Lock.newCondition()</code>获取<code>Condition</code>对象</td>
</tr>
<tr>
<td>调用方法</td>
<td>直接调用，如：<code>object.wait()</code></td>
<td>直接调用，如：<code>condition.await()</code></td>
</tr>
<tr>
<td>等待队列个数</td>
<td>一个</td>
<td>多个</td>
</tr>
<tr>
<td>当前线程释放锁并进入等待队列</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>当前线程释放锁并进入等待队列，在等待状态中<em>不</em>响应中断</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>当前线程释放锁并进入超时等待状态</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>当前线程释放锁并进入等待状态到将来的某个时间</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>唤醒等待队列中的一个线程</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>唤醒等待队列中的全部线程</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<img src="/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/sync-and-wait-queue.png" class="" title="同步队列和等待队列的模样">

<h3 id="通过源码看世界"><a href="#通过源码看世界" class="headerlink" title="通过源码看世界"></a>通过源码看世界</h3><h4 id="AQS超时获取锁的源代码"><a href="#AQS超时获取锁的源代码" class="headerlink" title="AQS超时获取锁的源代码"></a>AQS超时获取锁的源代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// acquire，acquireInterruptibly与此大同小异</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) || <span class="comment">// 先尝试获取一次</span></span><br><span class="line">        doAcquireNanos(arg, nanosTimeout); <span class="comment">// 尝试失败，将其包装成Node，放入等待队列，并等待前驱节点唤醒</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE); <span class="comment">// 包装成独占模式等待者</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 若是头节点，尝试获取同步状态，成功则将自己设置成头节点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// 释放前驱节点引用，便于GC回收原头节点</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) <span class="comment">// 超时仍未获取到，则返回fasle</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">// 如果前驱节点状态(SIGNAL)正常，则等待；若已取消(CANCELLED)为其寻找一个正常的前驱节点；否则CAS设置前驱节点状态为正常态</span></span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold) <span class="comment">// 超时时间大于阈值，则使用parkNanos超时等待；否则采用高速自旋重试</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) <span class="comment">// 被唤醒发现线程中断，则抛出中断异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) </span><br><span class="line">            cancelAcquire(node); <span class="comment">// 超时或中断退出时，则取消获取同步状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/aqs-doAcquireNanos.png" class="" title="AQS超时获取锁的流程图">

<h4 id="AQS释放锁的源代码"><a href="#AQS释放锁的源代码" class="headerlink" title="AQS释放锁的源代码"></a>AQS释放锁的源代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">// 尝试释放同步状态</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h); <span class="comment">// 释放成功，唤醒头节点的后继节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) </span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);　<span class="comment">// 将头节点状态修改为0</span></span><br><span class="line"></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123; <span class="comment">// 头节点不存在后继节点或后继节点已取消获取同步状态</span></span><br><span class="line">        s = <span class="keyword">null</span>;　</span><br><span class="line">        <span class="comment">// 从前往后寻找不一定能找到刚刚加入队列的后继节点, 因为在Node addWaiter(Node mode)中，是先CAS设置尾节点，再设置前驱节点和尾节点的引用关系</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev) </span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) <span class="comment">// 从队尾往前找，找到第一个需要唤醒的节点</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread); <span class="comment">// 唤醒线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ReentrantLock非公平获取锁源代码"><a href="#ReentrantLock非公平获取锁源代码" class="headerlink" title="ReentrantLock非公平获取锁源代码"></a>ReentrantLock非公平获取锁源代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NonfairSync类中</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">// 非公平锁直接尝试获取锁</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync父类中</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 目前没有其他线程获得锁，当前线程就可以尝试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">// CAS修改同步状态</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// 当前线程持有锁，支持重入</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc); <span class="comment">// 已持有锁，可直接修改</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 修改失败返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ReentrantLock公平获取锁源代码"><a href="#ReentrantLock公平获取锁源代码" class="headerlink" title="ReentrantLock公平获取锁源代码"></a>ReentrantLock公平获取锁源代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FairSync类中</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">// 多了这个判断，需要判断队列中是否还有前驱节点线程</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ReentrantLock释放锁的源代码"><a href="#ReentrantLock释放锁的源代码" class="headerlink" title="ReentrantLock释放锁的源代码"></a>ReentrantLock释放锁的源代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) <span class="comment">// 当前线程未持有锁，不可释放</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 由于锁可重入，当同步状态等于0时，才代表真正释放掉</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ReentrantReadWriteLock获取释放锁源代码"><a href="#ReentrantReadWriteLock获取释放锁源代码" class="headerlink" title="ReentrantReadWriteLock获取释放锁源代码"></a>ReentrantReadWriteLock获取释放锁源代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*以高16位表示所有线程获取读锁数，以低16位表示单个线程获取写锁数 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT); <span class="comment">// 0x00010000</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>; <span class="comment">// 低16位全为1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125; <span class="comment">// 根据同步状态计算已持有的读锁数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125; <span class="comment">// 根据同步状态计算已持有的写锁数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123; <span class="comment">// 获取独占锁（写锁）</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 持有的写锁数</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="comment">// 如果同步状态不为0但是写锁数为0,代表持有读锁(不为0)</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread()) <span class="comment">// 已持有读锁或不是当前线程持有写锁，均不可再获取写锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT) <span class="comment">// 获取写锁数超限</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(c + acquires); <span class="comment">// 是当前线程持有写锁，可重入获取</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() || <span class="comment">// 公平模式下需要判断同步队列中是否有前驱节点在等待</span></span><br><span class="line">        !compareAndSetState(c, c + acquires)) <span class="comment">// 无线程获取写锁，CAS获取锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current); <span class="comment">// 获取成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively()) <span class="comment">// 非持有写锁的线程不可释放写锁</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>; <span class="comment">// 因为可重入，当同步状态低16位全为0，才代表成功释放</span></span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(nextc); </span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123; <span class="comment">// 获取共享锁(读锁)</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)　<span class="comment">// 写锁已被持有但不是当前线程，获取读锁阻塞</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);　<span class="comment">// 持有的读锁数</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp; <span class="comment">// 公平模式下需要判断同步队列中是否有前驱节点在等待</span></span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123; <span class="comment">// 无线程持有写锁，所有线程都可获取读锁</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123; <span class="comment">// 无线程持有读锁，标记当前线程首次获取读锁1次</span></span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// 有线程持有读锁，若当前线程是首次获取读锁的线程，则增加读锁持有数</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 有线程持有读锁，但不是首次获取读锁的线程，则初始化线程相应读锁持有数</span></span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) <span class="comment">// 无缓存或缓存的计数不是当前线程</span></span><br><span class="line">                cachedHoldCounter = rh = readHolds.get(); <span class="comment">// 获取线程本地缓存</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)  <span class="comment">// 有缓存且当前线程第一次获取锁，则初始化线程(锁计数)本地缓存</span></span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++; <span class="comment">// 当前线程持有读锁数加1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current); <span class="comment">// 自旋获取读锁，用于应对首次尝试CAS未命中和重入读锁的情况</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// 当前线程是第一个获取读锁的线程</span></span><br><span class="line">        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>) <span class="comment">// 线程仅持有1个读锁，释放后即无第一个读线程</span></span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            firstReaderHoldCount--; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123; <span class="comment">// 只获取一次读锁，则直接移除，</span></span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count; <span class="comment">// 减少缓存计数信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 自旋释放读锁</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">            <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">            <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="java中的阻塞队列"><a href="#java中的阻塞队列" class="headerlink" title="java中的阻塞队列"></a>java中的阻塞队列</h2><p>插入和移除操作的4种处理方式：</p>
<table>
<thead>
<tr>
<th>方法/处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody><tr>
<td>插入方法</td>
<td><code>add(e)</code></td>
<td><code>offer(e)</code></td>
<td><code>put(e)</code></td>
<td><code>offer(e, time, unit)</code></td>
</tr>
<tr>
<td>移除方法</td>
<td><code>remove()</code></td>
<td><code>poll()</code></td>
<td><code>take()</code></td>
<td><code>poll(time, unit)</code></td>
</tr>
<tr>
<td>检查方法</td>
<td><code>element()</code></td>
<td><code>peek()</code></td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<p>提供了哪些阻塞队列？</p>
<ul>
<li><code>ArrayBlockingQueue</code>：由数组结构组成的有界阻塞队列。</li>
<li><code>LinkedBlockingQueue</code>：由链表结构组成的有界阻塞队列。</li>
<li><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列。</li>
<li><code>DelayQueue</code>：使用优先级队列实现的无界阻塞延时队列。（延迟队列中的元素到了延迟时间则可以从中取出，否则无法取出）</li>
<li><code>SynchronousQueue</code>：不存储元素的阻塞队列。</li>
<li><code>LinkedTransferQueue</code>：由链表结构组成的无界阻塞队列。</li>
<li><code>LinkedBlockingDeque</code>：由链表结构组成的双向阻塞队列。</li>
</ul>
<h2 id="java中的原子操作类"><a href="#java中的原子操作类" class="headerlink" title="java中的原子操作类"></a>java中的原子操作类</h2><ul>
<li><code>AtomicBoolean</code>：原子更新布尔类型。</li>
<li><code>AtomicInteger</code>：原子更新整型。</li>
<li><code>AtomicLong</code>：原子更新长整型。</li>
<li><code>AtomicIntegerArray</code>：原子更新整型数组里的元素。（对内部的数组元素(将传入数组复制一份)进行修改，不会影响传入的数组）</li>
<li><code>AtomicLongArray</code>：原子更新长整型数组里的元素。</li>
<li><code>AtomicReferenceArray</code>：原子更新引用类型数组里的元素。</li>
<li><code>AtomicReference</code>：原子更新引用类型。</li>
<li><code>AtomicIntegerFieldUpdater</code>：原子更新整型字段的更新器。</li>
<li><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器。</li>
<li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型字段的更新器。</li>
<li><code>AtomicMarkableReference</code>：原子更新带有boolean标记位的引用类型。</li>
<li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。</li>
</ul>
<h2 id="java中的并发工具类"><a href="#java中的并发工具类" class="headerlink" title="java中的并发工具类"></a>java中的并发工具类</h2><ul>
<li><code>CountDownLatch</code>（倒计数器/闭锁）：一个或多个线程等待其他线程完成操作。<span class="label info">用于等待事件。是一次性对象，一旦进入终止状态就不能被重置，只能使用一次。</span></li>
<li><code>CyclicBarrier</code>（循环屏障/栅栏）：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。<span class="label info">用于等待其他线程。可以使用reset()方法重置，多次使用。</span></li>
<li><code>Semaphore</code>（信号量）：控制同时访问某个特定资源的线程数量或同时执行某个指定操作的数量。还可以用来实现某种资源池，或者对容器施加边界。二值信号量可以用作互斥体，具备不可重入的加锁语义。</li>
<li><code>Exchanger</code>（交换者）：用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。</li>
<li>Guava <code>RateLimiter</code>（限流器）：使用漏桶算法（利用一个缓存区，请求进入系统时，无论请求的速率如何都先保存在缓存区内，然后以固定的流速流出缓存区进行处理）或令牌桶算法（桶中存放的不再是请求，而是令牌，处理程序只有拿到令牌后才能对请求进行处理，无令牌时程序要么等待令牌，要么丢弃请求，为了限制流速，会在每个单位时间产生一定量的令牌放入桶中）对请求进行限流。</li>
</ul>
<h2 id="java中的线程池"><a href="#java中的线程池" class="headerlink" title="java中的线程池"></a>java中的线程池</h2><img src="/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/thread-pool-processing.png" class="">

<ol>
<li>如果当前运行的线程少于<code>corePoolSize</code>，则创建新线程来执行任务（<span class="label danger">注意：执行这一步骤需要获取全局锁</span>）。</li>
<li>如果运行的线程等于或多于<code>corePoolSize</code>，则将任务加入<code>BlockingQueue</code>。</li>
<li>如果无法将任务加入<code>BlockingQueue</code>（队列已满），则创建新的线程来处理任务（<span class="label danger">注意：执行这一步骤需要获取全局锁</span>）。</li>
<li>如果创建新线程将使当前运行的线程超出<code>maximumPoolSize</code>，任务将被拒绝，并调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li>
</ol>
<h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h3><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, // 核心线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize, // 最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime, // 线程数量超过核心线程时，多余的空闲线程的最大存活时间</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit, // 时间的单位</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue, // 阻塞队列，暂存被提交但尚未执行的任务</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory, // 创建工作线程的工厂</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123; <span class="comment">// 拒绝策略，任务太多来不及处理时如何拒绝</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BlockingQueue</code>（阻塞队列）：</p>
<ul>
<li><code>ArrayBlockingQueue</code>：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。</li>
<li><code>LinkedBlockingQueue</code>：一个基于链表结构的阻塞队列，此队列按FIFO（先进先出）排序元素，吞吐量通常要高于<code>ArrayBlockingQueue</code>。</li>
<li><code>SynchronousQueue</code>：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于<code>LinkedBlockingQueue</code>。<blockquote>
<p>仅当有足够多的消费者，并且总是有一个消费者准备好获取交付的工作时，才适合使用同步队列。</p>
</blockquote>
</li>
<li><code>PriorityBlockingQueue</code>：一个具有优先级的无限阻塞队列。<blockquote>
<p>当需要按照某种顺序而不是FIFO来处理元素时，非常适用。既可以使用元素的自然顺序来比较（它们实现了<code>Comparable</code>），也可以使用<code>Comparator</code>来比较。</p>
</blockquote>
</li>
</ul>
<p><code>RejectedExecutionHandler</code>（饱和策略）：</p>
<ul>
<li><code>AbortPolicy</code>：直接抛出异常。</li>
<li><code>CallerRunsPolicy</code>：只用调用者所在线程来运行任务。</li>
<li><code>DiscardOldestPolicy</code>：丢弃下一个将被执行的任务，然后尝试重新提交新的任务。<blockquote>
<span class="label warning">如果工作队列是一个优先队列，那么“抛弃最旧的”策略将导致抛弃优先级最高的任务，因此最好不要将“抛弃最旧的”饱和策略和优先级队列放在一起使用。</span></blockquote>
</li>
<li><code>DiscardPolicy</code>：不处理悄悄丢弃掉。</li>
</ul>
<h4 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h4><ul>
<li><code>execute()</code>：用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。</li>
<li><code>submit()</code>：用于提交需要返回值的任务。</li>
</ul>
<h4 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h4><ul>
<li><code>shutdown()</code>：只是将线程池的状态设置成<code>SHUTDOWN</code>状态，然后中断所有没有正在执行任务的线程。</li>
<li><code>shutdownNow()</code>：首先将线程池的状态设置成<code>STOP</code>，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。</li>
</ul>
<h3 id="合理配置线程池"><a href="#合理配置线程池" class="headerlink" title="合理配置线程池"></a>合理配置线程池</h3><p>线程数配置：</p>
<ul>
<li><p>按任务的性质拆分：<br><u>CPU密集型任务</u>应配置尽可能小的线程，如配置<code>Ncpu+1</code>个线程的线程池。由于<u>IO密集型任务</u>线程并不是一直在执行任务，则应配置尽可能多的线程，如<code>2*Ncpu</code>。<u>混合型的任务</u>，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过<code>Runtime.getRuntime().availableProcessors()</code>方法获得当前设备的CPU个数。</p>
</li>
<li><p>按任务优先级拆分：<br>优先级不同的任务可以使用优先级队列<code>PriorityBlockingQueue</code>来处理。它可以让优先级高的任务先执行。但需要注意如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。</p>
</li>
<li><p>按任务执行时间拆分：<br>执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。</p>
</li>
<li><p>按任务的依赖性拆分:<br>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，等待的时间越长，则CPU空闲时间就越长，那么线程数应该设置得越大，这样才能更好地利用CPU。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ncpu &#x3D; cpu的数量</span><br><span class="line">Ucpu &#x3D; 目标cpu的使用率，0 ≤ Ucpu ≤ 1</span><br><span class="line">W&#x2F;C &#x3D; 等待时间与计算时间的比率</span><br><span class="line">为保持处理器达到期望的使用率，最优的线程池大小等于：Nthreads &#x3D; Ncpu * Ucpu * (1 + W&#x2F;C)</span><br></pre></td></tr></table></figure>

<p>队列配置：</p>
<ul>
<li><span class="label primary">建议使用有界队列</span></li>
<li>吞吐量比较：<br><code>SynchronousQueue(Executors.newCachedThreadPool)</code>&gt;<code>LinkedBlockingQueue(Executors.newFixedThreadPool())</code>&gt;<code>ArrayBlockingQueue</code></li>
</ul>
<p>拒绝策略配置：</p>
<ul>
<li>也可以根据应用场景需要来实现<code>RejectedExecutionHandler</code>接口自定义策略。如记录日志或持久化存储不能处理的任务。</li>
</ul>
<p>空闲存活时间配置：</p>
<ul>
<li>任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。</li>
</ul>
<h3 id="监控线程池"><a href="#监控线程池" class="headerlink" title="监控线程池"></a>监控线程池</h3><p>通过线程池提供的参数进行监控，在监控线程池的时候可以使用以下属性：</p>
<ul>
<li><code>taskCount</code>：线程池需要执行的任务数量。</li>
<li><code>completedTaskCount</code>：线程池在运行过程中已完成的任务数量，小于或等于<code>taskCount</code>。</li>
<li><code>largestPoolSize</code>：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。</li>
<li><code>getPoolSize</code>：线程池的线程数量。</li>
<li><code>getActiveCount</code>：获取活动的线程数量。</li>
</ul>
<p>通过继承线程池来自定义线程池，重写线程池的<code>beforeExecute</code>、<code>afterExecute</code>和<code>terminated</code>方法，在任务执行前、执行后和线程池关闭前执行一些代码来进行监控。</p>
<h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><ul>
<li><code>FixedThreadPool</code>：容量为<code>Integer.MAX_VALUE</code>的<code>LinkedBlockingQueue</code>。由于使用无界队列，因此<code>maximumPoolSize</code>和<code>keepAliveTime</code>将是无效参数。运行中的FixedThreadPool（未执行方法<code>shutdown()</code>或<code>shutdownNow()</code>）也不会拒绝任务。这意味着如果主线程提交任务的速度高于池中线程处理任务的速度时，它会不断积压任务。<u>极端情况下，会因为积压过多的任务而耗尽内存资源。</u><blockquote>
<p>适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，它适用于负载比较重的服务器。</p>
</blockquote>
</li>
<li><code>SingleThreadExecutor</code>：<code>corePoolSize</code>和<code>maximumPoolSize</code>被设置为<code>1</code>，容量为<code>Integer.MAX_VALUE</code>的<code>LinkedBlockingQueue</code>。使用无界队列带来的影响与上述相同。<blockquote>
<p>适用于需要保证顺序地执行各个任务；并且在任意时间点，不会有多个线程是活动的应用场景。</p>
</blockquote>
</li>
<li><code>CachedThreadPool</code>：核心线程数为<code>0</code>,最大线程数为<code>Integer.MAX_VALUE</code>，<code>keepAliveTime</code>设置为<code>60L</code>，没有容量的<code>SynchronousQueue</code>，是大小无界的线程池，这意味着如果主线程提交任务的速度高于池中线程处理任务的速度时，它会不断创建新线程。<u>极端情况下，会因为创建过多线程而耗尽CPU和内存资源。</u><blockquote>
<p>适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器。</p>
</blockquote>
</li>
<li><code>ScheduledThreadPoolExecutor</code>：<code>DelayedQueue</code>无界队列，其内保存的<code>ScheduledFutureTask</code>任务会先按照任务的执行时间升序排列，其次按照任务提交的序列号升序排列。<blockquote>
<p>适用于需要多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程的数量的应用场景。</p>
</blockquote>
</li>
<li><code>SingleThreadScheduledExecutor</code>：只有一个核心线程的<code>ScheduledThreadPoolExecutor</code>。<blockquote>
<p>适用于需要单个后台线程执行周期任务，同时需要保证顺序地执行各个任务的应用场景。</p>
</blockquote>
</li>
</ul>
<hr>
<ul>
<li><em>《Java并发编程的艺术》</em></li>
<li><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization" target="_blank" rel="noopener">Synchronization</a></li>
<li><a href="https://blog.dreamtobe.cn/2015/11/13/java_synchronized/" target="_blank" rel="noopener">Java Synchronised机制</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrency</tag>
      </tags>
  </entry>
</search>
