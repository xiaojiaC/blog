---
title: java垃圾回收器
categories:
  - [JAVA, 读书笔记]
tags:
  - java
  - gc
date: 2020-07-22 17:35:09
---

## [CMS](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html)收集器的工作过程

1. {% label danger@初始标记 %}：仅仅只是标记一下GC Roots能直接关联到的对象，需要暂停应用程序线程，该阶段完成后，应用程序线程再次启动。
2. 并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。
3. 并发预清理：改变当运行第二阶段时，由应用程序线程运行引用关系改变导致没有标记到的存活对象，以更新第二阶段的结果。
<!-- more -->
4. {% label danger@重新标记 %}：由于第三阶段是并发的，对象引用可能会发生进一步改变。因此，应用程序线程会再一次被暂停以更新这些变化，并且在进行实际的清理之前确保一个正确的对象引用视图。这一阶段十分重要，因为必须避免收集到仍被引用的对象。
5. 并发清理：清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。
6. 并发重置：收集器做一些收尾的工作，以便下一次GC周期能有一个干净的状态。

## [G1](https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html)收集器的工作过程

> young gc(并行独占，Eden区用尽时触发) -> young gc + concurrent mark(并发，堆内存占用率达到阈值时触发) -> mixed gc(并行，标记完成时触发) -> [full gc(独占，晋升失败/回收前堆区耗尽时触发)]

### {% label danger@年轻代GC %}的工作过程：

1. 根扫描：扫描根引用和记忆集记录的外部引用（老年代到新生代的对象引用）；
2. 更新记忆集：排空**赃卡队列**（Dirty Card Queue），更新**记忆集**（Remember Set），该阶段完成后可以准确反映老年代到新生代的对象引用；
3. 处理记忆集：扫描并标记被老年代对象指向的Eden/Survivor中的对象；
4. 复制对象：遍历对象树，复制扫描出的存活对象到Survivor/Old区；
5. 处理引用队列：软引用，弱引用，虚引用，Final引用。

### 并发标记的工作过程：

1. {% label danger@初始标记 %}（Initial Marking）：标记GC Roots能直接关联到的对象，并且修改**TAMS**指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行新生代GC时同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。
2. 根区域扫描（Root Region Scanning）：扫描并标记Survivor区直接可达的老年代区域对象；这一过程必须在下一次新生代GC之前完成；
3. 并发标记（Concurrent Marking）：对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行，可以被一次新生代GC打断。当对象图扫描完成以后，还要重新处理**SATB**记录下的在并发时有引用变动的对象。
4. {% label danger@重新标记 %}（Remark）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。
5. {% label danger@独占清理 %}（Cleanup）：计算各个Region存活对象和GC回收价值比例，并进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成**回收集**（Collection Set）。
6. {% label danger@复制 %}（Copying）：把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。该阶段可能会发生在新生代Regions记录为`[GC pause (young)]`，也可能会同时发生在新生代和老年代Regions记录为`[GC Pause (mixed)]`。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。


## [Shenandoah](https://wiki.openjdk.java.net/display/shenandoah/Main)收集器的工作过程

1. {% label danger@初始标记 %}（Initial Marking）：与G1一样，首先标记与GC Roots直接关联的对象，这个阶段仍是“Stop The World”的，但停顿时间与堆大小无关，只与GC Roots的数量相关。
2. 并发标记（Concurrent Marking）：与G1一样，遍历对象图，标记出全部可达的对象，这个阶段是与用户线程一起并发的，时间长短取决于堆中存活对象的数量以及对象图的结构复杂程度。
3. {% label danger@最终标记 %}（Final Marking）：与G1一样，处理剩余的SATB扫描，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组回收集（Collection Set）。最终标记阶段也会有一小段短暂的停顿。
4. 并发清理（Concurrent Cleanup）：这个阶段用于清理那些整个区域内连一个存活对象都没有找到的Region（这类Region被称为Immediate Garbage Region）。
5. 并发回收（Concurrent Evacuation）：并发回收阶段是Shenandoah与之前HotSpot中其他收集器的核心差异。在这个阶段，Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region之中。复制对象这件事情如果将用户线程冻结起来再做那是相当简单的，但如果两者必须要同时并发进行的话，就变得复杂起来了。其困难点是在移动对象的同时，用户线程仍然可能不停对被移动的对象进行读写访问，移动对象是一次性的行为，但移动之后整个内存中所有指向该对象的引用都还是旧对象的地址，这是很难一瞬间全部改变过来的。对于并发回收阶段遇到的这些困难，Shenandoah将会通过**读屏障**和被称为“Brooks Pointers”的**转发指针**来解决。并发回收阶段运行的时间长短取决于为该周期选择的回收集的大小。
6. {% label danger@初始引用更新 %}（Initial Update Reference）：并发回收阶段复制对象结束后，还需要把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新。引用更新的初始化阶段实际上并未做什么具体的处理，设立这个阶段只是为了建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务而已。初始引用更新时间很短，会产生一个非常短暂的停顿。
7. 并发引用更新（Concurrent Update Reference）：真正开始进行引用更新操作，这个阶段是与用户线程一起并发的，时间长短取决于内存中涉及的引用数量的多少。并发引用更新与并发标记不同，它不再需要沿着对象图来搜索，只需要按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值即可。
8. {% label danger@最终引用更新 %}（Final Update Reference）：解决了堆中的引用更新后，还要修正存在于GCRoots中的引用。这个阶段是Shenandoah的最后一次停顿，停顿时间只与GC Roots的数量相关。
9. 并发清理（Concurrent Cleanup）：经过并发回收和引用更新之后，整个回收集中所有的Region已再无存活对象，这些Region都变成Immediate Garbage Regions了，最后再调用一次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用。

## [ZGC](https://wiki.openjdk.java.net/display/zgc)收集器的工作过程

1. 并发标记（Concurrent Mark）：与G1、Shenandoah一样，并发标记是遍历对象图做可达性分析的阶段，前后也要经过类似于G1、Shenandoah的初始标记、最终标记的短暂停顿，而且这些停顿阶段所做的事情在目标上也是相类似的。与G1、Shenandoah不同的是，ZGC的标记是在指针上而不是在对象上进行的，标记阶段会更新染色指针中的`Marked 0`、`Marked 1`标志位。
2. 并发预备重分配（Concurrent Prepare for Relocate）：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成**重分配集**（Relocation Set）。重分配集与G1收集器的回收集（Collection Set）还是有区别的，ZGC划分Region的目的并非为了像G1那样做收益优先的增量回收。相反，ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本。因此，ZGC的重分配集只是决定了里面的存活对象会被重新复制到其他的Region中，里面的Region会被释放，而并不能说回收行为就只是针对这个集合里面的Region进行，因为标记过程是针对全堆的。此外，在JDK 12的ZGC中开始支持的类卸载以及弱引用的处理，也是在这个阶段中完成的。
3. 并发重分配（Concurrent Relocate）：重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个**转发表**（Forward Table），记录从旧对象到新对象的转向关系。得益于**染色指针**的支持，ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（Self-Healing）能力。这样做的好处是只有第一次访问旧对象会陷入转发，也就是只慢一次，对比Shenandoah的Brooks转发指针，那是每次对象访问都必须付出的固定开销，简单地说就是每次都慢，因此ZGC对用户程序的运行时负载要比Shenandoah来得更低一些。还有另外一个直接的好处是由于染色指针的存在，一旦重分配集中某个Region的存活对象都复制完毕后，这个Region就可以立即释放用于新对象的分配（但是转发表还得留着不能释放掉），哪怕堆中还有很多指向这个对象的未更新指针也没有关系，这些旧指针一旦被使用，它们都是可以自愈的。
4. 并发重映射（Concurrent Remap）：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，这一点从目标角度看是与Shenandoah并发引用更新阶段一样的，但是ZGC的并发重映射并不是一个必须要“迫切”去完成的任务，因为前面说过，即使是旧引用，它也是可以自愈的，最多只是第一次使用时多一次转发和修正操作。重映射清理这些旧引用的主要目的是为了不变慢（还有清理结束后可以释放转发表这样的附带收益），所以说这并不是很“迫切”。因此，ZGC很巧妙地把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图[插图]的开销。一旦所有指针都被修正之后，原来记录新旧对象关系的转发表就可以释放掉了。

----
* *《深入理解Java虚拟机》*