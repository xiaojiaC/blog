---
title: java并发编程实战
date: 2020-03-22 20:47:30
categories:
- [JAVA, 读书笔记]
tags:
- java
- concurrency
---

## 线程安全性

要编写线程安全的代码，核心在于{% label primary@要对状态访问操作进行管理 %}，特别是对**共享的**和**可变的**状态的访问。

当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。

如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：
- {% label info@不在线程之间共享该状态变量。 %}
- {% label info@将状态变量修改为不可变的变量。 %}
- {% label info@在访问状态变量时使用同步。 %}

<!-- more -->

在编写并发程序时，一种正确的编程方法就是：{% label success@首先使代码正确运行，然后再提高代码的速度。 %}即便如此，最好也只是当性能测试结果和应用需求告诉你必须提高性能，以及测量结果表明这种优化在实际环境中确实能带来性能提升时，才进行优化。

### 线程安全性

在线程安全性的定义中，最核心的概念是{% label primary@正确性 %}（某个类的行为与其规范完全一致）。

> 当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。

### 原子性

竞态条件：
- {% label info@先检查后执行 %} eg: 单例延迟初始化
- {% label info@读取-修改-写入 %} eg: i++

原子操作：对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。

当在无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的。在实际情况中，应尽可能地使用现有的线程安全对象（eg: `AtomicLong`）来管理类的状态。

### 加锁机制

当在不变性条件涉及多个变量时，各个变量之间并不是彼此独立的，而是某个变量的值会对其他变量的值产生约束。因此，当更新某一个变量时，需要在同一个原子操作中对其他变量同时进行更新。

{% label danger@要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。 %}

### 用锁来保护状态

{% label warning@如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步。而且，当使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同一个锁。%}

每个共享的和可变的变量都应该只由一个锁类保护，从而使维护人员知道是哪一个锁。

{% label danger@每个包含多个变量的不变性条件，其中涉及的所有变量都需要同一个锁来保护。 %}

### 活跃性与性能

{% label warning@通常，在简单性与性能之间存在着相互制约因素。当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性（这可能会破坏安全性）。 %}

当使用锁时，你应该清楚代码块中实现的功能，以及在执行该代码块时是否需要很长的时间，无论是执行计算密集的操作，还是执行某个可能阻塞的操作，如果锁持有的时间过长，那么都会带来活跃性或性能问题。

{% label danger@当执行时间较长的计算或可能无法快速完成的操作(eg: I/O)时，一定不要持有锁。 %}





----
* *《Java并发编程实战》*