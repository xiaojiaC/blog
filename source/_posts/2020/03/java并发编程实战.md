---
title: java并发编程实战
date: 2020-03-22 20:47:30
categories:
- [JAVA, 读书笔记]
tags:
- java
- concurrency
---

## 线程安全性

要编写线程安全的代码，核心在于{% label primary@要对状态访问操作进行管理 %}，特别是对**共享的**和**可变的**状态的访问。

当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。

如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：
- 不在线程之间共享该状态变量。
- 将状态变量修改为不可变的变量。
- 在访问状态变量时使用同步。

<!-- more -->

在编写并发程序时，一种正确的编程方法就是：{% label success@首先使代码正确运行，然后再提高代码的速度。 %}即便如此，最好也只是当性能测试结果和应用需求告诉你必须提高性能，以及测量结果表明这种优化在实际环境中确实能带来性能提升时，才进行优化。

### 线程安全性

在线程安全性的定义中，最核心的概念是{% label primary@正确性 %}（某个类的行为与其规范完全一致）。

> 当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。

### 原子性

竞态条件：
- {% label info@先检查后执行 %} eg: 单例延迟初始化
- {% label info@读取-修改-写入 %} eg: i++

原子操作：对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。

当在无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的。在实际情况中，应尽可能地使用现有的线程安全对象（eg: `AtomicLong`）来管理类的状态。

### 加锁机制

当在不变性条件涉及多个变量时，各个变量之间并不是彼此独立的，而是某个变量的值会对其他变量的值产生约束。因此，当更新某一个变量时，需要在同一个原子操作中对其他变量同时进行更新。

{% label danger@要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。 %}

### 用锁来保护状态

{% label warning@如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步。而且，当使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同一个锁。%}

每个共享的和可变的变量都应该只由一个锁类保护，从而使维护人员知道是哪一个锁。

{% label danger@每个包含多个变量的不变性条件，其中涉及的所有变量都需要同一个锁来保护。 %}

### 活跃性与性能

{% label warning@通常，在简单性与性能之间存在着相互制约因素。当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性（这可能会破坏安全性）。 %}

当使用锁时，你应该清楚代码块中实现的功能，以及在执行该代码块时是否需要很长的时间，无论是执行计算密集的操作，还是执行某个可能阻塞的操作，如果锁持有的时间过长，那么都会带来活跃性或性能问题。

{% label danger@当执行时间较长的计算或可能无法快速完成的操作(eg: I/O)时，一定不要持有锁。 %}

## 对象的共享
### 可见性

在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，想要对内存操作的执行顺序进行判断，几乎无法得出正确的结论。有一种简单的方法能避免这些复杂的问题：{% label success@只要有数据在多个线程间共享，就使用正确的同步。%}

当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证称为最低安全性。它适用于绝大多数变量，但是存在一个例外：{% label primary@非volatile类型的64位数值变量。%}

JMM要求变量的读取和写入操作都必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读或写操作分解为两个32位的操作。因此在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非用volatile来声明它们，或用锁保护起来。

加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。

{% label danger@加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。 %}

什么时候使用volatile变量？仅当同时满足以下**所有**条件时。
-  对变量的写入操作不依赖变量的当前值，或者能确保只有单个线程更新变量的值。
-  该变量不会与其他变量一起纳入不变性条件中。
-  在访问变量时不需要加锁。

### 发布与逸出

发布：使对象能够在当前作用域之外的代码中使用。

发布的方式：
-  将对象引用保存到一个公有的静态变量。
-  发布对象时间接地发布了其他对象（eg:非私有域中引用的所有对象）。
-  发布一个内部类实例。

逸出：某个不应该发布的对象被发布。当某个对象逸出时，你必须假设某个类或线程可能会误用该对象，误用该引用的风险始终存在。

逸出的例子：
-  构造函数中发布内部类实例，导致`this`引用逸出。
-  构造函数中创建线程后使用`start()`启动，导致`this`引用逸出。

{% label danger@不要在构造过程中使this引用逸出。%}

### 线程封闭

当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步，这种技术被称为线程封闭。

-  Ad-hoc线程封闭：维护封闭性的职责完全由程序实现来承担。
> {% label warning@在volatile变量上存在一种特殊的线程封闭。只要你能确保只有单个线程对共享的volatile变量执行写入操作，那么就可以安全地在这些共享的volatile变量上执行“读取-修改-写入”的操作。%}
-  栈封闭
-  `ThreadLocal`

### 不变性

不可变的对象一定是线程安全的。

不可变性并不等于将对象中所有的域都声明为final类型，即使对象中所有的域都是final类型的，这个对象也仍然是可变的，因为final类型的域中可以保存对可变对象的引用。

当满足以下所有条件时，对象才是不可变的：
- 对象创建以后其状态就不能修改。
- 对象的所有域都是final类型。
- 对象是正确创建的（在对象的创建期间，this引用没有逸出）。

{% label success@除非需要更高的可见性，否则应将所有的域都声明为私有域。除非需要某个域是可变的，否则应将其声明为final域。%}

### 安全发布

安全发布：要安全发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象，可以通过以下方式安全发布：
-  在静态初始化函数中初始化一个对象引用。
-  将对象的引用保存到volatile类型的域或`AtomicReferance`对象中。
-  将对象的引用保存到某个正确构造对象的final类型域中。
-  将对象的引用保存到一个由锁保护的域中。

在没有额外同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。

对象的发布取决于它的可变性：
-  不可变对象可以通过任意机制来发布。
-  事实不可变对象必须通过安全方式来发布。
-  可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。

{% label warning@如果final类型的域指向的是可变对象，那么在访问这些域所指向的对象的状态时仍然需要同步。%}

### 小结

并发程序中使用和共享对象时，有以下一些实用的策略，包括：
- **线程封闭**。线程封闭的对象只能有一个线程持有，对象被封闭在该线程中，并且只能由这个线程修改。
- **只读共享**。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。
- **线程安全共享**。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来访问而不需要进一步的同步。
- **保护对象**。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。

## 对象的组合
### 设计线程安全类

在设计线程安全类的过程中，需要包含以下三个基本要素：
1. 找出构成对象状态的所有变量。
2. 找出约束变量的不变性条件。
3. 建立对象状态的并发访问管理策略。

同步策略定义了如何在不违背对象不变条件或后验条件的情况下对其状态的访问操作进行协同。同步策略规定了如何将不可变性，线程封闭与加锁机制等结合起来以维护线程的安全性，并且还规定了哪些变量由哪些锁来保护。要确保开发人员可以对这个类进行分析与维护，就必须将同步策略写为正式文档。

{% label warning@如果在一个不变性条件中包含多个变量，那么在执行任何访问相关变量的操作时，都必须持有保护这些变量的锁。%}

类的不变性条件与后验条件约束了在对象上有哪些状态和状态转换是有效的。在某些对象的方法中还包含一些基于状态的先验条件（例如：不能从空队列移除一个元素）。如果某个操作中包含有基于状态的先验条件，那么这个操作就称为依赖状态的操作。

### 实例封闭

封装可简化线程安全类的实现过程。通过将封闭机制与合适的加锁策略结合起来，可以确保以线程安全的方式来使用非线程安全的对象。

将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。

{% label success@优先使用私有的锁对象而不是对象的内置锁（或任何其他可通过公有方式访问的锁）。%}

### 线程安全性委托

线程安全性委托：
- 单个状态变量：可以将线程的安全性委托给单个线程安全的状态变量。
- 独立的多个状态变量：可以将线程的安全性委托给多个线程安全的状态变量，只要这些变量是彼此独立的，即组合而成的类并不会在其包含的多个状态变量上增加任何不变性条件。
- 有不变性条件的多个状态变量：{% label warning@某个类含有复合操作，那么仅靠委托并不足以实现线程安全性。这个类必须提供自己的加锁机制以保证这些复合操作都是原子操作，除非整个复合操作都可以委托给状态变量。%}

如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全地发布这个变量。

### 在现有的线程安全类中添加功能

在现有的线程安全类中添加功能有以下几种方式：
- 修改原始的类：通常无法做到。
- ~~扩展这个类~~：比较脆弱，底层类改变同步策略选择不同的锁来保护它的状态变量时，子类会被破坏。
- ~~将扩展代码放入一个辅助类~~：更加脆弱，必须谨慎确保和线程安全类使用同一个锁，客户端加锁还会破坏同步策略的封装性。
- 使用组合构建自己的锁

### 将同步策略文档化

在文档中说明客户代码需要了解的线程安全性保证，以及代码维护人员需要了解的同步策略。

## 基础构建模块
### 同步容器类

同步容器类都是线程安全的，但在某些情况下可能需要额外的客户端加锁来保护复合操作。

同步容器类通过其**自身的锁**来保护它的每个方法。

虽然加锁可以防止迭代器抛出`ConcurrentModificationException`，但你必须记住在所有对共享容器进行迭代的地方都需要加锁。尤其要小心隐式迭代器的场景（容器的`toString`方法，以及`hasCode`和`equals`方法会间接地执行迭代器）。

{% label success@正如封装对象的状态有助于维持不变性条件一样，封装对象的同步机制同样有助于确保实施同步策略。%}

### 并发容器

通过并发容器来代替同步容器，可以极大地提高伸缩性并降低风险。

`ConcurrentHashMap`：只有当应用程序需要加锁Map以进行独占访问时，才应该放弃使用`ConcurrentHashMap`。
`CopyOnWriteArrayList`：仅当迭代操作远远多于修改操作时，才应该使用“写时复制”容器。
`ArrayBlockingQueue`：在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于`LinkedBlockingQueue`。
`LinkedBlockingQueue`：对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。
`SynchronousQueue`：仅当有足够多的的消费者，并且总是有一个消费者准备好获取交付的工作时，才适合用同步队列。
`LinkedBlockingDeque`：双端队列，适用于工作密取。

{% label success@在设计初期就使用阻塞队列建立对资源的管理 %}（提早做这件事会比以后再修复容易的多）。

在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具：它们能抑制防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮。

### 阻塞和可中断的方法

当一个方法能够抛出`InterruptedException`时，是在告诉你这个方法是一个可阻塞方法，进一步看，如果它被中断，将可以提前结束阻塞状态。
当你在代码中调用了一个会抛出`InterruptedException`的方法时，你自己的方法就成为了一个阻塞方法，要为响应中断做好准备。在类库代码中，有两种基本选择：
- **传递`InterruptedException`**：1. 不捕获继续抛出。2. 先捕获，然后对其中特定活动进行简洁清理后，再抛出。
- **恢复中断**：有时候不能抛出`InterruptedException`，比如当你的代码是`Runnable`的一部分时。在这种情况下，你必须捕获`InterruptedException`，并且在当前线程中调用`interrupt`从中断中恢复，这样调用栈中更高层的代码才可以发现中断已经发生。

{% label warning@你不应该捕获InterruptedException，但不做任何响应。只有一种情况允许掩盖中断：你扩展了Thread，并因此控制了所有处于调用栈上层的代码。%}

### 同步工具

闭锁(`CountDownLatch`/`FutureTask`)：可以用来确保特定活动直到其他的活动完成后才发生。

- 确保一个计算不会执行，直到它需要的资源被初始化。
- 确保一个服务不会开始，直到它依赖的其他服务都已经开始。
- 等待，直到活动的所有部分都为继续处理做好充分准备，比如：多玩家游戏中的所有玩家是否都准备就绪。

信号量(`Semaphore`)：控制同时访问某个特定资源的线程数量或同时执行某个指定操作的数量。还可以用来实现某种资源池，或者对容器施加边界。

屏障(`CyclicBarrier`)：与闭锁类似，都能阻塞一组线程，直到某些事件发生。它们的不同之处在于：所有线程必须同时到达同步点，才能够继续处理。{% label primary@闭锁等待的是事件，屏障等待的是其他线程。%}

交换机(`Exchanger`)：用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。

### 小结

- 可变状态是至关重要的。
> 所有并发问题都可以归结为如何协调对并发状态的访问。可变状态越少就越容易确保线程安全性。
- 尽量将域声明为final类型，除非需要它们是可变的。
- 不可变对象一定是线程安全的。
> 不可变对象能极大地降低并发编程的复杂性。它们更为简单而且安全，可以任意共享而无需使用加锁或保护性复制等机制。
- 封装有助于管理复杂性。
> 在编写线程安全的程序时，虽然可以将所有数据都保存在全局变量中，但为什么要这样做？将数据封装在对象中，更易于维持不变性条件：将同步机制封装在对象中，更易于遵循同步策略。
- 用锁来保护每个可变变量。
- 当保护同一个不变性条件中的所有变量时，要使用同一个锁。
- 在执行复合操作时，要持有锁。
- 如果从多个线程中访问同一个可变变量时没有同步机制，那么程序会出现问题。
- 不要故作聪明地推断出不需要使用同步。
- 在设计过程中考虑线程安全，或者在文档中明确地指出它不是线程安全的。
- 将同步策略文档化。

----
* *《Java并发编程实战》*