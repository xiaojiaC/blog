---
title: java并发编程实战
date: 2020-03-22 20:47:30
categories:
- [JAVA, 读书笔记]
tags:
- java
- concurrency
---

## 线程安全性

要编写线程安全的代码，核心在于{% label primary@要对状态访问操作进行管理 %}，特别是对**共享的**和**可变的**状态的访问。

当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。

如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：
- 不在线程之间共享该状态变量。
- 将状态变量修改为不可变的变量。
- 在访问状态变量时使用同步。

<!-- more -->

在编写并发程序时，一种正确的编程方法就是：{% label success@首先使代码正确运行，然后再提高代码的速度。 %}即便如此，最好也只是当性能测试结果和应用需求告诉你必须提高性能，以及测量结果表明这种优化在实际环境中确实能带来性能提升时，才进行优化。

### 线程安全性

在线程安全性的定义中，最核心的概念是{% label primary@正确性 %}（某个类的行为与其规范完全一致）。

> 当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。

### 原子性

竞态条件：
- {% label info@先检查后执行 %} eg: 单例延迟初始化
- {% label info@读取-修改-写入 %} eg: i++

原子操作：对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。

当在无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的。在实际情况中，应尽可能地使用现有的线程安全对象（eg: `AtomicLong`）来管理类的状态。

### 加锁机制

当在不变性条件涉及多个变量时，各个变量之间并不是彼此独立的，而是某个变量的值会对其他变量的值产生约束。因此，当更新某一个变量时，需要在同一个原子操作中对其他变量同时进行更新。

{% label danger@要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。 %}

### 用锁来保护状态

{% label warning@如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步。而且，当使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同一个锁。%}

每个共享的和可变的变量都应该只由一个锁类保护，从而使维护人员知道是哪一个锁。

{% label danger@每个包含多个变量的不变性条件，其中涉及的所有变量都需要同一个锁来保护。 %}

### 活跃性与性能

{% label warning@通常，在简单性与性能之间存在着相互制约因素。当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性（这可能会破坏安全性）。 %}

当使用锁时，你应该清楚代码块中实现的功能，以及在执行该代码块时是否需要很长的时间，无论是执行计算密集的操作，还是执行某个可能阻塞的操作，如果锁持有的时间过长，那么都会带来活跃性或性能问题。

{% label danger@当执行时间较长的计算或可能无法快速完成的操作(eg: I/O)时，一定不要持有锁。 %}

## 对象的共享
### 可见性

在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，想要对内存操作的执行顺序进行判断，几乎无法得出正确的结论。有一种简单的方法能避免这些复杂的问题：{% label success@只要有数据在多个线程间共享，就使用正确的同步。%}

当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证称为最低安全性。它适用于绝大多数变量，但是存在一个例外：{% label primary@非volatile类型的64位数值变量。%}

JMM要求变量的读取和写入操作都必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读或写操作分解为两个32位的操作。因此在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非用volatile来声明它们，或用锁保护起来。

加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。

{% label danger@加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。 %}

什么时候使用volatile变量？仅当同时满足以下**所有**条件时。
-  对变量的写入操作不依赖变量的当前值，或者能确保只有单个线程更新变量的值。
-  该变量不会与其他变量一起纳入不变性条件中。
-  在访问变量时不需要加锁。

### 发布与逸出

发布：使对象能够在当前作用域之外的代码中使用。

发布的方式：
-  将对象引用保存到一个公有的静态变量。
-  发布对象时间接地发布了其他对象（eg:非私有域中引用的所有对象）。
-  发布一个内部类实例。

逸出：某个不应该发布的对象被发布。当某个对象逸出时，你必须假设某个类或线程可能会误用该对象，误用该引用的风险始终存在。

逸出的例子：
-  构造函数中发布内部类实例，导致`this`引用逸出。
-  构造函数中创建线程后使用`start()`启动，导致`this`引用逸出。

{% label danger@不要在构造过程中使this引用逸出。%}

### 线程封闭

当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步，这种技术被称为线程封闭。

-  Ad-hoc线程封闭：维护封闭性的职责完全由程序实现来承担。
> {% label warning@在volatile变量上存在一种特殊的线程封闭。只要你能确保只有单个线程对共享的volatile变量执行写入操作，那么就可以安全地在这些共享的volatile变量上执行“读取-修改-写入”的操作。%}
-  栈封闭
-  `ThreadLocal`

### 不变性

不可变的对象一定是线程安全的。

不可变性并不等于将对象中所有的域都声明为final类型，即使对象中所有的域都是final类型的，这个对象也仍然是可变的，因为final类型的域中可以保存对可变对象的引用。

当满足以下所有条件时，对象才是不可变的：
- 对象创建以后其状态就不能修改。
- 对象的所有域都是final类型。
- 对象是正确创建的（在对象的创建期间，this引用没有逸出）。

{% label success@除非需要更高的可见性，否则应将所有的域都声明为私有域。除非需要某个域是可变的，否则应将其声明为final域。%}

### 安全发布

安全发布：要安全发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象，可以通过以下方式安全发布：
-  在静态初始化函数中初始化一个对象引用。
-  将对象的引用保存到volatile类型的域或`AtomicReferance`对象中。
-  将对象的引用保存到某个正确构造对象的final类型域中。
-  将对象的引用保存到一个由锁保护的域中。

在没有额外同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。

对象的发布取决于它的可变性：
-  不可变对象可以通过任意机制来发布。
-  事实不可变对象必须通过安全方式来发布。
-  可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。

{% label warning@如果final类型的域指向的是可变对象，那么在访问这些域所指向的对象的状态时仍然需要同步。%}

### 小结

并发程序中使用和共享对象时，有以下一些实用的策略，包括：
- **线程封闭**。线程封闭的对象只能有一个线程持有，对象被封闭在该线程中，并且只能由这个线程修改。
- **只读共享**。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。
- **线程安全共享**。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来访问而不需要进一步的同步。
- **保护对象**。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。

## 对象的组合
### 设计线程安全类

在设计线程安全类的过程中，需要包含以下三个基本要素：
1. 找出构成对象状态的所有变量。
2. 找出约束变量的不变性条件。
3. 建立对象状态的并发访问管理策略。

同步策略定义了如何在不违背对象不变条件或后验条件的情况下对其状态的访问操作进行协同。同步策略规定了如何将不可变性，线程封闭与加锁机制等结合起来以维护线程的安全性，并且还规定了哪些变量由哪些锁来保护。要确保开发人员可以对这个类进行分析与维护，就必须将同步策略写为正式文档。

{% label warning@如果在一个不变性条件中包含多个变量，那么在执行任何访问相关变量的操作时，都必须持有保护这些变量的锁。%}

类的不变性条件与后验条件约束了在对象上有哪些状态和状态转换是有效的。在某些对象的方法中还包含一些基于状态的先验条件（例如：不能从空队列移除一个元素）。如果某个操作中包含有基于状态的先验条件，那么这个操作就称为依赖状态的操作。

### 实例封闭

封装可简化线程安全类的实现过程。通过将封闭机制与合适的加锁策略结合起来，可以确保以线程安全的方式来使用非线程安全的对象。

将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。

{% label success@优先使用私有的锁对象而不是对象的内置锁（或任何其他可通过公有方式访问的锁）。%}

### 线程安全性委托

线程安全性委托：
- 单个状态变量：可以将线程的安全性委托给单个线程安全的状态变量。
- 独立的多个状态变量：可以将线程的安全性委托给多个线程安全的状态变量，只要这些变量是彼此独立的，即组合而成的类并不会在其包含的多个状态变量上增加任何不变性条件。
- 有不变性条件的多个状态变量：{% label warning@某个类含有复合操作，那么仅靠委托并不足以实现线程安全性。这个类必须提供自己的加锁机制以保证这些复合操作都是原子操作，除非整个复合操作都可以委托给状态变量。%}

如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全地发布这个变量。

### 在现有的线程安全类中添加功能

在现有的线程安全类中添加功能有以下几种方式：
- 修改原始的类：通常无法做到。
- ~~扩展这个类~~：比较脆弱，底层类改变同步策略选择不同的锁来保护它的状态变量时，子类会被破坏。
- ~~将扩展代码放入一个辅助类~~：更加脆弱，必须谨慎确保和线程安全类使用同一个锁，客户端加锁还会破坏同步策略的封装性。
- 使用组合构建自己的锁

### 将同步策略文档化

在文档中说明客户代码需要了解的线程安全性保证，以及代码维护人员需要了解的同步策略。

## 基础构建模块
### 同步容器类

同步容器类都是线程安全的，但在某些情况下可能需要额外的客户端加锁来保护复合操作。

同步容器类通过其**自身的锁**来保护它的每个方法。

虽然加锁可以防止迭代器抛出`ConcurrentModificationException`，但你必须记住在所有对共享容器进行迭代的地方都需要加锁。尤其要小心隐式迭代器的场景（容器的`toString`方法，以及`hasCode`和`equals`方法会间接地执行迭代器）。

{% label success@正如封装对象的状态有助于维持不变性条件一样，封装对象的同步机制同样有助于确保实施同步策略。%}

### 并发容器

通过并发容器来代替同步容器，可以极大地提高伸缩性并降低风险。

`ConcurrentHashMap`：只有当应用程序需要加锁Map以进行独占访问时，才应该放弃使用`ConcurrentHashMap`。
`CopyOnWriteArrayList`：仅当迭代操作远远多于修改操作时，才应该使用“写时复制”容器。
`ArrayBlockingQueue`：在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于`LinkedBlockingQueue`。
`LinkedBlockingQueue`：对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。
`SynchronousQueue`：仅当有足够多的的消费者，并且总是有一个消费者准备好获取交付的工作时，才适合用同步队列。
`LinkedBlockingDeque`：双端队列，适用于工作密取。

{% label success@在设计初期就使用阻塞队列建立对资源的管理 %}（提早做这件事会比以后再修复容易的多）。

在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具：它们能抑制防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮。

### 阻塞和可中断的方法

当一个方法能够抛出`InterruptedException`时，是在告诉你这个方法是一个可阻塞方法，进一步看，如果它被中断，将可以提前结束阻塞状态。
当你在代码中调用了一个会抛出`InterruptedException`的方法时，你自己的方法就成为了一个阻塞方法，要为响应中断做好准备。在类库代码中，有两种基本选择：
- **传递`InterruptedException`**：1. 不捕获继续抛出。2. 先捕获，然后对其中特定活动进行简洁清理后，再抛出。
- **恢复中断**：有时候不能抛出`InterruptedException`，比如当你的代码是`Runnable`的一部分时。在这种情况下，你必须捕获`InterruptedException`，并且在当前线程中调用`interrupt`从中断中恢复，这样调用栈中更高层的代码才可以发现中断已经发生。

{% label warning@你不应该捕获InterruptedException，但不做任何响应。只有一种情况允许掩盖中断：你扩展了Thread，并因此控制了所有处于调用栈上层的代码。%}

### 同步工具

闭锁(`CountDownLatch`/`FutureTask`)：可以用来确保特定活动直到其他的活动完成后才发生。

- 确保一个计算不会执行，直到它需要的资源被初始化。
- 确保一个服务不会开始，直到它依赖的其他服务都已经开始。
- 等待，直到活动的所有部分都为继续处理做好充分准备，比如：多玩家游戏中的所有玩家是否都准备就绪。

信号量(`Semaphore`)：控制同时访问某个特定资源的线程数量或同时执行某个指定操作的数量。还可以用来实现某种资源池，或者对容器施加边界。

屏障(`CyclicBarrier`)：与闭锁类似，都能阻塞一组线程，直到某些事件发生。它们的不同之处在于：所有线程必须同时到达同步点，才能够继续处理。{% label primary@闭锁等待的是事件，屏障等待的是其他线程。%}

交换机(`Exchanger`)：用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。

### 小结

- 可变状态是至关重要的。
> 所有并发问题都可以归结为如何协调对并发状态的访问。可变状态越少就越容易确保线程安全性。
- 尽量将域声明为final类型，除非需要它们是可变的。
- 不可变对象一定是线程安全的。
> 不可变对象能极大地降低并发编程的复杂性。它们更为简单而且安全，可以任意共享而无需使用加锁或保护性复制等机制。
- 封装有助于管理复杂性。
> 在编写线程安全的程序时，虽然可以将所有数据都保存在全局变量中，但为什么要这样做？将数据封装在对象中，更易于维持不变性条件：将同步机制封装在对象中，更易于遵循同步策略。
- 用锁来保护每个可变变量。
- 当保护同一个不变性条件中的所有变量时，要使用同一个锁。
- 在执行复合操作时，要持有锁。
- 如果从多个线程中访问同一个可变变量时没有同步机制，那么程序会出现问题。
- 不要故作聪明地推断出不需要使用同步。
- 在设计过程中考虑线程安全，或者在文档中明确地指出它不是线程安全的。
- 将同步策略文档化。

## Executor框架

`Executor`：一个简单的接口，它提供了一种标准的方法将任务的提交过程与执行过程解耦开来，并用`Runnable`来表示任务。

`Executor`的实现通常会创建线程来执行任务，但JVM只有在所有非守护线程全部终止才会退出。因此，如果无法正确的关闭`Executor`，那么JVM将无法结束。

`ExecutorService`扩展了`Executor`接口，添加了一些用于生命周期管理的方法（同时还提供一些用于任务提交的便利方法）。

`ExecutorService`的生命周期有三种状态：运行、关闭和终止。`ExecutorService`最初创建后的初始状态是运行状态。当它被关闭后提交到`ExecutorService`的任务，会被拒绝执行处理器处理。它可能只是简单抛弃任务，或者引起`execute`方法抛出一个`RejectedExecutionException`等。一旦所有的任务全部完成后，`ExecutorService`会进入终止状态。可以调用`awaitTermination`来等待`ExecutorService`到达终止状态，或者通过`isTerminated`来轮询检查`ExecutorService`是否已经终止。通常在调用`shutdown`之后会立即调用`awaitTermination`阻塞等待，从而产生同步地关闭`ExecutorService`的效果。
> `shutdown`方法将执行平缓的关闭过程：{% label primary@不再接受新的任务，同时等待已经提交的任务执行完毕——包括尚未开始执行的任务。%}
> `shutdownNow`方法将执行粗暴的关闭过程：{% label primary@尝试取消所有运行中的任务，并且不再启动排在队列中尚未开始的任务。%}

在Executor框架中，已提交但尚未开始的任务可以取消，但对于那些已经开始执行的任务，只有当它们能够响应中断时，才能取消。取消一个已经完成的任务不会有任何影响。

### Executors中的静态方法

`newFixedThreadPool`：创建一个定长的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大长度，这时线程池的规模将不再变化（*如果某个线程由于发生了未预期的exception而结束，那么线程池会补充一个新的线程*）。

`newCachedThreadPool`：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，当需求增加时，它可以灵活地添加新线程，而并不会对池的长度做任何限制。

`newSingleThreadExecutor`：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO, LIFO, 优先级）执行。*如果这个线程异常结束会创建一个新的线程来替代*。

`newScheduledThreadPool`：创建一个定长线程池，支持定时及周期性任务执行。类似于`Timer`。
> {% label warning@Timer存在一些缺陷，你应该考虑使用ScheduledThreadPoolExecutor来替代它。%}
> 1. 只创建唯一的线程来执行所有的任务，如果一个任务执行很耗时，会导致其他任务的时效准确性出现问题。
> 2. 如果任务执行中抛出未检查的异常，将产生无法预料的行为（抛出未检查的异常会终止线程，不会重新恢复线程的执行，已经被安排但尚未执行的任务永远不再执行，新的任务也不能被调度，即发生线程泄露）。

如果你向`Executor`提交了一个批处理任务，并且希望在它们完成后获得结果。为此你可以保存与每个任务相关联的`Future`，然后不断地调用timeout为零的`get`，来检验`Future`是否完成。这样做固然可以，但却相当乏味。幸运的是，还有一个更好的方法：完成服务。

`CompletionService`整合了`Executor`和`BlockingQueue`的功能。你可以将`Callable`任务提交给它去执行，然后使用类似于队列中的`take`和`poll`方法，在结果完整可用时获得这个结果，像一个打包的`Future`。`ExecutorCompletionService`是实现`CompletionService`接口的一个类，并将计算任务委托给一个`Executor`。

## 取消与关闭

java没有提供任何机制来安全地终止线程。但它提供了中断，这是一种协作机制，能够使一个线程终止另一个线程的当前工作。

### 取消策略

一个可取消的任务必须拥有取消策略，这个策略详细定义取消操作的“How”、“When”、“What”，即代码如何（How）请求取消该任务，任务在何时（When）检查是否已经请求了取消，以及在响应时执行那些（What）操作。

应用程序可以不间断定期的检查标志位的状态是否被改变，来实现取消。但是 {% label warning@如果程序调用了一个阻塞方法（例如：BlockingQueu.put()）那么可能会出现一个严重的问题，即任务可能永远无法检查取消标志。%}

### 中断策略

一个中断策略决定线程如何应对中断请求——当发现中断请求时，应该做哪些工作，哪些工作单元对中断来说是原子操作，以及以多快速度来响应中断。

每个`Thread`都有一个boolean类型的中断状态。当中断线程时，该状态会被置为true。`Thread`中包含的中断方法：`inturrept()`会将中断状态置为true，`isInterrupted()`方法会返回当前的中断状态，而`interrupted()`方法则会清除当前状态，并返回它之前的值。

阻塞库函数：`Object.wait()`、`Thread.sleep()`和`Thread.join()`等，都会去检查线程何时中断，并且在发生中断时提前返回。它们在响应中断时执行的操作包括：清除中断状态，并抛出`InterruptedException`异常，表示阻塞操作由于中断而提前结束。

当线程在非阻塞状态下中断时，它的中断状态将被设置，然后根据将被取消的操作来检查中断状态以判断发生了中断。通过这样的方法，中断操作将变得“有黏性”——如果不触发`InterruptedException`，那么中断状态将一直保持，直到明确地清除中断状态。

{% label danger@调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。%}

对中断的正确理解是：它并不会真正地中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己（这些时刻也被称为取消点）。

使用`interrupted()`静态方法应该小心，因为它会清除并发线程的中断状态。如果你调用了interrupted，并且它返回了true，你必须对其进行处理，除非你想掩盖这个中断——你可以抛出`InterruptedException`，或者通过再次调用`interrupt`来恢复中断状态。

{% label success@通常中断是实现取消的最合理方式。%}

### 响应中断

在调用可中断的阻塞函数时，例如`Thread.sleep`或`BlockingQueue.put`等，有两种实用策略可用于处理`InterruptedException`：
- 传递异常（可能在执行某个特定于任务的清除操作之后），从而使你的方法也称为可中断的阻塞方法。
- 恢复中断状态，从而使调用栈中的上层代码能够对其进行处理。

只有实现了线程中断策略的代码才可以屏蔽中断请求。在常规的任务和库代码中都不应该屏蔽中断请求。

对于一些**不支持取消**但仍可以调用可中断阻塞方法的操作，它们必须在循环中调用这些方法，并在发现中断后重新尝试。在这种情况下，它们应该在本地保存中断状态，并在返回前恢复状态而不是在捕获`InterruptedException`时恢复状态。

如果代码不会调用可中断的阻塞方法，那么仍然可以通过在任务代码中轮询当前线程的中断状态来响应中断。

执行任务的线程拥有自己的执行策略，即使任务不响应中断，限时运行的方法仍然能返回到它的调用者。

### 通过Future取消

`ExecutorService.submit`会返回一个`Future`来描述任务。`Future`有一个`cancel`方法,它需要一个`boolean`类型的参数: `mayInterruptIfRunning`，它的返回值表示取消尝试是否成功（这仅仅告诉你它是否能够接收中断，而不是任务是否检测并处理了中断）。当`mayInterruptIfRunning`为true，并且任务当前正在某个线程中运行，那么这个线程能被中断。把这个参数设置成false意味着“如果还没有启动的话，不要运行这个任务”，这应该用于那些不处理中断的任务中。

当`Future.get`抛出`InterruptedException`或`TimeoutException`时，如果你知道不再需要结果，那么就可以调用`Future.cancel`来取消任务。

### 处理不可中断阻塞

**java.io中的同步Socket I/O**：Socket中的`InputStream`和`OutputStream`中的read和write方法都不响应中断，但是通过关闭底层的Socket，可以让read或write所阻塞的线程抛出一个`SocketException`。

**java.nio中的同步I/O**：中断一个等待`InterruptibleChannel`的线程，会导致抛出`ClosedByInterruptException`，并关闭链路（也会导致其他线程在这条链路的阻塞，抛出`ClosedByInterruptException`）。关闭一个`InterruptibleChannel`导致多个阻塞在链路操作上的线程抛出`AsynchronousCloseException`。大多数标准`Channel`都实现了`InterruptibleChannel`。

**Selector的异步I/O**：如果一个线程阻塞于`Selector.select`方法，`close`方法会导致它通过抛出`ClosedSelectorException`提前返回。

**获取某个锁**：如果一个线程由于等待某个内置锁而阻塞，那么将无法响应中断，因为线程认为它肯定会获得锁，所以将不会理会中断请求。然而显式`Lock`类提供了`lockInterruptibly`方法，允许你等待一个锁，并仍然能够响应中断。

采用`newTaskFor`来封装非标准的取消：
`newTaskFor`是一个工厂方法，它将创建`Future`来代表任务。`newTaskFor`还能返回一个`RunnableFuture`接口，该接口扩展了`Future`和`Runnable`（并由`FutureTask`实现）。

### 停止基于线程的服务

线程池拥有它的工作者线程，如果需要中断这些线程，那么应该由线程池负责。`ExecutorService`提供两种关闭方法：使用`shutdown`平滑关闭，以及使用`shutdownNow`强行关闭。在进行强行关闭时，会首先关闭当前正在执行的任务，然后返回所有尚未启动的任务清单。

配合使用`exec.shutdown()`和`exec.awaitTermination(timeout,unit)`来关闭线程服务。

另一种关闭生产者消费者服务的方法是使用“毒丸”对象。“毒丸”是指一个放在队列上的对象，其含义是：当你得到它时，停止一切工作。注意只有在无界队列中，毒丸对象才能够可靠地工作（要保证一定会被放置进去）。

### 处理非正常的线程终止

导致线程提前死亡的最主要原因是`RuntimeException`。由于这些异常表示出现了某种编程错误或者其他不可修复的错误，因此它们通常不会被捕获。它们不会在调用栈中逐层传递，而是默认地在控制台输出栈追踪消息，并终止线程。

{% label primary@当一个线程因为未捕获异常而退出时，JVM会把这个事件报告给应用程序提供的UncaughtExceptionHandler。如果处理器不存在，默认的行为是向System.err打印出栈追踪信息。%}

为了给线程池设置`UncaughtExceptionHandler`，需要向`ThreadPoolExecutor`的构造函数提供一个`ThreadFactory`。标准线程池允许未捕获的任务异常去结束池线程，但是使用一个`try-finally`块来接收通知的话，当池线程被终结后，能够有新的线程取代它。如果没有非捕获异常的处理器，或者其他失败通知机制，任务会无声无息地失败，这会导致混乱。如果你想在任务因为异常而失败时获得通知，并且执行一些特定于任务的恢复操作，那么可以将任务封装在能捕获异常的`Runnable`与`Callable`中，或者改写`ThreadPoolExecutor`的`afterExecute`方法。

**令人困惑的是**：只有通过`execute`提交的任务，才能将它抛出的异常送交给未捕获异常的处理器；而通过`submit`提交的任务，抛出的任何异常无论是否为受检查的，都被认为是任务返回状态的一部分。如果有`submit`提交的任务由于抛出了异常而结束，那么这个异常将被`Future.get`包装在`ExecutionException`中重新抛出。

### JVM关闭

JVM的关闭方式可以分为三种：
- 正常关闭：当最后一个非守护线程结束或者调用了`System.exit`或者通过其他特定平台的方法关闭（发送`SIGINT`，`SIGTERM`信号或者键入`Ctrl-C`等）。
- 强制关闭：通过调用`Runtime.halt`方法或者是在操作系统中直接(发送`SIGKILL`信号)kill掉JVM进程。
- 异常关闭：运行中遇到`RuntimeException`异常，OOM等。

#### 关闭钩子

在正常关闭中，JVM首先调用所有已注册的关闭钩子，关闭钩子是指通过`Runtime.addShutdownHook`注册的但尚未开始的线程。JVM并不能保证关闭钩子的调用顺序。在关闭应用程序线程时，如果有（守护或非守护）线程仍然在运行，那么这些线程接下来将与关闭进程并发执行。当所有关闭钩子都执行结束时，如果`runFinalizersOnExit`为true，那么JVM将运行终结器，然后再停止。JVM并不会停止或中断任何在关闭时仍然运行的应用程序线程。当JVM最终结束时，这些线程将被强行结束。如果关闭钩子或终结器没有执行完成，那么正常关闭进程“挂起”并且JVM必须被强行关闭。当被强行关闭时，只是关闭JVM，而不会运行关闭钩子。

{% label danger@关闭钩子应该是线程安全的：它们在访问共享数据时必须使用同步，并应该小心地避免死锁。%}

关闭钩子可以用于实现服务或应用程序的清理工作（比如：删除临时文件，清除无法由操作系统自动清除的资源等）。

{% label warning@关闭钩子不应该依赖于可能被应用程序或其他关闭钩子关闭的服务。%}因为所有钩子都是并发执行的且不能保证顺序，如果关闭一个服务依赖于另一个服务的时候这会出现竞态条件或死锁等问题。对所有的服务使用唯一的关闭钩子，让它执行一系列的关闭操作，而不是每个服务使用一个可以避免这个问题。

#### 守护线程

线程可分为两种：普通线程和守护线程。在JVM启动时创建的所有线程中，除了主线程以外，其它的线程都是守护线程（例如：垃圾回收器以及其它执行辅助工作的线程）。当创建一个新线程时，新线程将继承创建它的线程的守护状态。因此在默认情况下，主线程创建的所有线程都是普通线程。

普通线程与守护线程之间的差异仅在于当线程退出时发生的操作。当一个线程退出时，JVM会检查其他正在运行的线程，如果这些线程都是守护线程，那么JVM会正常退出操作。{% label warning@当JVM停止时，所有仍然存在的守护线程都将被抛弃——既不会执行finally代码块，也不会执行回卷栈，而JVM只是直接退出。%}

我们应尽可能少地使用守护线程——很少有操作能够在不进行清理的情况下被安全地抛弃。特别是，{% label danger@如果在守护线程中执行可能包含I/O操作的任务，那么将是一种危险的行为。 %}守护线程最好用于执行“内部任务”，例如：周期性地从内存的缓存中移除逾期的数据。

#### 终结器

由于终结器可以在某个由JVM管理的线程中运行，因此终结器访问的任何状态都可能被多个线程访问，这样就{% label danger@必须对其访问操作进行同步。终结器并不能保证它们将在何时运行甚至是否会运行，%}并且复杂的终结器通常还会在对象上产生巨大的性能开销。要编写正确的终结器是非常困难的。在大多数情况下，通过使用finally代码块和显示的close方法，能够比使用终结器更好地管理资源。唯一例外情况在于：{% label info@当需要管理对象，并且该对象持有的资源是通过本地方法获得的。%}

{% label success@避免使用终结器。%}

## 线程池的使用
### 在任务与执行策略之间的隐性耦合

{% label warning@只有当线程本地值的生命周期受限于任务的生命周期时，在线程池的线程中使用ThreadLocal才有意义，而在线程池的线程中不应该使用ThreadLocal在任务之间传递值。%}
<br/>
{% label primary@只有当任务是同类型的并且相互独立时，线程池的性能才能达到最佳。%}如果将运行时间较长的与运行时间较短的任务混合在一起，那么除非线程池很大，否则将可能造成{% label danger@拥塞 %}。如果提交的任务依赖于其他任务，那么除非线程池无限大，否则将可能造成{% label danger@死锁 %}。

只要线程池中的任务需要无限期地等待一些必须由池中其他任务才能提供的资源或条件，例如某个任务等待另一个任务的返回值或执行结果，那么除非线程池足够大，否则将发生线程{% label danger@饥饿死锁%}。

执行时间较长的任务不仅会造成线程池堵塞，甚至还会增加执行时间较短任务的服务时间。有一项技术可以缓解执行时间较长任务造成的影响，即限定任务等待资源的时间，而不要无限地等待。如果在线程池中总是充满了被阻塞的任务，那么也可能表明线程池的规模过小。

### 设置线程池的大小

对于**计算密集型任务**，在拥有Ncpu个处理器的系统上，当线程池的大小为Ncpu+1时，通常能实现最优的利用率（即使当计算密集型的线程偶尔由于页缺失故障或其他原因而暂停时，这个额外的线程也能确保CPU的时钟周期不会被浪费）。

对于**包含I/O操作或其他阻塞操作的任务**，由于线程并不会一直执行，因此线程池的规模应该更大。要正确的设置线程池的大小，你必须估算出任务的等待时间与计算时间的比值。这种估算不需要很精确，并且可以通过分析或监控工具获得。

```
    Ncpu = cpu的数量
    Ucpu = 目标cpu的利用率，0 ≤ Ucpu ≤ 1
    W/C = 等待时间与计算时间的比率
    为保持处理器达到期望的利用率，最优的线程池大小等于：Nthreads = Ncpu * Ucpu * (1 + W/C)
```

也可以通过另一种方法来调节线程池大小：在某个基准负载下，分别设置不同大小的线程池来运行应用程序，并观察CPU利用率的水平。

当然，CPU周期并不是唯一影响线程池大小的资源，还包括内存、文件句柄、套接字句柄、数据库连接等。计算这些资源对线程池的约束条件更容易：计算每个任务对该资源的需求量，然后用该资源的可用总量除以每个任务的需求量，所得结果就是线程池大小的上限。

### 配置ThreadPoolExecutor

对于`Executor`，`newCachedThreadPool`工厂方法是一种很好的默认选择，它能提供比固定大小的线程池更好的排队性能。当需要限制当前任务的数量以满足资源管理需求时，那么可以选择固定大小的线程池，就像在接受网络客户请求的服务器应用程序中，如果不进行限制，那么很容易发生过载问题。

{% label primary@只有任务相互独立时，为线程池或者工作队列设置界限才是合理的。%}如果任务之间存在依赖性，那么有界的线程池或队列就可能导致线程“饥饿”死锁问题。此时应该使用无界的线程池。

#### 饱和策略

中止（Abort）策略：是默认的饱和策略，该策略将抛出未检查的`RejectedExecutionException`。
抛弃（Discard）策略：会悄悄抛弃该任务。
抛弃最旧的（Discard-Oldest）策略：则会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。（{% label warning@如果工作队列是一个优先队列，那么“抛弃最旧的”策略将导致抛弃优先级最高的任务，因此最好不要将“抛弃最旧的”饱和策略和优先级队列放在一起使用%}）。
调用者运行（Caller-Runs）策略：实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。它不会在线程池的某个线程中执行新提交的任务，而是在一个调用了`execute`的线程中执行该任务。由于执行任务需要一定的时间，因此主线程至少在一段时间内不能提交任何任务，从而使得工作者线程有时间来处理正在执行的任务。在这期间，主线程不会调用`accept`，因此到达的请求将被保存在TCP层的队列而不是在应用程序的队列中。如果持续过载，那么TCP层将最终发现它的请求队列被填满，因此同样会开始抛弃请求。当服务器过载时，这种过载情况会逐渐向外蔓延开来，从线程池到工作队列到应用程序再到TCP层，最终达到客户端，导致服务器在高负载下实现一种平缓的性能降低。

#### 线程工厂

线程池需要创建一个线程，都要通过线程工厂方法来完成。默认的线程工厂创建一个新的、非守护的线程，并且不包含特殊的配置信息。`ThreadFactory`只有唯一的方法：`newThread`，每当线程池需要创建一个新线程时都会调用该方法。

许多情况下都需要使用定制的线程工厂方法：为线程池中的线程指定`UncaughtExceptionHandler`；实例化一个定制的`Thread`类用于执行调试信息的记录；给线程取一个更有意义的名称等。

如果在应用程序中需要利用安全策略来控制对某些特殊代码库的访问权限，那么可以通过`Executor`中的`privilegedThreadFactory`工厂来定制自己的线程工厂。

如果`Executor`是通过`Executors`中的某个工厂方法创建的，那么可以将结果的类型强转为`ThreadPoolExecutor`以访问设置器，在构造后更改其属性。

在`Executors`中包含一个`unconfigurableExecutorService`工厂方法，该方法对一个现有的`ExecutorService`进行包装，使其只暴露出`ExecutorService`的方法，因此不能对其进行配置。

### 扩展ThreadPoolExecutor

`ThreadPoolExecutor`是可扩展的，它提供了`beforeExecute`，`afterExecute`和`terminated`方法可用于扩展其行为。

无论任务是从`run`中正常返回，还是抛出一个异常而返回，`afterExecute`都会被调用（如果任务在完成后带有一个`Error`，那么就不会调用`afterExecute`）。如果`beforeExecute`抛出一个`RuntimeException`，那么任务将不被执行，并且`afterExecute`也不会被调用。

{% label success@当串行循环中的各个迭代操作之间彼此独立，并且每个迭代操作执行的工作量比管理一个新任务时带来的开销更多，那么这个串行循环就适合并行化。%}

## 性能与可伸缩性
### 对性能的思考

要想通过并发来获得更好的性能，需要努力做好两件事情：更有效地利用现有处理资源，以及在出现新的处理资源时使程序尽可能地利用这些新资源。

可伸缩性：当增加计算资源时（例如CPU、内存、存储容量或I\O带宽），程序的吞吐量或者处理能力能相应地增加。

避免不成熟的优化。首先使程序正确，然后再提高运行速度——如果它运行得还不够快。

在大多数性能决策中都包含有多个变量，并且非常依赖于运行环境。{% label primary@在使某个方案比其他方案“更快”之前，首先问自己一些问题：%}

- “更快”的含义是什么？
- 该方法在什么条件下运行得更快？在低负载还是高负载的情况下？大数据集还是小数据集？能否通过测试结果来验证你的答案？
- 这些条件在运行环境中的发生频率？能否通过测试结果来验证你的答案？
- 在其他不同条件的环境中能否使用这里的代码？
- 在实现这种性能提升时需要付出哪些隐含地代价，例如增加开发风险或维护开销？这种权衡是否合适？

在对性能的调优时，一定要有明确的性能需求（这样才能知道什么时候需要调优，以及什么时候应该停止），此外还需要一个测试程序以及真实地配置和负载等环境。在对性能调优后，你需要再次测量以验证是否到达了预期的性能提升目标。

{% label warning@以测试为基准，不要猜测。%}

### Amdahl定律

Amdahl定律：在增加计算资源的情况下，程序在理论上能够实现最高加速比，这个值取决于程序中可并行组件与串行组件所占的比重。

```
最高加速比：Speedup <= 1 / (F + (1 - F) / N)
处理器利用率：Speedup / N

N: 处理器的个数
F: 必须被串行执行的部分
```

当N趋近无穷大时，最大的加速比趋近于1/F。程序串行的部分越少，增加计算资源时，能够达到的最高加速比越大。

在所有并发程序中都包含一些串行部分。如果你认为你的程序中不存在串行部分，那么可以再仔细检查一遍。

Amdahl定律告诉我们：{% label primary@程序的可伸缩性取决于所有代码中必须被串行执行的代码比例。%}

### 线程引入的开销

- 上下文切换
    在程序中发生越多的阻塞（包括阻塞I/O，等待获取发生竞争的锁，或者在条件变量上等待），与CPU密集型的程序就会发生越多的上下文交换，从而增加调度开销，并因此而降低吞吐量。
- 内存同步
    现代的JVM能够通过优化去掉一些不会发生竞争的锁，从而减少不必要的同步开销。

    不要过度担心非竞争同步带来的开销。这个基本的机制已经非常快了，并且JVM还能进行额外的优化以进一步降低或消除开销。因此，{% label success@我们应该将优化重点放在那些发生锁竞争的地方。%}
- 阻塞
    非竞争的同步可以完全在JVM中进行处理，而竞争的同步可能需要操作系统的介入，从而增加开销。

### 减少锁的竞争

{% label danger@在并发程序中，对可伸缩性的最主要威胁就是独占方式的资源锁。%}

有两个因素将影响在锁上发生竞争的可能性：**锁的请求频率**，以及**每次持有该锁的时间**。如果二者的乘积很小，那么大多数获取锁的操作都不会发生竞争，因此在该锁上的竞争不会对可伸缩性造成严重的影响。然而，如果在锁上的请求量很高，那么需要获取该锁的线程被阻塞等等待。在极端的情况下，即使仍有大量工作等待完成，处理器也会被闲置。

{% label primary@有3种方式可以降低锁的竞争程度：%}

- 减少锁的持有时间。
- 降低锁的请求频率。
- 使用带有协调机制的独占锁（非独占/非阻塞锁），这些机制允许更高的并发性。

#### 缩小锁的范围

降低发生竞争可能性的一种有效方式就是**尽可能缩短锁的持有时间**。例如，可以将一些与锁无关的代码移除同步代码块，尤其是那些开销比较大的操作，以及可能被阻塞的操作，例如I/O操作。

尽管缩小同步代码块能提高可伸缩性，但同步代码快也不能过小——一些需要采用原子方式执行的操作（例如对某个不变性条件中的多个变量进行更新）必须包含在一个同步块中。此外，同步需要一定的开销，当把一个同步代码块分解为多个同步代码块时（在确保正确性的情况下），反而会对性能提升产生负面影响。在分解同步代码块时，理想的平衡点将与平台相关，但在实际情况中，仅当可以将一些“大量”的计算或阻塞操作从同步代码块中移出时，才应该考虑同步代码块的大小。

#### 减小锁的粒度

另一种减小锁的持有时间的方式是**降低线程请求锁的频率**（从而减小发生竞争的可能性）。这可以通过**锁分解**和**锁分段**技术来实现，在这些技术中将采用多个相互独立的锁来保护独立的状态变量，从而改变这些变量在之前由单个锁来保护的情况。这些技术能减小锁操作的粒度，并能实现更高的可伸缩性，然而，使用的锁越多那么发生死锁的风险也越高。

如果一个锁需要保护多个相互独立的状态变量，那么可以将这个锁分解为多个锁，并且每个锁只保护一个变量，从而提高可伸缩性，并最终降低每个锁被请求的频率。

#### 锁分段

锁分段的一个劣势在于：{% label warning@与采用单个锁来实现独占访问相比，要获取多个锁来实现独占访问将更加困难并且开销更高。%}例如：java7 ConcurrentHashMap扩容重哈希时需要获取分段锁集合中的所有锁。

#### 避免热点域

当每个操作都请求多个变量时，锁的粒度将很难降低。这是在性能与可伸缩性之间相互制衡的另一个方面，一些常见的优化措施，例如将一些反复计算的结果缓存起来，都会引入一些“热点域”，而这些热点域往往会限制可伸缩性。

#### 一些替代独占锁的方法

第三种降低竞争锁的影响的技术就是**放弃使用独占锁**，从而有助于使用一种友好并发的方式来管理共享状态。例如，使用并发容器、读-写锁、不可变对象以及原子变量。

如果在类中只包含少量的热点域，并且这些域不会与其他变量参与到不变性条件中，那么用原子变量来替代他们能提高可伸缩性。（通过减少算法中的热点域，可以提高可伸缩性——虽然原子变量能降低热点域的更新开销，但并不能完全消除。）

#### 监测CPU的利用率

当测试可伸缩性时，通常要确保处理器得到充分利用。可用工具如：UNIX系统上的`vmstat`和`mpstat`，或者Windows系统上的`perfmon`。

如果所有CPU的利用率并不均匀（有些CPU在忙碌地运行，而其他CPU却并非如此），那么你的首要目标就是进一步找出程序中的并行性。不均匀的利用率表明大多数计算都是由一小组线程完成的，并且应用程序没有利用其他的处理器。如果CPU没有得到充分利用，那么需要找出其中的原因。通常由以下几种原因：

- 负载不充足
- I/O密集
- 外部限制
- 锁竞争

> 在`vmstat`命令的输出中，有一栏信息是当前处于可运行状态但并没有运行（由于没有足够的CPU）的线程数量。

####  向对象池说“不”

{% label primary@通常，对象分配操作的开销比同步的开销更低。%}

### 减少上下文切换的开销

当任务在*运行*和*阻塞*这两个状态之间转换时，就相当于一次上下文切换。在锁获取操作上发生竞争时将导致更多的上下文切换。

## 并发程序的测试

并发测试大致分为两类：安全性测试和活跃性测试。

安全性：不发生任何错误的行为。
活跃性：某个良好的行为终究会发生。
吞吐量：指一组并发任务中已完成任务所占的比例。
响应性：指请求从发出到完成之间的时间（也被称为延迟）。
可伸缩性：指在增加更多资源的情况下（通常指CPU），吞吐量的提升情况。

### 正确性测试

在为某个并发类设计单元测试时，首先需要执行与测试串行类时相同的分析——{% label primary@找出需要检查的不变性条件和后验条件。%}

要测试在生产者—消费者模式中使用的类，一种有效的方法就是检查放入队列中和从队列中取出的各个元素。

测试单生产者—单消费者方法：通过一个对顺序敏感的检验和和计算函数来计算所有入队元素以及出队元素的校验和，并进行比较。如果两者相等，则测试就是成功的。

测试多生产者—多消费者方法：通过一个对元素入列/出列顺序不敏感的校验和计算函数，从而在测试程序运行完以后，可以将多个校验和以不同的顺序组合起来。

对于任何持有或管理其他对象的对象，都应该在不需要这些对象时销毁对它们的引用。这种存储资源泄露不仅会妨碍垃圾回收器回收内存（或线程、文件句柄、套接字、数据库连接或其他有限资源），而且还会导致资源耗尽以及应用程序失败。

在构造测试案例时，对客户提供的代码进行回调是非常有帮助的。回调函数的执行通常是在对象生命周期的一些已知位置上，并且在这些位置上非常适合判断不变性条件是否被破坏。例如，在`ThreadPoolExecutor`中将调用任务的`Runnable`和`ThreadFactory`。

由于并发代码中的大多数错误都是一些低概率事件，因此在测试并发错误时需要反复地执行许多次，但有些方法可以提高发现这些错误的概率。有一种有用的方法可以提高交替操作的数量，以便能更有效地搜索程序的状态空间：在访问共享状态的操作中，使用`Thread.yield`将产生更多的上下文切换。

### 性能测试

性能测试将衡量典型测试用例中的端到端性能。通常要获得一组合理的使用场景并不容易，理想情况下，在测试中应该反映出被测试对象在应用程序中的实际用法。

根据经验值来调整各种不同的限值，如线程数，缓存容量等。这些限值可能依赖于具体平台的特性（例如：处理器的类型、处理器的步进级别、CPU的数量、内存大小等），因此需要动态地进行配置，而我们通常需要合理地选择这些值，从而使程序能够在更多的系统上良好地运行。

### 避免性能测试陷阱

#### 垃圾回收
防止垃圾回收操作对测试结果产生偏差：
- 确保垃圾回收操作在测试的整个期间都不会执行（可以在调用JVM时指定`-verbose: gc`来判断是否执行了垃圾回收操作）。
- 确保垃圾回收操作在测试期间执行多次，这样测试程序就能充分反映出运行期间的内存分配与垃圾回收的开销（更长的测试时间）。

#### 动态编译

当某个类第一次被加载时，JVM会通过解释字节码的方式来执行它，在某个时刻，如果一个方法运行的次数足够多，那么动态编译器会将它编译为机器代码，当编译完成后，代码的执行方式将从解释执行变成直接执行。

基于各种原因，代码还可能被反编译（退回到解释执行）以及重新编译，例如加载了一个会是编译假设无效的类，或者在收集了足够的分析信息后，决定采用不同的优化措施来重新编译某条代码路径。

防止动态编译对测试结果产生偏差：
- 使程序运行足够长的时间（至少数分钟），这样编译过程以及解释执行都只是总运行时间的很小一部分。
- 使代码预先运行一段时间并且不测试这段时间内的代码性能，这样在开始计时前代码就已经被完全编译了。

#### 对代码路径的不真实采样

运行时编译器根据收集到的信息对已编译的代码进行优化。例如，如果当前已加载的类都没有改写某个方法，那么JVM会通过单一调用转换将虚拟方法调用转换为直接方法调用。但如果后来加载了一个改写了该方法的类，那么之前已编译的代码将失效。

#### 不真实的竞争程度

要获得有实际意义的测试结果，就需要模拟最接近正式环境的并发量和竞争程度。

#### 无用的代码消除

优化编译器能找出并消除那些不会对输出结果产生任何影响的无用代码。

避免算法被优化掉而又不会引入过高的开销：
- 计算某个派生对象中域的散列值，并将它与一个任意值进行比较。如`System.nanoTime`的当前值，如果二者碰巧相等，那么就输出一个无用并且可以被忽略的消息。

不仅每个计算结果都应该被使用，而且还应该是不可预测的，否则，一个智能的动态优化编译器将用预先计算的结果来代替计算过程。

### 其他的测试方法

质量保证的目标应该是{% label primary@在给定的测试资源下实现最高的可信度。%}

代码审查、静态分析工具（如FindBugs）、面向切面的测试技术，分析与监测工具（如JMX的`ThreadInfo`）。

----
* *《Java并发编程实战》*