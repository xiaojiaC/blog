---
title: 设计模式
date: 2023-09-03 19:00:01
categories:
  - [设计模式]
tags:
  - design patterns
---

{% centerquote %}

意图降低对象之间的耦合，增加程序的可复用性、可扩展性、可靠性和可维护性。

{% endcenterquote %}

### 设计原则

| 设计原则     | 含义                                                                     | 目的                         |
| ------------ | ------------------------------------------------------------------------ | ---------------------------- |
| 开闭原则     | 对扩展开放，对修改关闭                                                   | 降低维护带来的新风险         |
| 单一职责原则 | 一个类应该只有一个引起变化的原因                                         | 便于理解，提高代码的可读性   |
| 接口隔离原则 | 一个接口只干一件事，接口要精简单一                                       | 功能解耦，高聚合低耦合       |
| 依赖倒置原则 | 高层不应该依赖低层；抽象不应该依赖细节，细节应该依赖抽象；要面向接口编程 | 利于代码结构的升级扩展       |
| 最少知识法则 | 不该知道的不要知道，一个类应该保持对其它对象最少的了解                   | 只和你的密友说话，降低耦合度 |
| 里氏替换原则 | 不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义     | 防止继承泛滥                 |
| 组合复用原则 | 尽量使用组合或者聚合关系实现代码复用，少使用继承                         | 降低代码耦合                 |

<!-- more -->

### 设计模式

- [单例](/blog/单例模式.html)：确保某一个类只有一个实例存在。
- [工厂方法](/blog/工厂模式.html)：创建单个产品实例。
- [抽象工厂](/blog/工厂模式.html)：创建一族产品实例。
- [建造者](/blog/建造者模式.html：允许创建不同口味的对象以避免构造器污染。
- [原型](/blog/原型模式.html)：通过复制现有的实例来创建新的实例，无需知道相应类的信息。
-
- [适配器](/blog/适配器模式.html)：将一个接口转换成另一个客户所期望的接口。
- [装饰器](/blog/装饰器模式.html)：装饰对象动态为其添加额外行为。
- [代理](/blog/代理模式.html)：代理某个对象的行为和方法，添加自定义功能。
- [外观](/blog/外观模式.html)：为一个子系统中的一系列接口提供一个简单统一的接口。
- [桥接](/blog/桥接模式.html)：将抽象与其实现分离，从而使两个层次结构可以独立变化。
- [组合](/blog/组合模式.html)：可以使客户统一对待单个对象和组合对象。
- [享元](/blog/享元模式.html)：用共享技术来有效地支持大量细粒度对象的复用。
-
- [策略](/blog/策略模式.html)：在运行时选择最匹配的算法。
- [模板方法](/blog/模板方法模式.html)：定义算法骨架，将某些步骤推迟到子类实现。
- [观察者](/blog/观察者模式.html)：一个对象的改变导致所有依赖它的对象都将自动通知或更新。
- [迭代器](/blog/迭代器模式.html)：不暴露容器内部表示的一种顺序访问元素的方式。
- [责任链](/blog/责任链模式.html)：串联接收对象并在链条中传递请求直到一个对象处理它。
- [命令](/blog/命令模式.html)：对请求进行封装，将命令的发出和命令的执行解耦开。
- [状态](/blog/状态模式.html)：允许对象在内部状态改变时改变它的行为。（与策略模式类图相似，区别在于：策略模式会控制对象使用什么策略，而状态模式会自动改变对象状态流转。）
- 备忘录：在不破坏封装性的前提下，捕获和保存一个对象的内部状态，以便在需要时恢复该对象到原先的状态。
- 中介者：定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。
- 解释器：给定一个语言，定义它的文法的一种表示，并定义一个解释器，使用该解释器来解释语言中的句子。
- [访问者](/blog/访问者模式.html)：允许将功能添加到现有的类层次结构中，而无需修改层次结构。
-
- 非循环访问者：同访问者，但没有循环依赖的问题（被访问者依赖访问者基类，访问者依赖被访问者所有子类）。
- 抽象文档：为对象添加类型安全的动态属性。
- 活动对象：有自己的控制机制线程，封装对象方法的执行仅公开其 API，使方法调用与方法执行脱钩。
- 回调：传递给调用者的方法，它将在定义的时刻被调用。

### UML 类图

- `o--`: 聚合，整体与局部关系，局部可以脱离整体存在，具有各自的生命周期。表示 has-a（实例变量），例如公司与员工 `Company o-- Employee`
- `*--`: 组合，整体与局部关系，局部不可以脱离整体存在，其生命周期应该是一致的。表示 contain-a（实例变量），例如大脑与人类 `Person \*-- Brain`
- `--|>`: 继承，箭头从子类指向父类。表示 is-a（extends），例如柴犬与狗 `ShibaInu --|> Dog`
- `..|>`: 实现，箭头从实现类指向接口。表示 is-a（implement），例如狗与动物 `Dog ..|> Animal`
- `..>`: 依赖，箭头从使用类指向被依赖的类。表示 一个类调用被依赖类中的某些方法而得以完成这个类的一些职责。（局部变量，方法中的参数和对静态方法的调用）
- `-->`/`"+attr1"-->"-attr2"`: 单向关联，箭头从使用类指向被关联的类，可注明关联的属性。例如：`A --> B`，表示 B 类作为 A 类的属性。（实例变量）
- `--`/`"1"--"N"`: 双向关联，箭头从使用类指向被关联的类，可注明 1 对多、或多对一。例如：`A "1"--"N" B`，表示 B 类作为 A 类的属性同时，A 类也是 B 类的属性。（实例变量）

> [plantuml class diagram](https://plantuml.com/zh/class-diagram)
