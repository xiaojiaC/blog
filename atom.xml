<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Oh_null&#39;s blog</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://xiaojiac.github.io/blog/"/>
  <updated>2023-10-18T13:45:27.130Z</updated>
  <id>http://xiaojiac.github.io/blog/</id>
  
  <author>
    <name>xiaojiaC</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>组合模式</title>
    <link href="http://xiaojiac.github.io/blog/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.html"/>
    <id>http://xiaojiac.github.io/blog/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.html</id>
    <published>2023-10-17T13:35:06.000Z</published>
    <updated>2023-10-18T13:45:27.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>将对象组合成树结构以表示部分整体层次结构。 组合可以使客户统一对待单个对象和组合对象。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>需要表示一个对象整体与部分的层次结构时，可以使用组合模式来实现树形结构。例如：文件系统中的文件与文件夹。</li><li>需要忽略组合对象和单个对象之间的差异，客户将统一对待组合结构中的所有对象。例如：菜单系统中的菜单项与子菜单。</li><li>需要将对象的创建和使用分离时，可以使用组合模式来实现依赖注入。例如：<code>Spring</code>框架中的 Bean 对象。</li><li>……</li></ul><a id="more"></a><h3 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/awt/Container.html" target="_blank" rel="noopener">java.awt.Container</a> / <a href="http://docs.oracle.com/javase/8/docs/api/java/awt/Component.html" target="_blank" rel="noopener">java.awt.Component</a></li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每个句子由单词组成，单词又由字符组成。这些对象中的每一个都是可打印的，它们可以在它们之前或之后打印一些内容，</span></span><br><span class="line"><span class="comment"> * 例如句子始终以句号结尾，单词始终在其前面有空格。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LetterComposite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;LetterComposite&gt; children = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(LetterComposite letter)</span> </span>&#123;</span><br><span class="line">        children.add(letter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">printThisBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">printThisAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        printThisBefore();</span><br><span class="line">        children.forEach(LetterComposite::print);</span><br><span class="line">        printThisAfter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Letter</span> <span class="keyword">extends</span> <span class="title">LetterComposite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> character;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Letter</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.character = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">printThisBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(character);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Word</span> <span class="keyword">extends</span> <span class="title">LetterComposite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Word</span><span class="params">(List&lt;Letter&gt; letters)</span> </span>&#123;</span><br><span class="line">        letters.forEach(<span class="keyword">this</span>::add);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Word</span><span class="params">(<span class="keyword">char</span>... letters)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> letter : letters) &#123;</span><br><span class="line">            <span class="keyword">this</span>.add(<span class="keyword">new</span> Letter(letter));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">printThisBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sentence</span> <span class="keyword">extends</span> <span class="title">LetterComposite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sentence</span><span class="params">(List&lt;Word&gt; words)</span> </span>&#123;</span><br><span class="line">        words.forEach(<span class="keyword">this</span>::add);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">printThisAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">".\r\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Messenger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">LetterComposite <span class="title">messageFromOrcs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Word&gt; words = List.of(</span><br><span class="line">                <span class="keyword">new</span> Word(<span class="string">'W'</span>, <span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'r'</span>, <span class="string">'e'</span>),</span><br><span class="line">                <span class="keyword">new</span> Word(<span class="string">'t'</span>, <span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'r'</span>, <span class="string">'e'</span>),</span><br><span class="line">                <span class="keyword">new</span> Word(<span class="string">'i'</span>, <span class="string">'s'</span>),</span><br><span class="line">                <span class="keyword">new</span> Word(<span class="string">'a'</span>),</span><br><span class="line">                <span class="keyword">new</span> Word(<span class="string">'w'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'p'</span>),</span><br><span class="line">                <span class="keyword">new</span> Word(<span class="string">'t'</span>, <span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'r'</span>, <span class="string">'e'</span>),</span><br><span class="line">                <span class="keyword">new</span> Word(<span class="string">'i'</span>, <span class="string">'s'</span>),</span><br><span class="line">                <span class="keyword">new</span> Word(<span class="string">'a'</span>),</span><br><span class="line">                <span class="keyword">new</span> Word(<span class="string">'w'</span>, <span class="string">'a'</span>, <span class="string">'y'</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Sentence(words);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LetterComposite <span class="title">messageFromElves</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Word&gt; words = List.of(</span><br><span class="line">                <span class="keyword">new</span> Word(<span class="string">'M'</span>, <span class="string">'u'</span>, <span class="string">'c'</span>, <span class="string">'h'</span>),</span><br><span class="line">                <span class="keyword">new</span> Word(<span class="string">'w'</span>, <span class="string">'i'</span>, <span class="string">'n'</span>, <span class="string">'d'</span>),</span><br><span class="line">                <span class="keyword">new</span> Word(<span class="string">'p'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>),</span><br><span class="line">                <span class="keyword">new</span> Word(<span class="string">'f'</span>, <span class="string">'r'</span>, <span class="string">'o'</span>, <span class="string">'m'</span>),</span><br><span class="line">                <span class="keyword">new</span> Word(<span class="string">'y'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>, <span class="string">'r'</span>),</span><br><span class="line">                <span class="keyword">new</span> Word(<span class="string">'m'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>, <span class="string">'t'</span>, <span class="string">'h'</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Sentence(words);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="">示例代码</a></p></blockquote><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><img src="/blog/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/composite_demo.png" class=""><img src="/blog/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/composite.png" class=""><p>类图中主要包含以下角色：</p><p>抽象构件角色（<code>Component</code>）：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。<br>叶子构件角色（<code>Leaf</code>）：它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过抛出异常等方式进行处理。<br>容器构件角色（<code>Composite</code>）：它在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;组合模式&quot;&gt;&lt;a href=&quot;#组合模式&quot; class=&quot;headerlink&quot; title=&quot;组合模式&quot;&gt;&lt;/a&gt;组合模式&lt;/h2&gt;&lt;h3 id=&quot;意图&quot;&gt;&lt;a href=&quot;#意图&quot; class=&quot;headerlink&quot; title=&quot;意图&quot;&gt;&lt;/a&gt;意图&lt;/h3&gt;&lt;p&gt;将对象组合成树结构以表示部分整体层次结构。 组合可以使客户统一对待单个对象和组合对象。&lt;/p&gt;
&lt;h3 id=&quot;适用场景&quot;&gt;&lt;a href=&quot;#适用场景&quot; class=&quot;headerlink&quot; title=&quot;适用场景&quot;&gt;&lt;/a&gt;适用场景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;需要表示一个对象整体与部分的层次结构时，可以使用组合模式来实现树形结构。例如：文件系统中的文件与文件夹。&lt;/li&gt;
&lt;li&gt;需要忽略组合对象和单个对象之间的差异，客户将统一对待组合结构中的所有对象。例如：菜单系统中的菜单项与子菜单。&lt;/li&gt;
&lt;li&gt;需要将对象的创建和使用分离时，可以使用组合模式来实现依赖注入。例如：&lt;code&gt;Spring&lt;/code&gt;框架中的 Bean 对象。&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="组合模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="design patterns" scheme="http://xiaojiaC.github.io/blog/tags/design-patterns/"/>
    
      <category term="gof" scheme="http://xiaojiaC.github.io/blog/tags/gof/"/>
    
      <category term="structural" scheme="http://xiaojiaC.github.io/blog/tags/structural/"/>
    
      <category term="composite" scheme="http://xiaojiaC.github.io/blog/tags/composite/"/>
    
  </entry>
  
  <entry>
    <title>原型模式</title>
    <link href="http://xiaojiac.github.io/blog/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html"/>
    <id>http://xiaojiac.github.io/blog/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html</id>
    <published>2023-10-17T12:55:06.000Z</published>
    <updated>2023-10-18T13:45:27.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>通过复制现有的实例来创建新的实例，无需知道相应类的信息。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>某些结构复杂的对象的创建工作，由于需求的变化，这些对象经常面临着剧烈的变化，但是他们却拥有比较稳定一致的接口。</li><li>细胞分裂</li><li>物种克隆</li><li>……</li></ul><a id="more"></a><h3 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h3><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone--" target="_blank" rel="noopener">java.lang.Object#clone()</a></li><li><a href="https://commons.apache.org/proper/commons-beanutils/javadocs/v1.9.4/apidocs/org/apache/commons/beanutils/BeanUtils.html#cloneBean-java.lang.Object-" target="_blank" rel="noopener">Apache commons-beanutils BeanUtils#cloneBean(Object)</a></li><li><a href="https://docs.spring.io/spring-framework/docs/5.3.29/javadoc-api/org/springframework/beans/factory/config/ConfigurableBeanFactory.html#SCOPE_PROTOTYPE" target="_blank" rel="noopener">Spring ConfigurableBeanFactory#SCOPE_PROTOTYPE</a></li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 百宝箱包含一组魔法物品。有多种物品，例如戒指，药水和武器。可以使用藏宝箱提供的迭代器按类型浏览物品。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShippingAddress</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String receiver;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ShippingAddress <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 浅拷贝</span></span><br><span class="line">        <span class="comment">// return (ShippingAddress) super.clone();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        ShippingAddress res = (ShippingAddress) <span class="keyword">super</span>.clone();</span><br><span class="line">        res.address = res.address.clone(); <span class="comment">// 非基本数据类型属性也需拷贝</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String country;</span><br><span class="line">        <span class="keyword">private</span> String province;</span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">        <span class="keyword">private</span> String detail;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Address <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (Address) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="">示例代码</a></p></blockquote><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>创建一个新对象，新对象的属性和原来对象完全相同，对于非基本数据类型属性，仍指向原有属性所指向对象的内存地址。</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><img src="/blog/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/prototype.png" class=""><p>类图中主要包含以下角色：</p><p>抽象原型角色（<code>Prototype</code>）：声明克隆方法的接口，来说明它有被克隆功能。<br>具体原型角色（<code>ConcretePrototype</code>）：实现在抽象原型中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原型模式&quot;&gt;&lt;a href=&quot;#原型模式&quot; class=&quot;headerlink&quot; title=&quot;原型模式&quot;&gt;&lt;/a&gt;原型模式&lt;/h2&gt;&lt;h3 id=&quot;意图&quot;&gt;&lt;a href=&quot;#意图&quot; class=&quot;headerlink&quot; title=&quot;意图&quot;&gt;&lt;/a&gt;意图&lt;/h3&gt;&lt;p&gt;通过复制现有的实例来创建新的实例，无需知道相应类的信息。&lt;/p&gt;
&lt;h3 id=&quot;适用场景&quot;&gt;&lt;a href=&quot;#适用场景&quot; class=&quot;headerlink&quot; title=&quot;适用场景&quot;&gt;&lt;/a&gt;适用场景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;某些结构复杂的对象的创建工作，由于需求的变化，这些对象经常面临着剧烈的变化，但是他们却拥有比较稳定一致的接口。&lt;/li&gt;
&lt;li&gt;细胞分裂&lt;/li&gt;
&lt;li&gt;物种克隆&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="原型模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="design patterns" scheme="http://xiaojiaC.github.io/blog/tags/design-patterns/"/>
    
      <category term="gof" scheme="http://xiaojiaC.github.io/blog/tags/gof/"/>
    
      <category term="creational" scheme="http://xiaojiaC.github.io/blog/tags/creational/"/>
    
      <category term="prototype" scheme="http://xiaojiaC.github.io/blog/tags/prototype/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="http://xiaojiac.github.io/blog/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html"/>
    <id>http://xiaojiac.github.io/blog/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html</id>
    <published>2023-10-16T13:13:06.000Z</published>
    <updated>2023-10-18T13:45:27.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>当一个对象改变状态时，所有依赖它的对象都将自动通知或更新。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>当一个对象的改变的同时需要改变其他对象，同时你又不知道有多少对象需要改变时。</li><li>当一个对象可以通知其他对象而无需假设这些对象是谁时。</li><li>服务注册中心</li><li>图形界面应用程序</li><li>RSS/消息订阅/邮件系统</li><li>……</li></ul><a id="more"></a><h3 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Observer.html" target="_blank" rel="noopener">java.util.Observer</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/EventListener.html" target="_blank" rel="noopener">java.util.EventListener</a></li><li><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a></li><li><a href="https://docs.spring.io/spring-framework/docs/5.3.29/javadoc-api/org/springframework/context/ApplicationListener.html" target="_blank" rel="noopener">Spring ApplicationListener</a></li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在遥远的土地上生活着霍比特人和兽人的种族。他们都是户外生活的人所以他们密切关注天气的变化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WeatherObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(WeatherType currentWeather)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> WeatherType &#123;</span><br><span class="line"></span><br><span class="line">    SUNNY(<span class="string">"晴"</span>), RAINY(<span class="string">"雨"</span>), WINDY(<span class="string">"云"</span>), COLD(<span class="string">"风"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    WeatherType(String description) &#123;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hobbits</span> <span class="keyword">implements</span> <span class="title">WeatherObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(WeatherType currentWeather)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"霍比特人现在面临天气："</span> + currentWeather.getDescription());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orcs</span> <span class="keyword">implements</span> <span class="title">WeatherObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(WeatherType currentWeather)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"兽人现在面临天气："</span> + currentWeather.getDescription());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weather</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WeatherType currentWeather;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;WeatherObserver&gt; observers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Weather</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        currentWeather = WeatherType.SUNNY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(WeatherObserver obs)</span> </span>&#123;</span><br><span class="line">        observers.add(obs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(WeatherObserver obs)</span> </span>&#123;</span><br><span class="line">        observers.remove(obs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟天气随着时间流逝而变化。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timePasses</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WeatherType[] enumValues = WeatherType.values();</span><br><span class="line">        currentWeather = enumValues[(currentWeather.ordinal() + <span class="number">1</span>) % enumValues.length];</span><br><span class="line">        System.out.println(<span class="string">"变天了: "</span> + currentWeather);</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (WeatherObserver obs : observers) &#123;</span><br><span class="line">            obs.update(currentWeather);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="">示例代码</a></p></blockquote><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><img src="/blog/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/observer_demo.png" class=""><img src="/blog/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/observer.png" class=""><p>类图中主要包含以下角色：</p><p>抽象主题角色（<code>Subject</code>）：提供一个用于保存观察者对象的容器，可以增加、删除观察者以及通知所有观察者的方法。<br>具体主题角色（<code>ConcreteSubject</code>）：负责定义它自己的业务逻辑，并在主题内部状态改变时，通知它的所有观察者对象。<br>抽象观察者角色（<code>Observer</code>）：它是一个抽象类或接口，包含一个响应方法用来在订阅主题发生更改时做出对应反应。<br>具体观察者角色（<code>ConcreteObserver</code>）：实现抽象观察者中定义的抽象响应方法，以便在订阅主题发生更改时及时做出自己对应的反应。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;观察者模式&quot;&gt;&lt;a href=&quot;#观察者模式&quot; class=&quot;headerlink&quot; title=&quot;观察者模式&quot;&gt;&lt;/a&gt;观察者模式&lt;/h2&gt;&lt;h3 id=&quot;意图&quot;&gt;&lt;a href=&quot;#意图&quot; class=&quot;headerlink&quot; title=&quot;意图&quot;&gt;&lt;/a&gt;意图&lt;/h3&gt;&lt;p&gt;当一个对象改变状态时，所有依赖它的对象都将自动通知或更新。&lt;/p&gt;
&lt;h3 id=&quot;适用场景&quot;&gt;&lt;a href=&quot;#适用场景&quot; class=&quot;headerlink&quot; title=&quot;适用场景&quot;&gt;&lt;/a&gt;适用场景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;当一个对象的改变的同时需要改变其他对象，同时你又不知道有多少对象需要改变时。&lt;/li&gt;
&lt;li&gt;当一个对象可以通知其他对象而无需假设这些对象是谁时。&lt;/li&gt;
&lt;li&gt;服务注册中心&lt;/li&gt;
&lt;li&gt;图形界面应用程序&lt;/li&gt;
&lt;li&gt;RSS/消息订阅/邮件系统&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="观察者模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="design patterns" scheme="http://xiaojiaC.github.io/blog/tags/design-patterns/"/>
    
      <category term="gof" scheme="http://xiaojiaC.github.io/blog/tags/gof/"/>
    
      <category term="behavioral" scheme="http://xiaojiaC.github.io/blog/tags/behavioral/"/>
    
      <category term="observer" scheme="http://xiaojiaC.github.io/blog/tags/observer/"/>
    
  </entry>
  
  <entry>
    <title>装饰器模式</title>
    <link href="http://xiaojiac.github.io/blog/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F.html"/>
    <id>http://xiaojiac.github.io/blog/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F.html</id>
    <published>2023-10-16T12:43:06.000Z</published>
    <updated>2023-10-18T13:45:27.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>在不改变原有对象的基础上，动态地给一个对象添加一些额外的职责。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>用于扩展一个类的功能，或者给一个类添加附加职责。</li><li>动态地给一个对象添加功能，这些功能可以再被动态地撤销。</li><li>需要为一批平行的类进行改装或加装功能。</li><li>……</li></ul><a id="more"></a><h3 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html" target="_blank" rel="noopener">java.io.InputStream</a> / <a href="http://docs.oracle.com/javase/8/docs/api/java/io/OutputStream.html" target="_blank" rel="noopener">java.io.OutputStream</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/io/Reader.html" target="_blank" rel="noopener">java.io.Reader</a> / <a href="http://docs.oracle.com/javase/8/docs/api/java/io/Writer.html" target="_blank" rel="noopener">java.io.Writer</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#synchronizedCollection-java.util.Collection-" target="_blank" rel="noopener">Collections#synchronizedXXX()</a> / <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableCollection-java.util.Collection-" target="_blank" rel="noopener">Collections#unmodifiableXXX()</a> / <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#checkedCollection-java.util.Collection-java.lang.Class-" target="_blank" rel="noopener">Collections#checkedXXX()</a></li><li><a href="https://commons.apache.org/proper/commons-collections/javadocs/api-4.4/org/apache/commons/collections4/collection/AbstractCollectionDecorator.html" target="_blank" rel="noopener">commons-collections AbstractCollectionDecorator</a> / <a href="https://commons.apache.org/proper/commons-collections/javadocs/api-4.4/org/apache/commons/collections4/map/AbstractMapDecorator.html" target="_blank" rel="noopener">AbstractMapDecorator</a></li><li><a href="https://docs.spring.io/spring-framework/docs/5.3.29/javadoc-api/org/springframework/cache/transaction/TransactionAwareCacheDecorator.html" target="_blank" rel="noopener">Spring TransactionAwareCacheDecorator</a></li><li><a href="https://mybatis.org/mybatis-3/zh/apidocs/org/apache/ibatis/cache/decorators/package-summary.html" target="_blank" rel="noopener">Mybatis cache decorators</a></li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 附近的山丘上住着一个愤怒的巨魔。通常它是徒手战斗，但有时它有武器。</span></span><br><span class="line"><span class="comment"> * 为了武装它不必创建新的巨魔，只需选择合适的武器动态装饰它。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Troll</span> </span>&#123; <span class="comment">// 巨魔</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>; <span class="comment">// 攻击</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAttackPower</span><span class="params">()</span></span>; <span class="comment">// 获得攻击力</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fleeBattle</span><span class="params">()</span></span>; <span class="comment">// 逃离战斗</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleTroll</span> <span class="keyword">implements</span> <span class="title">Troll</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"巨魔试图抓住你！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAttackPower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fleeBattle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"巨魔惊恐地尖叫着逃跑了！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClubbedTroll</span> <span class="keyword">implements</span> <span class="title">Troll</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Troll decorated;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClubbedTroll</span><span class="params">(Troll decorated)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.decorated = decorated;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        decorated.attack();</span><br><span class="line">        System.out.println(<span class="string">"巨魔向你挥舞棍子！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAttackPower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> decorated.getAttackPower() + <span class="number">10</span>; <span class="comment">// 伤害增加</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fleeBattle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        decorated.fleeBattle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="">示例代码</a></p></blockquote><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><img src="/blog/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/decorator_demo.png" class=""><img src="/blog/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/decorator.png" class=""><p>装饰器模式主要包含以下角色：</p><p>抽象构件角色（<code>Component</code>）：定义一个抽象接口以规范准备接收附加职责的对象。<br>具体构件角色（<code>ConcreteComponent</code>）：实现抽象构件，将要通过装饰角色为其添加一些职责。<br>抽象装饰角色（<code>Decorator</code>）：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。<br>具体装饰角色（<code>ConcreteDecorator</code>）：实现抽象装饰的相关方法，并给具体构件对象添加附加的职责。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;装饰器模式&quot;&gt;&lt;a href=&quot;#装饰器模式&quot; class=&quot;headerlink&quot; title=&quot;装饰器模式&quot;&gt;&lt;/a&gt;装饰器模式&lt;/h2&gt;&lt;h3 id=&quot;意图&quot;&gt;&lt;a href=&quot;#意图&quot; class=&quot;headerlink&quot; title=&quot;意图&quot;&gt;&lt;/a&gt;意图&lt;/h3&gt;&lt;p&gt;在不改变原有对象的基础上，动态地给一个对象添加一些额外的职责。&lt;/p&gt;
&lt;h3 id=&quot;适用场景&quot;&gt;&lt;a href=&quot;#适用场景&quot; class=&quot;headerlink&quot; title=&quot;适用场景&quot;&gt;&lt;/a&gt;适用场景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;用于扩展一个类的功能，或者给一个类添加附加职责。&lt;/li&gt;
&lt;li&gt;动态地给一个对象添加功能，这些功能可以再被动态地撤销。&lt;/li&gt;
&lt;li&gt;需要为一批平行的类进行改装或加装功能。&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="装饰器模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="design patterns" scheme="http://xiaojiaC.github.io/blog/tags/design-patterns/"/>
    
      <category term="gof" scheme="http://xiaojiaC.github.io/blog/tags/gof/"/>
    
      <category term="structural" scheme="http://xiaojiaC.github.io/blog/tags/structural/"/>
    
      <category term="decorator" scheme="http://xiaojiaC.github.io/blog/tags/decorator/"/>
    
  </entry>
  
  <entry>
    <title>迭代器模式</title>
    <link href="http://xiaojiac.github.io/blog/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.html"/>
    <id>http://xiaojiac.github.io/blog/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.html</id>
    <published>2023-10-16T12:33:06.000Z</published>
    <updated>2023-10-18T13:45:27.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露该对象的内部表示。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>访问一个聚合对象的内容而无需暴露它的内部表示。</li><li>支持对聚合对象的多种遍历。</li><li>为遍历不同的聚合结构提供一个统一的接口。</li><li>……</li></ul><a id="more"></a><h3 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html" target="_blank" rel="noopener">java.util.Iterator</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html" target="_blank" rel="noopener">java.util.Enumeration</a></li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 百宝箱包含一组魔法物品。有多种物品，例如戒指，药水和武器。可以使用藏宝箱提供的迭代器按类型浏览物品。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreasureChest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Item&gt; items;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreasureChest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        items = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> Item(ItemType.POTION, <span class="string">"Potion of courage"</span>),</span><br><span class="line">                <span class="keyword">new</span> Item(ItemType.RING, <span class="string">"Ring of shadows"</span>),</span><br><span class="line">                <span class="keyword">new</span> Item(ItemType.POTION, <span class="string">"Potion of wisdom"</span>),</span><br><span class="line">                <span class="keyword">new</span> Item(ItemType.POTION, <span class="string">"Potion of blood"</span>),</span><br><span class="line">                <span class="keyword">new</span> Item(ItemType.WEAPON, <span class="string">"Sword of silver"</span>),</span><br><span class="line">                <span class="keyword">new</span> Item(ItemType.POTION, <span class="string">"Potion of rust"</span>),</span><br><span class="line">                <span class="keyword">new</span> Item(ItemType.POTION, <span class="string">"Potion of healing"</span>),</span><br><span class="line">                <span class="keyword">new</span> Item(ItemType.RING, <span class="string">"Ring of armor"</span>),</span><br><span class="line">                <span class="keyword">new</span> Item(ItemType.WEAPON, <span class="string">"Steel halberd"</span>),</span><br><span class="line">                <span class="keyword">new</span> Item(ItemType.WEAPON, <span class="string">"Dagger of poison"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Item&gt; <span class="title">getItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(items);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">(ItemType itemType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreasureChestItemIterator(<span class="keyword">this</span>, itemType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ItemType type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Item</span><span class="params">(ItemType type, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setType(type);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ItemType <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(ItemType type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> ItemType &#123;</span><br><span class="line"></span><br><span class="line">    ANY, WEAPON, RING, POTION</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreasureChestItemIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreasureChest treasureChest;</span><br><span class="line">    <span class="keyword">private</span> ItemType itemType;</span><br><span class="line">    <span class="keyword">private</span> Item[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreasureChestItemIterator</span><span class="params">(TreasureChest treasureChest, ItemType itemType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.treasureChest = treasureChest;</span><br><span class="line">        <span class="keyword">this</span>.itemType = itemType;</span><br><span class="line">        <span class="keyword">this</span>.items = treasureChest.getItems().stream()</span><br><span class="line">                .filter(i -&gt; ItemType.ANY.equals(itemType) || i.getType().equals(itemType))</span><br><span class="line">                .collect(Collectors.toList())</span><br><span class="line">                .toArray(<span class="keyword">new</span> Item[]&#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (items.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cursor &gt;= <span class="number">0</span> &amp;&amp; cursor &lt; items.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= items.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> items[cursor++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="">示例代码</a></p></blockquote><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><img src="/blog/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/iterator_demo.png" class="">]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;迭代器模式&quot;&gt;&lt;a href=&quot;#迭代器模式&quot; class=&quot;headerlink&quot; title=&quot;迭代器模式&quot;&gt;&lt;/a&gt;迭代器模式&lt;/h2&gt;&lt;h3 id=&quot;意图&quot;&gt;&lt;a href=&quot;#意图&quot; class=&quot;headerlink&quot; title=&quot;意图&quot;&gt;&lt;/a&gt;意图&lt;/h3&gt;&lt;p&gt;提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露该对象的内部表示。&lt;/p&gt;
&lt;h3 id=&quot;适用场景&quot;&gt;&lt;a href=&quot;#适用场景&quot; class=&quot;headerlink&quot; title=&quot;适用场景&quot;&gt;&lt;/a&gt;适用场景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;访问一个聚合对象的内容而无需暴露它的内部表示。&lt;/li&gt;
&lt;li&gt;支持对聚合对象的多种遍历。&lt;/li&gt;
&lt;li&gt;为遍历不同的聚合结构提供一个统一的接口。&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="迭代器模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="design patterns" scheme="http://xiaojiaC.github.io/blog/tags/design-patterns/"/>
    
      <category term="gof" scheme="http://xiaojiaC.github.io/blog/tags/gof/"/>
    
      <category term="behavioral" scheme="http://xiaojiaC.github.io/blog/tags/behavioral/"/>
    
      <category term="iterator" scheme="http://xiaojiaC.github.io/blog/tags/iterator/"/>
    
  </entry>
  
  <entry>
    <title>适配器模式</title>
    <link href="http://xiaojiac.github.io/blog/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.html"/>
    <id>http://xiaojiac.github.io/blog/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.html</id>
    <published>2023-10-15T11:53:13.000Z</published>
    <updated>2023-10-18T13:45:27.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>将一个接口转换成另一个客户所期望的接口。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>需要使用一个已有类，但是它的接口不能和你需要的所匹配。</li><li>需要使用一些现有的子类，但是子类化他们每一个的子类来进行接口的适配是不现实的。一个对象适配器可以适配他们父类的接口。</li><li>需要使用适配器作为一个在应用和第三方类库间的中间层来使应用和类库解耦。</li><li>电源适配器</li><li>……</li></ul><a id="more"></a><h3 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h3><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#list-java.util.Enumeration-" target="_blank" rel="noopener">java.util.Collections#list()</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#enumeration-java.util.Collection-" target="_blank" rel="noopener">java.util.Collections#enumeration()</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/adapters/XmlAdapter.html#marshal-BoundType-" target="_blank" rel="noopener">javax.xml.bind.annotation.adapters.XMLAdapter</a></li><li><a href="https://docs.spring.io/spring-framework/docs/5.3.29/javadoc-api/org/springframework/web/servlet/HandlerAdapter.html" target="_blank" rel="noopener">Spring HandlerAdapter</a></li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 充电器将生活中220V交流电适配为5V直流电为手机充电。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voltage220V</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output220V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> src = <span class="number">220</span>;</span><br><span class="line">        System.out.println(String.format(<span class="string">"输出电压: %sV"</span>, src));</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类适配器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageClassAdapter</span> <span class="keyword">extends</span> <span class="title">Voltage220V</span> <span class="keyword">implements</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> srcV = output220V(); <span class="comment">// 源电压</span></span><br><span class="line">        <span class="keyword">int</span> dstV = srcV / <span class="number">44</span> ;  <span class="comment">// 降压适配</span></span><br><span class="line">        <span class="keyword">return</span> dstV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象适配器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageObjectAdapter</span> <span class="keyword">implements</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Voltage220V voltage220V;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VoltageObjectAdapter</span><span class="params">(Voltage220V voltage220V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.voltage220V = voltage220V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> srcV = voltage220V.output220V();</span><br><span class="line">        <span class="keyword">int</span> dstV = srcV / <span class="number">44</span>;</span><br><span class="line">        <span class="keyword">return</span> dstV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charging</span><span class="params">(IVoltage5V iVoltage5V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> output = iVoltage5V.output5V();</span><br><span class="line">        <span class="keyword">if</span>(output == <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"电压为5V, 可以充电~~"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"电压不为5V, 不能充电~~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="">示例代码</a></p></blockquote><h4 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h4><ul><li>适配被适配者到目标接口，需要保证只有一个具体的被适配者类。</li><li>可以让适配器重写一些被适配者的行为，因为适配器是被适配者的子类。</li><li>只引入了一个对象，并且不需要其他指针间接访问被适配者。</li></ul><h4 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h4><ul><li>一个适配器可以和许多被适配者工作，也就是被适配者自己和所有它的子类。适配器同时可以为所有被适配者添加功能。</li><li>覆盖被适配者的行为变得更难。需要子类化被适配者然后让适配器引用这个子类不是被适配者。</li></ul><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><img src="/blog/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/class_adapter.png" class=""><img src="/blog/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/object_adapter.png" class="">]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;适配器模式&quot;&gt;&lt;a href=&quot;#适配器模式&quot; class=&quot;headerlink&quot; title=&quot;适配器模式&quot;&gt;&lt;/a&gt;适配器模式&lt;/h2&gt;&lt;h3 id=&quot;意图&quot;&gt;&lt;a href=&quot;#意图&quot; class=&quot;headerlink&quot; title=&quot;意图&quot;&gt;&lt;/a&gt;意图&lt;/h3&gt;&lt;p&gt;将一个接口转换成另一个客户所期望的接口。&lt;/p&gt;
&lt;h3 id=&quot;适用场景&quot;&gt;&lt;a href=&quot;#适用场景&quot; class=&quot;headerlink&quot; title=&quot;适用场景&quot;&gt;&lt;/a&gt;适用场景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;需要使用一个已有类，但是它的接口不能和你需要的所匹配。&lt;/li&gt;
&lt;li&gt;需要使用一些现有的子类，但是子类化他们每一个的子类来进行接口的适配是不现实的。一个对象适配器可以适配他们父类的接口。&lt;/li&gt;
&lt;li&gt;需要使用适配器作为一个在应用和第三方类库间的中间层来使应用和类库解耦。&lt;/li&gt;
&lt;li&gt;电源适配器&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="适配器模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="design patterns" scheme="http://xiaojiaC.github.io/blog/tags/design-patterns/"/>
    
      <category term="gof" scheme="http://xiaojiaC.github.io/blog/tags/gof/"/>
    
      <category term="structural" scheme="http://xiaojiaC.github.io/blog/tags/structural/"/>
    
      <category term="adapter" scheme="http://xiaojiaC.github.io/blog/tags/adapter/"/>
    
  </entry>
  
  <entry>
    <title>状态模式</title>
    <link href="http://xiaojiac.github.io/blog/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.html"/>
    <id>http://xiaojiac.github.io/blog/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.html</id>
    <published>2023-10-15T11:23:06.000Z</published>
    <updated>2023-10-18T13:45:27.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>允许对象在内部状态改变时改变它的行为，这个对象看起来像是修改了它的类。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>对象的行为取决于它的状态，并且它必须在运行时根据状态更改其行为。</li><li>根据对象状态的不同，操作有大量的条件语句。可用该模式把条件语句的分支分别放入单独的类中。这样你就可以将对象的状态视为独立的对象，该对象可以独立于其他对象而变化。</li><li>……</li></ul><a id="more"></a><h3 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h3><ul><li><a href="https://docs.spring.io/spring-statemachine/docs/3.1.0/reference/#developing-your-first-spring-statemachine-application" target="_blank" rel="noopener">Spring State Machine</a></li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 糖果售卖机，在"投了25分钱"的状态下"转动曲柄"，会售出糖果；而在"没有25分钱"的状态下"转动曲柄"会提示请先投币。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 投币</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">insertQuarter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 退币</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">ejectQuarter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转动出糖曲轴</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">turnCrank</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发糖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">dispense</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 退还硬币</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">returnQuarter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"退币。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoQuarterState</span> <span class="keyword">extends</span> <span class="title">State</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    GumballMachine gumballMachine;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NoQuarterState</span><span class="params">(GumballMachine gumballMachine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertQuarter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"你投入了一个硬币"</span>);</span><br><span class="line">        <span class="comment">// 转换为有硬币状态</span></span><br><span class="line">        gumballMachine.setState(gumballMachine.hasQuarterState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ejectQuarter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"没有硬币，无法弹出"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnCrank</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请先投币"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispense</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"没有投币，无法发放糖果"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HasQuarterState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    GumballMachine gumballMachine;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HasQuarterState</span><span class="params">(GumballMachine gumballMachine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertQuarter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请不要重复投币！"</span>);</span><br><span class="line">        returnQuarter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ejectQuarter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        returnQuarter();</span><br><span class="line">        gumballMachine.setState(gumballMachine.noQuarterState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnCrank</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"转动曲轴，准备发糖"</span>);</span><br><span class="line">        gumballMachine.setState(gumballMachine.soldState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispense</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this method don't support"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoldState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    GumballMachine gumballMachine;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SoldState</span><span class="params">(GumballMachine gumballMachine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertQuarter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"已投币，请等待糖果"</span>);</span><br><span class="line">        returnQuarter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ejectQuarter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"无法退币，正在发放糖果，请等待"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnCrank</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"已按过曲轴，请等待"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispense</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> candyCount = gumballMachine.getCandyCount();</span><br><span class="line">        <span class="keyword">if</span> (candyCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"分发一颗糖果"</span>);</span><br><span class="line">            candyCount--;</span><br><span class="line">            gumballMachine.setCandyCount(candyCount);</span><br><span class="line">            <span class="keyword">if</span> (candyCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                gumballMachine.setState(gumballMachine.noQuarterState);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Oh，糖果已售罄..."</span>);</span><br><span class="line">        gumballMachine.setState(gumballMachine.soldOutState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoldOutState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    GumballMachine gumballMachine;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SoldOutState</span><span class="params">(GumballMachine gumballMachine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertQuarter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"糖果已经售罄"</span>);</span><br><span class="line">        returnQuarter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ejectQuarter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"没有投币，无法退币"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnCrank</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"糖果已经售罄"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispense</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"糖果已经售罄"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GumballMachine</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> State noQuarterState = <span class="keyword">new</span> NoQuarterState(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">public</span> State hasQuarterState = <span class="keyword">new</span> HasQuarterState(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">public</span> State soldState = <span class="keyword">new</span> SoldState(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">public</span> State soldOutState = <span class="keyword">new</span> SoldOutState(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> candyCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> State state = soldOutState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GumballMachine</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.candyCount = count;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            setState(noQuarterState);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertQuarter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.insertQuarter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ejectQuarter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.ejectQuarter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnCrank</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.turnCrank();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispense</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.dispense();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCandyCount</span><span class="params">(<span class="keyword">int</span> candyCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.candyCount = candyCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCandyCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> candyCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="">示例代码</a></p></blockquote><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><img src="/blog/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/state_demo.png" class=""><img src="/blog/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/state.png" class=""><p>类图中主要包含三个核心角色：</p><p>上下文角色（<code>Context</code>）：定义客户端需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。<br>抽象状态角色（<code>State</code>）：定义一个接口，用以封装上下文对象中的特定状态所对应的行为。<br>具体状态角色（<code>ConcreteState</code>）：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;状态模式&quot;&gt;&lt;a href=&quot;#状态模式&quot; class=&quot;headerlink&quot; title=&quot;状态模式&quot;&gt;&lt;/a&gt;状态模式&lt;/h2&gt;&lt;h3 id=&quot;意图&quot;&gt;&lt;a href=&quot;#意图&quot; class=&quot;headerlink&quot; title=&quot;意图&quot;&gt;&lt;/a&gt;意图&lt;/h3&gt;&lt;p&gt;允许对象在内部状态改变时改变它的行为，这个对象看起来像是修改了它的类。&lt;/p&gt;
&lt;h3 id=&quot;适用场景&quot;&gt;&lt;a href=&quot;#适用场景&quot; class=&quot;headerlink&quot; title=&quot;适用场景&quot;&gt;&lt;/a&gt;适用场景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;对象的行为取决于它的状态，并且它必须在运行时根据状态更改其行为。&lt;/li&gt;
&lt;li&gt;根据对象状态的不同，操作有大量的条件语句。可用该模式把条件语句的分支分别放入单独的类中。这样你就可以将对象的状态视为独立的对象，该对象可以独立于其他对象而变化。&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="状态模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="design patterns" scheme="http://xiaojiaC.github.io/blog/tags/design-patterns/"/>
    
      <category term="gof" scheme="http://xiaojiaC.github.io/blog/tags/gof/"/>
    
      <category term="behavioral" scheme="http://xiaojiaC.github.io/blog/tags/behavioral/"/>
    
      <category term="state" scheme="http://xiaojiaC.github.io/blog/tags/state/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="http://xiaojiac.github.io/blog/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html"/>
    <id>http://xiaojiac.github.io/blog/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html</id>
    <published>2023-09-21T14:11:06.000Z</published>
    <updated>2023-10-18T13:45:27.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>定义一个算法族，并将每个算法封装起来，使它们可以互相替换。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>需要在运行时自由选择最匹配的算法</li><li>需要使用一个算法的不同变体</li><li>需要避免暴露复杂的特定于算法的规则</li><li>需要避免多重条件语句嵌套</li><li>排序算法</li><li>……</li></ul><a id="more"></a><h3 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h3><ul><li><a href="https://docs.spring.io/spring-framework/docs/5.3.29/javadoc-api/org/springframework/web/accept/ContentNegotiationStrategy.html" target="_blank" rel="noopener">Spring ContentNegotiationStrategy</a></li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 屠龙是一项危险的职业。有经验将会使它变得简单。经验丰富的屠龙者对不同类型的龙有不同的战斗策略。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DragonSlayingStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MeleeStrategy</span> <span class="keyword">implements</span> <span class="title">DragonSlayingStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用神剑切断这条龙的头部!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProjectileStrategy</span> <span class="keyword">implements</span> <span class="title">DragonSlayingStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"向龙投掷魔法弩!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellStrategy</span> <span class="keyword">implements</span> <span class="title">DragonSlayingStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"念念有词，对龙念咒语中!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DragonSlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DragonSlayingStrategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DragonSlayer</span><span class="params">(DragonSlayingStrategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeStrategy</span><span class="params">(DragonSlayingStrategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goToBattle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        strategy.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="">示例代码</a></p></blockquote><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><img src="/blog/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/strategy_demo.png" class=""><img src="/blog/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/strategy.png" class=""><p>类图中主要包含三个核心角色：</p><p>抽象策略角色（<code>Strategy</code>）：规定策略或算法的行为。<br>具体策略角色（<code>ConcreteStrategy</code>）：具体的策略或算法实现。<br>上下文角色（<code>Context</code>）：用来操作策略的上下文，屏蔽高层模块(客户端)对策略、算法的直接访问，封装可能存在的变化。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;策略模式&quot;&gt;&lt;a href=&quot;#策略模式&quot; class=&quot;headerlink&quot; title=&quot;策略模式&quot;&gt;&lt;/a&gt;策略模式&lt;/h2&gt;&lt;h3 id=&quot;意图&quot;&gt;&lt;a href=&quot;#意图&quot; class=&quot;headerlink&quot; title=&quot;意图&quot;&gt;&lt;/a&gt;意图&lt;/h3&gt;&lt;p&gt;定义一个算法族，并将每个算法封装起来，使它们可以互相替换。&lt;/p&gt;
&lt;h3 id=&quot;适用场景&quot;&gt;&lt;a href=&quot;#适用场景&quot; class=&quot;headerlink&quot; title=&quot;适用场景&quot;&gt;&lt;/a&gt;适用场景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;需要在运行时自由选择最匹配的算法&lt;/li&gt;
&lt;li&gt;需要使用一个算法的不同变体&lt;/li&gt;
&lt;li&gt;需要避免暴露复杂的特定于算法的规则&lt;/li&gt;
&lt;li&gt;需要避免多重条件语句嵌套&lt;/li&gt;
&lt;li&gt;排序算法&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="策略模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="design patterns" scheme="http://xiaojiaC.github.io/blog/tags/design-patterns/"/>
    
      <category term="gof" scheme="http://xiaojiaC.github.io/blog/tags/gof/"/>
    
      <category term="behavioral" scheme="http://xiaojiaC.github.io/blog/tags/behavioral/"/>
    
      <category term="strategy" scheme="http://xiaojiaC.github.io/blog/tags/strategy/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="http://xiaojiac.github.io/blog/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html"/>
    <id>http://xiaojiac.github.io/blog/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html</id>
    <published>2023-09-16T13:11:11.000Z</published>
    <updated>2023-10-18T13:45:27.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>为另一个对象提供代理以控制对其的访问。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>需要在不修改原代码的基础上，扩展和增强实现</li><li>需要隐藏部分实现过程和细节，对象的访问控制</li><li>事务代理</li><li>非侵入式日志监听</li><li>……</li></ul><a id="more"></a><h3 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h3><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Proxy.html" target="_blank" rel="noopener">java.lang.reflect.Proxy</a></li><li><a href="https://cglib.sourceforge.net/apidocs/net/sf/cglib/proxy/Enhancer.html" target="_blank" rel="noopener">cglib dynamic proxy</a></li><li><a href="https://commons.apache.org/proper/commons-proxy/" target="_blank" rel="noopener">apache commons proxy</a></li><li><a href="https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html" target="_blank" rel="noopener">mockito</a>以及<a href="https://easymock.org/user-guide.html" target="_blank" rel="noopener">easymock</a>、<a href="https://powermock.github.io/" target="_blank" rel="noopener">powermock</a>等 mock 框架</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 想象有一个塔，当地的巫师去那里学习他们的法术。通过代理象牙塔进入功能，以此来保证只有前3个巫师才能进入。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WizardTower</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enter</span><span class="params">(Wizard wizard)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IvoryTower</span> <span class="keyword">implements</span> <span class="title">WizardTower</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enter</span><span class="params">(Wizard wizard)</span> </span>&#123;</span><br><span class="line">        System.out.println(wizard + <span class="string">" enters the tower."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WizardTowerProxy</span> <span class="keyword">implements</span> <span class="title">WizardTower</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_WIZARDS_ALLOWED = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numWizards;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WizardTower tower;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WizardTowerProxy</span><span class="params">(WizardTower tower)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tower = tower;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enter</span><span class="params">(Wizard wizard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numWizards &lt; NUM_WIZARDS_ALLOWED) &#123;</span><br><span class="line">            tower.enter(wizard);</span><br><span class="line">            numWizards++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(wizard + <span class="string">" is not allowed to enter!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="">示例代码</a></p></blockquote><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>手动生成并维护代理类的源码，控制被代理对象的访问。</p><p><strong>缺点</strong>：</p><ul><li>静态代理在委托类变多的情况时会显的非常臃肿，不方便阅读与使用；</li><li>接口类变化会影响委托类和代理类：比如方法修改返回值、参数类型、增加方法，实现类和代理类都需要修改，不够灵活。</li></ul><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>使用反射和字节码的技术，在运行期创建指定接口的实现或类的子类及其实例对象，控制被代理对象的访问。</p><ul><li>jdk 代理</li></ul><ol><li>定义一个接口和接口的实现类</li><li>创建一个代理类实现<code>InvocationHandler</code>接口（指定运行时生成代理类需要完成的具体任务）</li><li>重写<code>InvocationHandler</code>接口中的<code>invoke</code>方法</li><li>创建被代理类的对象，通过代理类对象来调用相应方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WizardTowerInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_WIZARDS_ALLOWED = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numWizards;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WizardTower tower;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WizardTowerInvocationHandler</span><span class="params">(WizardTower tower)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tower = tower;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numWizards &lt; NUM_WIZARDS_ALLOWED) &#123;</span><br><span class="line">            Object result = method.invoke(tower, args);</span><br><span class="line">            numWizards++;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Wizard wizard = (Wizard) args[<span class="number">0</span>];</span><br><span class="line">            System.out.println(wizard + <span class="string">" is not allowed to enter!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InvocationHandler invocationHandler = <span class="keyword">new</span> WizardTowerInvocationHandler(<span class="keyword">new</span> IvoryTower());</span><br><span class="line">        WizardTower tower = (WizardTower) Proxy.newProxyInstance(WizardTower<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">                new Class[]&#123;WizardTower.class&#125;, invocationHandler);</span><br><span class="line">        tower.enter(<span class="keyword">new</span> Wizard(<span class="string">"Red wizard"</span>));</span><br><span class="line">        tower.enter(<span class="keyword">new</span> Wizard(<span class="string">"White wizard"</span>));</span><br><span class="line">        tower.enter(<span class="keyword">new</span> Wizard(<span class="string">"Black wizard"</span>));</span><br><span class="line">        tower.enter(<span class="keyword">new</span> Wizard(<span class="string">"Green wizard"</span>));</span><br><span class="line">        tower.enter(<span class="keyword">new</span> Wizard(<span class="string">"Brown wizard"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>cglib 代理</li></ul><ol><li>定义一个接口和接口的实现类</li><li>创建一个代理类实现<code>MethodInterceptor</code>接口（指定运行时生成代理类需要完成的具体任务）</li><li>重写<code>MethodInterceptor</code>接口中的<code>intercept</code>方法<ul><li>可以通过<code>CallbackFilter</code>来过滤要重写的方法</li></ul></li><li>创建被代理类的对象，通过代理类对象来调用相应方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WizardTowerMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_WIZARDS_ALLOWED = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numWizards;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WizardTowerMethodInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numWizards &lt; NUM_WIZARDS_ALLOWED) &#123;</span><br><span class="line">            Object result = methodProxy.invokeSuper(obj, args);</span><br><span class="line">            numWizards++;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Wizard wizard = (Wizard) args[<span class="number">0</span>];</span><br><span class="line">            System.out.println(wizard + <span class="string">" is not allowed to enter!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(IvoryTower<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> WizardTowerMethodInterceptor()); <span class="comment">// 会拦截IvoryTower中的所有方法</span></span><br><span class="line">        IvoryTower tower = (IvoryTower) enhancer.create();</span><br><span class="line">        tower.enter(<span class="keyword">new</span> Wizard(<span class="string">"Red wizard"</span>));</span><br><span class="line">        tower.enter(<span class="keyword">new</span> Wizard(<span class="string">"White wizard"</span>));</span><br><span class="line">        tower.enter(<span class="keyword">new</span> Wizard(<span class="string">"Black wizard"</span>));</span><br><span class="line">        tower.enter(<span class="keyword">new</span> Wizard(<span class="string">"Green wizard"</span>));</span><br><span class="line">        tower.enter(<span class="keyword">new</span> Wizard(<span class="string">"Brown wizard"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><img src="/blog/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/proxy_demo.png" class=""><img src="/blog/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/proxy.png" class=""><p>类图中主要包含三个核心角色：</p><p>抽象对象角色（<code>AbstractObject</code>）：声明了目标对象和代理对象的共同接口，这样依赖在任何可以使用目标对象的地方都可以使用代理对象。<br>目标对象角色（<code>RealObject</code>）：定义了代理对象所代表的目标对象。<br>代理对象角色（<code>ProxyObject</code>）：代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或者之后执行某个操作，而不是单纯的将调用传递给目标对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h2&gt;&lt;h3 id=&quot;意图&quot;&gt;&lt;a href=&quot;#意图&quot; class=&quot;headerlink&quot; title=&quot;意图&quot;&gt;&lt;/a&gt;意图&lt;/h3&gt;&lt;p&gt;为另一个对象提供代理以控制对其的访问。&lt;/p&gt;
&lt;h3 id=&quot;适用场景&quot;&gt;&lt;a href=&quot;#适用场景&quot; class=&quot;headerlink&quot; title=&quot;适用场景&quot;&gt;&lt;/a&gt;适用场景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;需要在不修改原代码的基础上，扩展和增强实现&lt;/li&gt;
&lt;li&gt;需要隐藏部分实现过程和细节，对象的访问控制&lt;/li&gt;
&lt;li&gt;事务代理&lt;/li&gt;
&lt;li&gt;非侵入式日志监听&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="代理模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="design patterns" scheme="http://xiaojiaC.github.io/blog/tags/design-patterns/"/>
    
      <category term="gof" scheme="http://xiaojiaC.github.io/blog/tags/gof/"/>
    
      <category term="structural" scheme="http://xiaojiaC.github.io/blog/tags/structural/"/>
    
      <category term="proxy" scheme="http://xiaojiaC.github.io/blog/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>享元模式</title>
    <link href="http://xiaojiac.github.io/blog/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.html"/>
    <id>http://xiaojiac.github.io/blog/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.html</id>
    <published>2023-09-03T14:00:32.000Z</published>
    <updated>2023-10-18T13:45:27.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>使用共享有效地支持大量细粒度对象的复用。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>需要与相似对象尽可能共享来最大限度地减少内存使用或计算消耗</li><li>……</li></ul><a id="more"></a><h3 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h3><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#valueOf-int-" target="_blank" rel="noopener">java.lang.Integer#valueOf(int)</a> 以及<code>Byte</code>、<code>Boolean</code>、<code>Short</code>, <code>Character</code>、<code>Long</code>等包装类型</li><li>棋牌游戏中的<code>棋</code>和<code>牌</code></li><li>字符串常量池</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         1. 默认缓存范围为 [-128, 127]</span></span><br><span class="line"><span class="comment">         2. 缓存最大值可由 -XX:AutoBoxCacheMax=N jvm参数调整</span></span><br><span class="line"><span class="comment">         3. 缓存最大值可由 -Djava.lang.Integer.IntegerCache.high=N system属性调整</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/openjdk/jdk/blob/9a9add8825a040565051a09010b29b099c2e7d49/jdk/src/share/classes/java/lang/Integer.java#L780" target="_blank" rel="noopener">demo</a></p></blockquote><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><img src="/blog/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/flyweight.png" class=""><p>类图中主要包含四个核心角色：</p><ul><li>抽象的享元角色（<code>FlyWeight</code>）：它是产品的抽象类，同时定义出对象的内部状态（不会随着环境的改变而改变的可共享部分）和外部状态（随环境改变而改变的不可以共享的部分）。</li><li>具体的享元角色（<code>ConcreteFlyWeight</code>）：是具体的产品类，实现抽象角色定义的相关业务。</li><li>不可共享角色（<code>UnsharedConcreteFlyWeight</code>）：不能被共享的子类可设计成不可共享角色。</li><li>享元工厂类（<code>FlyweightFactory</code>）：负责创建和管理享元角色，当使用者创建享元对象时，会由享元工厂先从工厂中获取，若存在则对外提供，不存在则由工厂创建。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;享元模式&quot;&gt;&lt;a href=&quot;#享元模式&quot; class=&quot;headerlink&quot; title=&quot;享元模式&quot;&gt;&lt;/a&gt;享元模式&lt;/h2&gt;&lt;h3 id=&quot;意图&quot;&gt;&lt;a href=&quot;#意图&quot; class=&quot;headerlink&quot; title=&quot;意图&quot;&gt;&lt;/a&gt;意图&lt;/h3&gt;&lt;p&gt;使用共享有效地支持大量细粒度对象的复用。&lt;/p&gt;
&lt;h3 id=&quot;适用场景&quot;&gt;&lt;a href=&quot;#适用场景&quot; class=&quot;headerlink&quot; title=&quot;适用场景&quot;&gt;&lt;/a&gt;适用场景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;需要与相似对象尽可能共享来最大限度地减少内存使用或计算消耗&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="享元模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="design patterns" scheme="http://xiaojiaC.github.io/blog/tags/design-patterns/"/>
    
      <category term="gof" scheme="http://xiaojiaC.github.io/blog/tags/gof/"/>
    
      <category term="structural" scheme="http://xiaojiaC.github.io/blog/tags/structural/"/>
    
      <category term="flyweight" scheme="http://xiaojiaC.github.io/blog/tags/flyweight/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="http://xiaojiac.github.io/blog/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html"/>
    <id>http://xiaojiac.github.io/blog/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</id>
    <published>2023-09-03T14:00:32.000Z</published>
    <updated>2023-10-18T13:45:27.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><ul><li>简单工厂模式（Simple Factory）：<span class="label primary">生产一种产品</span><br>在工厂类中提供一个封装的静态工厂方法，用于隐藏对象初始化细节，使客户端代码专注于使用，而不必关心对象构造过程。</li><li>工厂方法模式（Factory Method）：<span class="label primary">生产一种产品，让类把实例化推迟到子类</span><br>为创建某种对象定义一个接口，让子类决定实例化哪个类。工厂方法允许类将实例化延迟到子类。</li><li>抽象工厂模式（Abstract Factory）：<span class="label primary">生产一族产品</span><br>提供一个用于创建相关对象家族的接口，而无需指定其具体类。</li></ul><a id="more"></a><h3 id="释义"><a href="#释义" class="headerlink" title="释义"></a>释义</h3><p>工厂模式将创建对象的具体过程屏蔽隔离起来，从而达到更高的灵活性，工厂模式可以分为三类：</p><ul><li>简单工厂模式<br>客户需要什么品牌的车，调统一的工厂，工厂直接<em>按品牌创建</em>对应的汽车。</li><li>工厂方法模式<br>客户需要什么品牌的车，调相应的品牌工厂，由<em>品牌工厂创建</em>对应的汽车。</li><li>抽象工厂模式<br>客户需要什么品牌的车及其配件，调相应的品牌工厂，由品牌工厂<em>创建对应的汽车及其配件</em>。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>需要只关心对象的创建，但不关心如何创建、管理它的时候</li><li>需要依赖具体环境创建不同实例，这些实例都有相同的行为</li><li>……</li></ul><h3 id="典型案例"><a href="#典型案例" class="headerlink" title="典型案例"></a>典型案例</h3><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html#getInstance--" target="_blank" rel="noopener">java.util.Calendar#getInstance()</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/text/NumberFormat.html#getInstance--" target="_blank" rel="noopener">java.text.NumberFormat#getInstance()</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/EnumSet.html#of(E)" target="_blank" rel="noopener">java.util.EnumSet#of()</a></li><li><a href="https://www.slf4j.org/apidocs/org/slf4j/LoggerFactory.html#getLogger-java.lang.Class-" target="_blank" rel="noopener">org.slf4j.LoggerFactory#getLogger(java.lang.Class&lt;?&gt;)</a></li><li><a href="https://docs.spring.io/spring-framework/docs/5.3.29/javadoc-api/org/springframework/beans/factory/FactoryBean.html" target="_blank" rel="noopener">Spring FactoryBean</a></li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarsSimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getCar</span><span class="params">(CarType type)</span> </span>&#123;</span><br><span class="line">        Car car = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> FORD:</span><br><span class="line">                car = <span class="keyword">new</span> Ford();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FERRARI:</span><br><span class="line">                car = <span class="keyword">new</span> Ferrari();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：不符合“开闭原则”，每次添加新产品就需要修改工厂类。</p><h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarsFactoryMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Car <span class="title">getCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FerrariCarsFactory</span> <span class="keyword">implements</span> <span class="title">CarsFactoryMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Ferrari();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FordCarsFactory</span> <span class="keyword">implements</span> <span class="title">CarsFactoryMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Ford();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarsAbstractFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Car <span class="title">createCar</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Accessory <span class="title">createAccessory</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FerrariCarsFactory</span> <span class="keyword">implements</span> <span class="title">CarsAbstractFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Ferrari();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Accessory <span class="title">createAccessory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FerrariAccessory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FordCarsFactory</span> <span class="keyword">implements</span> <span class="title">CarsAbstractFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Ford();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Accessory <span class="title">createAccessory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FordAccessory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="">demo</a></p></blockquote><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><img src="/blog/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/factory.png" class=""><img src="/blog/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/abstract_factory.png" class="">]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h2&gt;&lt;h3 id=&quot;意图&quot;&gt;&lt;a href=&quot;#意图&quot; class=&quot;headerlink&quot; title=&quot;意图&quot;&gt;&lt;/a&gt;意图&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;简单工厂模式（Simple Factory）：&lt;span class=&quot;label primary&quot;&gt;生产一种产品&lt;/span&gt;&lt;br&gt;在工厂类中提供一个封装的静态工厂方法，用于隐藏对象初始化细节，使客户端代码专注于使用，而不必关心对象构造过程。&lt;/li&gt;
&lt;li&gt;工厂方法模式（Factory Method）：&lt;span class=&quot;label primary&quot;&gt;生产一种产品，让类把实例化推迟到子类&lt;/span&gt;&lt;br&gt;为创建某种对象定义一个接口，让子类决定实例化哪个类。工厂方法允许类将实例化延迟到子类。&lt;/li&gt;
&lt;li&gt;抽象工厂模式（Abstract Factory）：&lt;span class=&quot;label primary&quot;&gt;生产一族产品&lt;/span&gt;&lt;br&gt;提供一个用于创建相关对象家族的接口，而无需指定其具体类。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="工厂模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="design patterns" scheme="http://xiaojiaC.github.io/blog/tags/design-patterns/"/>
    
      <category term="creational" scheme="http://xiaojiaC.github.io/blog/tags/creational/"/>
    
      <category term="factory" scheme="http://xiaojiaC.github.io/blog/tags/factory/"/>
    
  </entry>
  
  <entry>
    <title>建造者模式</title>
    <link href="http://xiaojiac.github.io/blog/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.html"/>
    <id>http://xiaojiac.github.io/blog/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.html</id>
    <published>2023-09-03T13:01:32.000Z</published>
    <updated>2023-10-18T13:45:27.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>将复杂对象的构造与其表示分开，以便同一构造过程可以创建不同的表示。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>需要创建不同表示的同一类对象同时避免构造器污染</li><li>需要规避多个构造器重载</li><li>需要规避单个构造器参数数量较多，多个参数的排列方式（构造函数签名）可能变得难以理解</li><li>……</li></ul><a id="more"></a><h3 id="典型案例"><a href="#典型案例" class="headerlink" title="典型案例"></a>典型案例</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" target="_blank" rel="noopener">java.lang.StringBuilder</a></li><li><a href="http://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html#put-byte-" target="_blank" rel="noopener">java.nio.ByteBuffer</a></li><li><a href="https://projectlombok.org/features/Builder" target="_blank" rel="noopener">Lombok @Builder</a></li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer role;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; tags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造器，引导用户通过builder方法创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Account</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = builder.id;</span><br><span class="line">        <span class="keyword">this</span>.name = builder.name;</span><br><span class="line">        <span class="keyword">this</span>.role = builder.role;</span><br><span class="line">        <span class="keyword">this</span>.email = builder.email;</span><br><span class="line">        <span class="keyword">this</span>.tags = builder.tags;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">builder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Account.Builder(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Integer role;</span><br><span class="line">        <span class="keyword">private</span> String email;</span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; tags;</span><br><span class="line"></span><br><span class="line">        Builder(String name) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"name can not be null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.id = UUID.randomUUID().toString();</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">role</span><span class="params">(Integer role)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.role = role;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">email</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.email = email;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">addTag</span><span class="params">(String tag)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.tags == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.tags = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.tags.add(tag);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Account <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Account(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="">demo</a></p></blockquote><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><img src="/blog/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/builder.png" class="">]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;建造者模式&quot;&gt;&lt;a href=&quot;#建造者模式&quot; class=&quot;headerlink&quot; title=&quot;建造者模式&quot;&gt;&lt;/a&gt;建造者模式&lt;/h2&gt;&lt;h3 id=&quot;意图&quot;&gt;&lt;a href=&quot;#意图&quot; class=&quot;headerlink&quot; title=&quot;意图&quot;&gt;&lt;/a&gt;意图&lt;/h3&gt;&lt;p&gt;将复杂对象的构造与其表示分开，以便同一构造过程可以创建不同的表示。&lt;/p&gt;
&lt;h3 id=&quot;适用场景&quot;&gt;&lt;a href=&quot;#适用场景&quot; class=&quot;headerlink&quot; title=&quot;适用场景&quot;&gt;&lt;/a&gt;适用场景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;需要创建不同表示的同一类对象同时避免构造器污染&lt;/li&gt;
&lt;li&gt;需要规避多个构造器重载&lt;/li&gt;
&lt;li&gt;需要规避单个构造器参数数量较多，多个参数的排列方式（构造函数签名）可能变得难以理解&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="建造者模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="design patterns" scheme="http://xiaojiaC.github.io/blog/tags/design-patterns/"/>
    
      <category term="gof" scheme="http://xiaojiaC.github.io/blog/tags/gof/"/>
    
      <category term="creational" scheme="http://xiaojiaC.github.io/blog/tags/creational/"/>
    
      <category term="builder" scheme="http://xiaojiaC.github.io/blog/tags/builder/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://xiaojiac.github.io/blog/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html"/>
    <id>http://xiaojiac.github.io/blog/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</id>
    <published>2023-09-03T12:00:32.000Z</published>
    <updated>2023-10-18T13:45:27.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>保证一个类只有一个实例，并且为它提供一个全局访问点。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>线程池、连接池</li><li>缓存管理器</li><li>日志记录器</li><li>文件管理器</li><li>……</li></ul><a id="more"></a><h3 id="典型案例"><a href="#典型案例" class="headerlink" title="典型案例"></a>典型案例</h3><ul><li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#getRuntime%28%29" target="_blank" rel="noopener">java.lang.Runtime#getRuntime()</a></li><li><a href="https://docs.spring.io/spring-framework/docs/5.3.29/javadoc-api/org/springframework/beans/factory/config/ConfigurableBeanFactory.html#SCOPE_SINGLETON" target="_blank" rel="noopener">Spring ConfigurableBeanFactory#SCOPE_SINGLETON</a></li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类装载时就完成了初始化，jvm保证线程安全问题。若从始至终没有使用实例，会造成内存浪费。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton INSTANCE = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可被反射破坏单例性！！！</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现Serializable的类需要添加该方法，防止反序列化实例时创建新的实例。（下同）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    volatile修饰，禁止jvm指令重排序（即禁止重排21,24）：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    getInstance() 方法部分字节码：</span></span><br><span class="line"><span class="comment">    10 monitorenter</span></span><br><span class="line"><span class="comment">    11 getstatic #2 &lt;com/jd/study/designpattern/singleton/LazySingleton.instance&gt;</span></span><br><span class="line"><span class="comment">    14 ifnonnull 27 (+13)</span></span><br><span class="line"><span class="comment">    17 new #3 &lt;com/jd/study/designpattern/singleton/LazySingleton&gt;</span></span><br><span class="line"><span class="comment">    20 dup</span></span><br><span class="line"><span class="comment">    21 invokespecial #4 &lt;com/jd/study/designpattern/singleton/LazySingleton.&lt;init&gt;&gt;</span></span><br><span class="line"><span class="comment">    24 putstatic #2 &lt;com/jd/study/designpattern/singleton/LazySingleton.instance&gt;</span></span><br><span class="line"><span class="comment">    27 aload_0</span></span><br><span class="line"><span class="comment">    28 monitorexit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 双重检查为了不必要的加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态内部类单例"><a href="#静态内部类单例" class="headerlink" title="静态内部类单例"></a>静态内部类单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可被反射破坏单例性！！！</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先类加载时，内部类不会马上被加载，所以不会事先占用内存空间，其次在初始化内部类的过程中，jvm会保证同一时刻只有一个线程运行。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticInnerClassSingleton INSTANCE = <span class="keyword">new</span> StaticInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举类单例"><a href="#枚举类单例" class="headerlink" title="枚举类单例"></a>枚举类单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleton &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    通过javap -v EnumSingleton.class可以看到HOLDER其实是static final类型的，由jvm保证线程安全问题：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public static final com.xxx.designpattern.singleton.EnumSingleton HOLDER;</span></span><br><span class="line"><span class="comment">        descriptor: Lcom/xxx/designpattern/singleton/EnumSingleton;</span></span><br><span class="line"><span class="comment">        flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL, ACC_ENUM</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HOLDER(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enum 类不允许反射构造，调用报错：java.lang.IllegalArgumentException: Cannot reflectively create enum objects。</span></span><br><span class="line">    EnumSingleton(<span class="keyword">int</span> code) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>java.lang.Enum</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enum 类不允许克隆。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CloneNotSupportedException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enum 类不允许反序列化。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"can't deserialize enum"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObjectNoData</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"can't deserialize enum"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="">demo</a></p></blockquote><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><img src="/blog/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/singleton.png" class="">]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h2&gt;&lt;h3 id=&quot;意图&quot;&gt;&lt;a href=&quot;#意图&quot; class=&quot;headerlink&quot; title=&quot;意图&quot;&gt;&lt;/a&gt;意图&lt;/h3&gt;&lt;p&gt;保证一个类只有一个实例，并且为它提供一个全局访问点。&lt;/p&gt;
&lt;h3 id=&quot;适用场景&quot;&gt;&lt;a href=&quot;#适用场景&quot; class=&quot;headerlink&quot; title=&quot;适用场景&quot;&gt;&lt;/a&gt;适用场景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;线程池、连接池&lt;/li&gt;
&lt;li&gt;缓存管理器&lt;/li&gt;
&lt;li&gt;日志记录器&lt;/li&gt;
&lt;li&gt;文件管理器&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单例模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="design patterns" scheme="http://xiaojiaC.github.io/blog/tags/design-patterns/"/>
    
      <category term="gof" scheme="http://xiaojiaC.github.io/blog/tags/gof/"/>
    
      <category term="creational" scheme="http://xiaojiaC.github.io/blog/tags/creational/"/>
    
      <category term="singleton" scheme="http://xiaojiaC.github.io/blog/tags/singleton/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://xiaojiac.github.io/blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"/>
    <id>http://xiaojiac.github.io/blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</id>
    <published>2023-09-03T11:00:01.000Z</published>
    <updated>2023-10-18T13:45:27.130Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <p>意图降低对象之间的耦合，增加程序的可复用性、可扩展性、可靠性和可维护性。</p>          </blockquote><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><table><thead><tr><th>设计原则</th><th>含义</th><th>目的</th></tr></thead><tbody><tr><td>开闭原则</td><td>对扩展开放，对修改关闭</td><td>降低维护带来的新风险</td></tr><tr><td>单一职责原则</td><td>一个类应该只有一个引起变化的原因</td><td>便于理解，提高代码的可读性</td></tr><tr><td>接口隔离原则</td><td>一个接口只干一件事，接口要精简单一</td><td>功能解耦，高聚合低耦合</td></tr><tr><td>依赖倒置原则</td><td>高层不应该依赖低层；抽象不应该依赖细节，细节应该依赖抽象；要面向接口编程</td><td>利于代码结构的升级扩展</td></tr><tr><td>最少知识法则</td><td>不该知道的不要知道，一个类应该保持对其它对象最少的了解</td><td>只和你的密友说话，降低耦合度</td></tr><tr><td>里氏替换原则</td><td>不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义</td><td>防止继承泛滥</td></tr><tr><td>组合复用原则</td><td>尽量使用组合或者聚合关系实现代码复用，少使用继承</td><td>降低代码耦合</td></tr></tbody></table><a id="more"></a><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li>单例：确保某一个类只有一个实例存在。</li><li>工厂方法：创建单个产品实例。</li><li>抽象工厂：创建一族产品实例。</li><li>建造者：允许创建不同口味的对象以避免构造器污染。</li><li>原型：通过复制现有的实例来创建新的实例，无需知道相应类的信息。</li><li>抽象文档：为对象添加类型安全的动态属性。</li><li>享元：用共享技术来有效地支持大量细粒度对象的复用。</li><li>代理：代理某个对象的行为和方法，添加自定义功能。</li><li>活动对象：有自己的控制机制线程，封装对象方法的执行仅公开其 API，使方法调用与方法执行脱钩。</li><li>组合：可以使客户统一对待单个对象和组合对象。</li><li>访问者：允许将功能添加到现有的类层次结构中，而无需修改层次结构。</li><li>非循环访问者：同访问者，但没有循环依赖的问题（被访问者依赖访问者基类，访问者依赖被访问者所有子类）。</li><li>适配器：将一个接口转换成另一个客户所期望的接口。</li><li>桥接：将抽象与其实现分离，从而使两个层次结构可以独立变化。</li><li>回调：传递给调用者的方法，它将在定义的时刻被调用。</li><li>命令：对请求进行封装，将命令的发出和命令的执行解耦开。</li><li>装饰器：装饰对象动态为其添加额外行为。</li><li>门面：为一个子系统中的一系列接口提供一个简单统一的接口。</li><li>迭代器：不暴露容器内部表示的一种顺序访问元素的方式。</li><li>观察者：一个对象的改变导致所有依赖它的对象都将自动通知或更新。</li><li>策略：在运行时选择最匹配的算法。</li><li>模板方法：定义算法骨架，将某些步骤推迟到子类实现。</li><li>状态：允许对象在内部状态改变时改变它的行为。（与策略模式类图相似，区别在于：策略模式会控制对象使用什么策略，而状态模式会自动改变对象状态流转。）</li><li>责任链：串联接收对象并在链条中传递请求直到一个对象处理它。</li></ul><h3 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h3><ul><li><code>o--</code>: 聚合，整体与局部关系，局部可以脱离整体存在，具有各自的生命周期。表示 has-a（实例变量），例如公司与员工 <code>Company o-- Employee</code></li><li><code>*--</code>: 组合，整体与局部关系，局部不可以脱离整体存在，其生命周期应该是一致的。表示 contain-a（实例变量），例如大脑与人类 <code>Person \*-- Brain</code></li><li><code>--|&gt;</code>: 继承，箭头从子类指向父类。表示 is-a（extends），例如柴犬与狗 <code>ShibaInu --|&gt; Dog</code></li><li><code>..|&gt;</code>: 实现，箭头从实现类指向接口。表示 is-a（implement），例如狗与动物 <code>Dog ..|&gt; Animal</code></li><li><code>..&gt;</code>: 依赖，箭头从使用类指向被依赖的类。表示 一个类调用被依赖类中的某些方法而得以完成这个类的一些职责。（局部变量，方法中的参数和对静态方法的调用）</li><li><code>--&gt;</code>/<code>&quot;+attr1&quot;--&gt;&quot;-attr2&quot;</code>: 单向关联，箭头从使用类指向被关联的类，可注明关联的属性。例如：<code>A --&gt; B</code>，表示 B 类作为 A 类的属性。（实例变量）</li><li><code>--</code>/<code>&quot;1&quot;--&quot;N&quot;</code>: 双向关联，箭头从使用类指向被关联的类，可注明 1 对多、或多对一。例如：<code>A &quot;1&quot;--&quot;N&quot; B</code>，表示 B 类作为 A 类的属性同时，A 类也是 B 类的属性。（实例变量）</li></ul><blockquote><p><a href="https://plantuml.com/zh/class-diagram" target="_blank" rel="noopener">plantuml class diagram</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;p&gt;意图降低对象之间的耦合，增加程序的可复用性、可扩展性、可靠性和可维护性。&lt;/p&gt;

          &lt;/blockquote&gt;

&lt;h3 id=&quot;设计原则&quot;&gt;&lt;a href=&quot;#设计原则&quot; class=&quot;headerlink&quot; title=&quot;设计原则&quot;&gt;&lt;/a&gt;设计原则&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;设计原则&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;目的&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;开闭原则&lt;/td&gt;
&lt;td&gt;对扩展开放，对修改关闭&lt;/td&gt;
&lt;td&gt;降低维护带来的新风险&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;单一职责原则&lt;/td&gt;
&lt;td&gt;一个类应该只有一个引起变化的原因&lt;/td&gt;
&lt;td&gt;便于理解，提高代码的可读性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;接口隔离原则&lt;/td&gt;
&lt;td&gt;一个接口只干一件事，接口要精简单一&lt;/td&gt;
&lt;td&gt;功能解耦，高聚合低耦合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;依赖倒置原则&lt;/td&gt;
&lt;td&gt;高层不应该依赖低层；抽象不应该依赖细节，细节应该依赖抽象；要面向接口编程&lt;/td&gt;
&lt;td&gt;利于代码结构的升级扩展&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;最少知识法则&lt;/td&gt;
&lt;td&gt;不该知道的不要知道，一个类应该保持对其它对象最少的了解&lt;/td&gt;
&lt;td&gt;只和你的密友说话，降低耦合度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;里氏替换原则&lt;/td&gt;
&lt;td&gt;不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义&lt;/td&gt;
&lt;td&gt;防止继承泛滥&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;组合复用原则&lt;/td&gt;
&lt;td&gt;尽量使用组合或者聚合关系实现代码复用，少使用继承&lt;/td&gt;
&lt;td&gt;降低代码耦合&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://xiaojiaC.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="design patterns" scheme="http://xiaojiaC.github.io/blog/tags/design-patterns/"/>
    
  </entry>
  
  <entry>
    <title>spring mvc文件上传为何突然失败？</title>
    <link href="http://xiaojiac.github.io/blog/spring%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%A4%B1%E8%B4%A5.html"/>
    <id>http://xiaojiac.github.io/blog/spring%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%A4%B1%E8%B4%A5.html</id>
    <published>2023-08-26T14:00:32.000Z</published>
    <updated>2023-10-18T13:45:27.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>生产素材上传正常运行已有一段时间，突然某天运营告知素材文件无法上传，奇怪的是最近一直无此块代码相关变更，于是乎就这样走进“幽灵探索”之路…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">DEBUG 29208 -- [http-nio-8080-exec-4] DispatcherServlet : POST &quot;&#x2F;cmsapi&#x2F;material&#x2F;upload&quot;, parameters&#x3D;&#123;masked&#125;</span><br><span class="line">DEBUG 29208 -- [http-nio-8080-exec-4] PropertySourcedRequestMappingHandlerMapping : looking up handler for path: &#x2F;cmsapi&#x2F;material&#x2F;upload</span><br><span class="line">DEBUG 29208 -- [http-nio-8080-exec-4] RequestMappingHandlerMapping : Mapped to com.xxx.cms.controller.MaterialController#uploadMaterials(UploadMaterialsRequest)</span><br><span class="line">DEBUG 29208 -- [http-nio-8080-exec-4] ServletInvocableHandlerMethod : Could not resolve parameter [0] in public com.xxx.cms.vo.Response&lt;com.xxx.cms.vo.ObjectResult&lt;com.xxx.cms.service.common.oss.OssFileDto&gt;&gt; com.xxx.cms.controller.MaterialController.uploadMaterials(com.xxx.cms.request.UploadMaterialsRequest): org.springframework.validation.BeanPropertyBindingResult: 1 errors</span><br><span class="line">Field error in object &#39;uploadMaterialsRequest&#39; on field &#39;file&#39;: rejected value [null]; codes [NotNull.uploadMaterialsRequest.file,NotNull.file,NotNull.org.springframework.web.multipart.MultipartFile,NotNull]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [uploadMaterialsRequest.file,file]; arguments []; default message [file]]; default message [material.file.null]</span><br><span class="line">DEBUG 29208 -- [http-nio-8080-exec-4] ExceptionHandlerExceptionResolver : Using @ExceptionHandler com.xxx.cms.advice.ApiExceptionAdvice#handleBindException(BindException)</span><br><span class="line">INFO 29208 -- [http-nio-8080-exec-4] ApiExceptionAdvice : org.springframework.validation.BeanPropertyBindingResult: 1 errors</span><br><span class="line">Field error in object &#39;uploadMaterialsRequest&#39; on field &#39;file&#39;: rejected value [null]; codes [NotNull.uploadMaterialsRequest.file,NotNull.file,NotNull.org.springframework.web.multipart.MultipartFile,NotNull]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [uploadMaterialsRequest.file,file]; arguments []; default message [file]]; default message [material.file.null]</span><br><span class="line">org.springframework.validation.BindException: org.springframework.validation.BeanPropertyBindingResult: 1 errors</span><br><span class="line">Field error in object &#39;uploadMaterialsRequest&#39; on field &#39;file&#39;: rejected value [null]; codes [NotNull.uploadMaterialsRequest.file,NotNull.file,NotNull.org.springframework.web.multipart.MultipartFile,NotNull]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [uploadMaterialsRequest.file,file]; arguments []; default message [file]]; default message [material.file.null]</span><br><span class="line">at org.springframework.web.method.annotation.ModelAttributeMethodProcessor.resolveArgument(ModelAttributeMethodProcessor.java:164) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE]</span><br><span class="line">at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:121) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE]</span><br><span class="line">at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:167) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE]</span><br><span class="line">at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:134) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE]</span><br><span class="line">at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE]</span><br><span class="line">at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:888) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE]</span><br><span class="line">at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE]</span><br><span class="line">at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE]</span><br><span class="line">at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE]</span><br><span class="line">at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE]</span><br><span class="line">at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE]</span><br><span class="line">at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE]</span><br><span class="line">at javax.servlet.http.HttpServlet.service(HttpServlet.java:660) [tomcat-embed-core-9.0.30.jar:9.0.30]</span><br><span class="line">at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE]</span><br><span class="line">at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) [tomcat-embed-core-9.0.30.jar:9.0.30]</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) [tomcat-embed-core-9.0.30.jar:9.0.30]</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.30.jar:9.0.30]</span><br><span class="line">at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) [spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE]</span><br><span class="line">at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE]</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.30.jar:9.0.30]</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.30.jar:9.0.30]</span><br><span class="line">at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) [spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE]</span><br><span class="line">at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE]</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.30.jar:9.0.30]</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.30.jar:9.0.30]</span><br><span class="line">at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) [spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE]</span><br><span class="line">at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE]</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.30.jar:9.0.30]</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.30.jar:9.0.30]</span><br><span class="line">at org.springframework.web.filter.CorsFilter.doFilterInternal(CorsFilter.java:92) [spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE]</span><br><span class="line">at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE]</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.30.jar:9.0.30]</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.30.jar:9.0.30]</span><br><span class="line">at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) [tomcat-embed-core-9.0.30.jar:9.0.30]</span><br><span class="line">at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.30.jar:9.0.30]</span><br><span class="line">at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.30.jar:9.0.30]</span><br><span class="line">at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.30.jar:9.0.30]</span><br><span class="line">at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.30.jar:9.0.30]</span><br><span class="line">at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.30.jar:9.0.30]</span><br><span class="line">at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.30.jar:9.0.30]</span><br><span class="line">at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:367) [tomcat-embed-core-9.0.30.jar:9.0.30]</span><br><span class="line">at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.30.jar:9.0.30]</span><br><span class="line">at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:860) [tomcat-embed-core-9.0.30.jar:9.0.30]</span><br><span class="line">at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1598) [tomcat-embed-core-9.0.30.jar:9.0.30]</span><br><span class="line">at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.30.jar:9.0.30]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [?:1.8.0_65]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [?:1.8.0_65]</span><br><span class="line">at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.30.jar:9.0.30]</span><br><span class="line">at java.lang.Thread.run(Thread.java:745) [?:1.8.0_65]</span><br><span class="line">DEBUG 29208 -- [http-nio-8080-exec-4] RequestResponseBodyMethodProcessor : Using &#39;application&#x2F;json&#39;, given [application&#x2F;json] and supported [application&#x2F;json, application&#x2F;*+json, application&#x2F;json, application&#x2F;*+json, application&#x2F;cbor]</span><br><span class="line">DEBUG 29208 -- [http-nio-8080-exec-4] RequestResponseBodyMethodProcessor : Writing [Response(code&#x3D;400, msg&#x3D;无效请求, data&#x3D;null, errors&#x3D;[com.xxx.cms.vo.FieldDefaultVo@7c382733])]</span><br><span class="line">DEBUG 29208 -- [http-nio-8080-exec-4] ExceptionHandlerExceptionResolver : Resolved [org.springframework.validation.BindException: org.springframework.validation.BeanPropertyBindingResult: 1 errors</span><br><span class="line">Field error in object &#39;uploadMaterialsRequest&#39; on field &#39;file&#39;: rejected value [null]; codes [NotNull.uploadMaterialsRequest.file,NotNull.file,NotNull.org.springframework.web.multipart.MultipartFile,NotNull]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [uploadMaterialsRequest.file,file]; arguments []; default message [file]]; default message [material.file.null]]</span><br><span class="line">DEBUG 29208 -- [http-nio-8080-exec-4] DispatcherServlet : Completed 200 OK</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java: 8</span><br><span class="line">spring-boot-starter-web: 2.2.4.RELEASE</span><br><span class="line">spring-boot-starter-log4j2: 2.2.4.RELEASE</span><br></pre></td></tr></table></figure><h3 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(value = <span class="string">"material/upload"</span>, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span><br><span class="line"><span class="keyword">public</span> Response&lt;ObjectResult&lt;OssFileDto&gt;&gt; upload(<span class="meta">@Valid</span> UploadMaterialsRequest request) &#123;</span><br><span class="line">    OssFileDto ossFile = materialService.bulkUpload(request);</span><br><span class="line">    <span class="keyword">return</span> Response.success(ObjectResult.of(ossFile, f -&gt; &#123;</span><br><span class="line">        fileRepository.setOssFileToken(request.getType(), f.getFileToken());</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadMaterialsRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"material.type.null"</span>)</span><br><span class="line">    <span class="meta">@EnumValue</span>(type = MaterialTypeEnum<span class="class">.<span class="keyword">class</span>, <span class="title">message</span> </span>= <span class="string">"material.type.illegal"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer type;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"material.file.null"</span>)</span><br><span class="line">    <span class="keyword">private</span> MultipartFile file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排查之路"><a href="#排查之路" class="headerlink" title="排查之路"></a>排查之路</h3><p>首先咨询同事，发现最近上线了一个新特性，但不涉及素材功能相关代码改动，搜索错误日志发现生产<span class="label primary">竟然</span>开启了<code>DEBUG</code>，有相关错误记录，发现 <span class="label danger">Field error in object uploadMaterialsRequest on field file: rejected value [null];</span>目前无法获取到上传的文件，但具体为何突然取不到？<br>尝试预发环境测试发现功能正常，想看下日志现场于是将日志级别调为<code>DEBUG</code>，发现问题复现了。猜测可能是<strong>动态日志级别修改导致</strong>，将线上<code>DEBUG</code>关闭后测试发现恢复，那为何日志级别会影响到文件读取呢？</p><h4 id="关键调用栈"><a href="#关键调用栈" class="headerlink" title="关键调用栈"></a>关键调用栈</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">parseRequest:<span class="number">276</span>, FileUploadBase (org.apache.tomcat.util.http.fileupload)</span><br><span class="line">parseParts:<span class="number">2867</span>, Request (org.apache.catalina.connector)  <span class="comment">// 解析MultipartFile</span></span><br><span class="line">parseParameters:<span class="number">3195</span>, Request (org.apache.catalina.connector)</span><br><span class="line">getParameterNames:<span class="number">1159</span>, Request (org.apache.catalina.connector)</span><br><span class="line">getParameterMap:<span class="number">1138</span>, Request (org.apache.catalina.connector)</span><br><span class="line">getParameterMap:<span class="number">443</span>, RequestFacade (org.apache.catalina.connector)</span><br><span class="line">lambda$logRequest$<span class="number">2</span>:<span class="number">964</span>, DispatcherServlet (org.springframework.web.servlet)</span><br><span class="line">apply:-<span class="number">1</span>, <span class="number">146803671</span> (org.springframework.web.servlet.DispatcherServlet$$Lambda$<span class="number">867</span>)</span><br><span class="line">traceDebug:<span class="number">86</span>, LogFormatUtils (org.springframework.core.log)</span><br><span class="line">logRequest:<span class="number">956</span>, DispatcherServlet (org.springframework.web.servlet) <span class="comment">// 打印请求日志</span></span><br><span class="line">doService:<span class="number">911</span>, DispatcherServlet (org.springframework.web.servlet)</span><br><span class="line">processRequest:<span class="number">1006</span>, FrameworkServlet (org.springframework.web.servlet)</span><br><span class="line">doPost:<span class="number">909</span>, FrameworkServlet (org.springframework.web.servlet)</span><br><span class="line">service:<span class="number">660</span>, HttpServlet (javax.servlet.http)</span><br></pre></td></tr></table></figure><h4 id="关键代码段"><a href="#关键代码段" class="headerlink" title="关键代码段"></a>关键代码段</h4><figure class="highlight java"><figcaption><span>org.apache.catalina.connector.Request</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseParts</span><span class="params">(<span class="keyword">boolean</span> explicit)</span> </span>&#123; <span class="comment">// explicit为false</span></span><br><span class="line">    <span class="keyword">if</span> (parts != <span class="keyword">null</span> || partsParseException != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Context context = getContext();</span><br><span class="line">    MultipartConfigElement mce = getWrapper().getMultipartConfigElement();</span><br><span class="line">    <span class="keyword">if</span> (mce == <span class="keyword">null</span>) &#123; <span class="comment">// 可以看到这里如果返回null，会跳过后续解析parts</span></span><br><span class="line">        <span class="keyword">if</span>(context.getAllowCasualMultipartParsing()) &#123;</span><br><span class="line">            mce = <span class="keyword">new</span> MultipartConfigElement(<span class="keyword">null</span>, connector.getMaxPostSize(),</span><br><span class="line">                    connector.getMaxPostSize(), connector.getMaxPostSize());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (explicit) &#123;</span><br><span class="line">                partsParseException = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        sm.getString(<span class="string">"coyoteRequest.noMultipartConfig"</span>));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parts = Collections.emptyList();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析parts 略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察以上调用栈，可以看到如果开启<code>DEBUG</code>模式，spring mvc 会解析请求参数打印请求日志，file 文件流此时已被提前解析读取一次，导致后续参数绑定时再次读取失败。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>关闭<code>DispatcherServlet</code>的<code>DEBUG</code>模式（但生产有时会利用<code>ROOT=DEBUG</code>排查其他问题）</li><li>让<code>StandardWrapper#getMultipartConfigElement()</code>返回<code>null</code>跳过解析（最终采用）</li></ol><img src="/blog/spring%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%A4%B1%E8%B4%A5/MultipartAutoConfig.PNG" class="" title="SpringBoot Multipart自动配置"><p>从上图可以看出默认 springboot 自动配置了 <code>spring.servlet.multipart.enabled=true</code>，默认启用<code>StandardServletMultipartResolver</code>，会初始化<code>MultipartConfigElement</code>；因此我们可以自定义<code>CommonsMultipartResolver</code>替换默认的解析器，并关闭<code>spring.servlet.multipart.enabled</code>即可实现方案 2。</p><figure class="highlight xml"><figcaption><span>pom.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><figcaption><span>application.properties</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.servlet.multipart.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>WebConfig.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MultipartResolver <span class="title">multipartResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CommonsMultipartResolver resolver = <span class="keyword">new</span> CommonsMultipartResolver();</span><br><span class="line">        resolver.setDefaultEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">        resolver.setMaxUploadSize(<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>); <span class="comment">// 10M</span></span><br><span class="line">        <span class="keyword">return</span> resolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题现象&quot;&gt;&lt;a href=&quot;#问题现象&quot; class=&quot;headerlink&quot; title=&quot;问题现象&quot;&gt;&lt;/a&gt;问题现象&lt;/h2&gt;&lt;p&gt;生产素材上传正常运行已有一段时间，突然某天运营告知素材文件无法上传，奇怪的是最近一直无此块代码相关变更，于是乎就这样走进“幽灵探索”之路…&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DEBUG 29208 -- [http-nio-8080-exec-4] DispatcherServlet : POST &amp;quot;&amp;#x2F;cmsapi&amp;#x2F;material&amp;#x2F;upload&amp;quot;, parameters&amp;#x3D;&amp;#123;masked&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DEBUG 29208 -- [http-nio-8080-exec-4] PropertySourcedRequestMappingHandlerMapping : looking up handler for path: &amp;#x2F;cmsapi&amp;#x2F;material&amp;#x2F;upload&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DEBUG 29208 -- [http-nio-8080-exec-4] RequestMappingHandlerMapping : Mapped to com.xxx.cms.controller.MaterialController#uploadMaterials(UploadMaterialsRequest)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DEBUG 29208 -- [http-nio-8080-exec-4] ServletInvocableHandlerMethod : Could not resolve parameter [0] in public com.xxx.cms.vo.Response&amp;lt;com.xxx.cms.vo.ObjectResult&amp;lt;com.xxx.cms.service.common.oss.OssFileDto&amp;gt;&amp;gt; com.xxx.cms.controller.MaterialController.uploadMaterials(com.xxx.cms.request.UploadMaterialsRequest): org.springframework.validation.BeanPropertyBindingResult: 1 errors&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Field error in object &amp;#39;uploadMaterialsRequest&amp;#39; on field &amp;#39;file&amp;#39;: rejected value [null]; codes [NotNull.uploadMaterialsRequest.file,NotNull.file,NotNull.org.springframework.web.multipart.MultipartFile,NotNull]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [uploadMaterialsRequest.file,file]; arguments []; default message [file]]; default message [material.file.null]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DEBUG 29208 -- [http-nio-8080-exec-4] ExceptionHandlerExceptionResolver : Using @ExceptionHandler com.xxx.cms.advice.ApiExceptionAdvice#handleBindException(BindException)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;INFO 29208 -- [http-nio-8080-exec-4] ApiExceptionAdvice : org.springframework.validation.BeanPropertyBindingResult: 1 errors&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Field error in object &amp;#39;uploadMaterialsRequest&amp;#39; on field &amp;#39;file&amp;#39;: rejected value [null]; codes [NotNull.uploadMaterialsRequest.file,NotNull.file,NotNull.org.springframework.web.multipart.MultipartFile,NotNull]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [uploadMaterialsRequest.file,file]; arguments []; default message [file]]; default message [material.file.null]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.springframework.validation.BindException: org.springframework.validation.BeanPropertyBindingResult: 1 errors&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Field error in object &amp;#39;uploadMaterialsRequest&amp;#39; on field &amp;#39;file&amp;#39;: rejected value [null]; codes [NotNull.uploadMaterialsRequest.file,NotNull.file,NotNull.org.springframework.web.multipart.MultipartFile,NotNull]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [uploadMaterialsRequest.file,file]; arguments []; default message [file]]; default message [material.file.null]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.springframework.web.method.annotation.ModelAttributeMethodProcessor.resolveArgument(ModelAttributeMethodProcessor.java:164) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:121) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:167) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:134) ~[spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:888) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at javax.servlet.http.HttpServlet.service(HttpServlet.java:660) [tomcat-embed-core-9.0.30.jar:9.0.30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [spring-webmvc-5.2.3.RELEASE.jar:5.2.3.RELEASE]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) [tomcat-embed-core-9.0.30.jar:9.0.30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) [tomcat-embed-core-9.0.30.jar:9.0.30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.30.jar:9.0.30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) [spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.30.jar:9.0.30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.30.jar:9.0.30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) [spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.30.jar:9.0.30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.30.jar:9.0.30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) [spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.30.jar:9.0.30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.30.jar:9.0.30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.springframework.web.filter.CorsFilter.doFilterInternal(CorsFilter.java:92) [spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.3.RELEASE.jar:5.2.3.RELEASE]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.30.jar:9.0.30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.30.jar:9.0.30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) [tomcat-embed-core-9.0.30.jar:9.0.30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.30.jar:9.0.30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.30.jar:9.0.30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.30.jar:9.0.30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.30.jar:9.0.30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.30.jar:9.0.30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.30.jar:9.0.30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:367) [tomcat-embed-core-9.0.30.jar:9.0.30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.30.jar:9.0.30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:860) [tomcat-embed-core-9.0.30.jar:9.0.30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1598) [tomcat-embed-core-9.0.30.jar:9.0.30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.30.jar:9.0.30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [?:1.8.0_65]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [?:1.8.0_65]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.30.jar:9.0.30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at java.lang.Thread.run(Thread.java:745) [?:1.8.0_65]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DEBUG 29208 -- [http-nio-8080-exec-4] RequestResponseBodyMethodProcessor : Using &amp;#39;application&amp;#x2F;json&amp;#39;, given [application&amp;#x2F;json] and supported [application&amp;#x2F;json, application&amp;#x2F;*+json, application&amp;#x2F;json, application&amp;#x2F;*+json, application&amp;#x2F;cbor]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DEBUG 29208 -- [http-nio-8080-exec-4] RequestResponseBodyMethodProcessor : Writing [Response(code&amp;#x3D;400, msg&amp;#x3D;无效请求, data&amp;#x3D;null, errors&amp;#x3D;[com.xxx.cms.vo.FieldDefaultVo@7c382733])]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DEBUG 29208 -- [http-nio-8080-exec-4] ExceptionHandlerExceptionResolver : Resolved [org.springframework.validation.BindException: org.springframework.validation.BeanPropertyBindingResult: 1 errors&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Field error in object &amp;#39;uploadMaterialsRequest&amp;#39; on field &amp;#39;file&amp;#39;: rejected value [null]; codes [NotNull.uploadMaterialsRequest.file,NotNull.file,NotNull.org.springframework.web.multipart.MultipartFile,NotNull]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [uploadMaterialsRequest.file,file]; arguments []; default message [file]]; default message [material.file.null]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DEBUG 29208 -- [http-nio-8080-exec-4] DispatcherServlet : Completed 200 OK&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="http://xiaojiaC.github.io/blog/categories/JAVA/"/>
    
      <category term="漏洞记事" scheme="http://xiaojiaC.github.io/blog/categories/JAVA/%E6%BC%8F%E6%B4%9E%E8%AE%B0%E4%BA%8B/"/>
    
    
      <category term="java" scheme="http://xiaojiaC.github.io/blog/tags/java/"/>
    
      <category term="spring mvc" scheme="http://xiaojiaC.github.io/blog/tags/spring-mvc/"/>
    
  </entry>
  
  <entry>
    <title>java垃圾回收器</title>
    <link href="http://xiaojiac.github.io/blog/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.html"/>
    <id>http://xiaojiac.github.io/blog/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.html</id>
    <published>2020-07-22T09:35:09.000Z</published>
    <updated>2023-10-18T13:45:27.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CMS收集器的工作过程"><a href="#CMS收集器的工作过程" class="headerlink" title="CMS收集器的工作过程"></a><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html" target="_blank" rel="noopener">CMS</a>收集器的工作过程</h2><ol><li><span class="label danger">初始标记</span>：仅仅只是标记一下GC Roots能直接关联到的对象，需要暂停应用程序线程，该阶段完成后，应用程序线程再次启动。</li><li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li><li>并发预清理：改变当运行第二阶段时，由应用程序线程运行引用关系改变导致没有标记到的存活对象，以更新第二阶段的结果。<a id="more"></a></li><li><span class="label danger">重新标记</span>：由于第三阶段是并发的，对象引用可能会发生进一步改变。因此，应用程序线程会再一次被暂停以更新这些变化，并且在进行实际的清理之前确保一个正确的对象引用视图。这一阶段十分重要，因为必须避免收集到仍被引用的对象。</li><li>并发清理：清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</li><li>并发重置：收集器做一些收尾的工作，以便下一次GC周期能有一个干净的状态。</li></ol><h2 id="G1收集器的工作过程"><a href="#G1收集器的工作过程" class="headerlink" title="G1收集器的工作过程"></a><a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html" target="_blank" rel="noopener">G1</a>收集器的工作过程</h2><blockquote><p>young gc(并行独占，Eden区用尽时触发) -&gt; young gc + concurrent mark(并发，堆内存占用率达到阈值时触发) -&gt; mixed gc(并行，标记完成时触发) -&gt; [full gc(独占，晋升失败/回收前堆区耗尽时触发)]</p></blockquote><h3 id="的工作过程："><a href="#的工作过程：" class="headerlink" title="的工作过程："></a><span class="label danger">年轻代GC</span>的工作过程：</h3><ol><li>根扫描：扫描根引用和记忆集记录的外部引用（老年代到新生代的对象引用）；</li><li>更新记忆集：排空<strong>赃卡队列</strong>（Dirty Card Queue），更新<strong>记忆集</strong>（Remember Set），该阶段完成后可以准确反映老年代到新生代的对象引用；</li><li>处理记忆集：扫描并标记被老年代对象指向的Eden/Survivor中的对象；</li><li>复制对象：遍历对象树，复制扫描出的存活对象到Survivor/Old区；</li><li>处理引用队列：软引用，弱引用，虚引用，Final引用。</li></ol><h3 id="并发标记的工作过程："><a href="#并发标记的工作过程：" class="headerlink" title="并发标记的工作过程："></a>并发标记的工作过程：</h3><ol><li><span class="label danger">初始标记</span>（Initial Marking）：标记GC Roots能直接关联到的对象，并且修改**TAMS**指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行新生代GC时同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</li><li>根区域扫描（Root Region Scanning）：扫描并标记Survivor区直接可达的老年代区域对象；这一过程必须在下一次新生代GC之前完成；</li><li>并发标记（Concurrent Marking）：对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行，可以被一次新生代GC打断。当对象图扫描完成以后，还要重新处理<strong>SATB</strong>记录下的在并发时有引用变动的对象。</li><li><span class="label danger">重新标记</span>（Remark）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。</li><li><span class="label danger">独占清理</span>（Cleanup）：计算各个Region存活对象和GC回收价值比例，并进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成**回收集**（Collection Set）。</li><li><span class="label danger">复制</span>（Copying）：把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。该阶段可能会发生在新生代Regions记录为`[GC pause (young)]`，也可能会同时发生在新生代和老年代Regions记录为`[GC Pause (mixed)]`。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</li></ol><h2 id="Shenandoah收集器的工作过程"><a href="#Shenandoah收集器的工作过程" class="headerlink" title="Shenandoah收集器的工作过程"></a><a href="https://wiki.openjdk.java.net/display/shenandoah/Main" target="_blank" rel="noopener">Shenandoah</a>收集器的工作过程</h2><ol><li><span class="label danger">初始标记</span>（Initial Marking）：与G1一样，首先标记与GC Roots直接关联的对象，这个阶段仍是“Stop The World”的，但停顿时间与堆大小无关，只与GC Roots的数量相关。</li><li>并发标记（Concurrent Marking）：与G1一样，遍历对象图，标记出全部可达的对象，这个阶段是与用户线程一起并发的，时间长短取决于堆中存活对象的数量以及对象图的结构复杂程度。</li><li><span class="label danger">最终标记</span>（Final Marking）：与G1一样，处理剩余的SATB扫描，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组回收集（Collection Set）。最终标记阶段也会有一小段短暂的停顿。</li><li>并发清理（Concurrent Cleanup）：这个阶段用于清理那些整个区域内连一个存活对象都没有找到的Region（这类Region被称为Immediate Garbage Region）。</li><li>并发回收（Concurrent Evacuation）：并发回收阶段是Shenandoah与之前HotSpot中其他收集器的核心差异。在这个阶段，Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region之中。复制对象这件事情如果将用户线程冻结起来再做那是相当简单的，但如果两者必须要同时并发进行的话，就变得复杂起来了。其困难点是在移动对象的同时，用户线程仍然可能不停对被移动的对象进行读写访问，移动对象是一次性的行为，但移动之后整个内存中所有指向该对象的引用都还是旧对象的地址，这是很难一瞬间全部改变过来的。对于并发回收阶段遇到的这些困难，Shenandoah将会通过<strong>读屏障</strong>和被称为“Brooks Pointers”的<strong>转发指针</strong>来解决。并发回收阶段运行的时间长短取决于为该周期选择的回收集的大小。</li><li><span class="label danger">初始引用更新</span>（Initial Update Reference）：并发回收阶段复制对象结束后，还需要把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新。引用更新的初始化阶段实际上并未做什么具体的处理，设立这个阶段只是为了建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务而已。初始引用更新时间很短，会产生一个非常短暂的停顿。</li><li>并发引用更新（Concurrent Update Reference）：真正开始进行引用更新操作，这个阶段是与用户线程一起并发的，时间长短取决于内存中涉及的引用数量的多少。并发引用更新与并发标记不同，它不再需要沿着对象图来搜索，只需要按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值即可。</li><li><span class="label danger">最终引用更新</span>（Final Update Reference）：解决了堆中的引用更新后，还要修正存在于GCRoots中的引用。这个阶段是Shenandoah的最后一次停顿，停顿时间只与GC Roots的数量相关。</li><li>并发清理（Concurrent Cleanup）：经过并发回收和引用更新之后，整个回收集中所有的Region已再无存活对象，这些Region都变成Immediate Garbage Regions了，最后再调用一次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用。</li></ol><h2 id="ZGC收集器的工作过程"><a href="#ZGC收集器的工作过程" class="headerlink" title="ZGC收集器的工作过程"></a><a href="https://wiki.openjdk.java.net/display/zgc" target="_blank" rel="noopener">ZGC</a>收集器的工作过程</h2><ol><li>并发标记（Concurrent Mark）：与G1、Shenandoah一样，并发标记是遍历对象图做可达性分析的阶段，前后也要经过类似于G1、Shenandoah的初始标记、最终标记的短暂停顿，而且这些停顿阶段所做的事情在目标上也是相类似的。与G1、Shenandoah不同的是，ZGC的标记是在指针上而不是在对象上进行的，标记阶段会更新染色指针中的<code>Marked 0</code>、<code>Marked 1</code>标志位。</li><li>并发预备重分配（Concurrent Prepare for Relocate）：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成<strong>重分配集</strong>（Relocation Set）。重分配集与G1收集器的回收集（Collection Set）还是有区别的，ZGC划分Region的目的并非为了像G1那样做收益优先的增量回收。相反，ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本。因此，ZGC的重分配集只是决定了里面的存活对象会被重新复制到其他的Region中，里面的Region会被释放，而并不能说回收行为就只是针对这个集合里面的Region进行，因为标记过程是针对全堆的。此外，在JDK 12的ZGC中开始支持的类卸载以及弱引用的处理，也是在这个阶段中完成的。</li><li>并发重分配（Concurrent Relocate）：重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个<strong>转发表</strong>（Forward Table），记录从旧对象到新对象的转向关系。得益于<strong>染色指针</strong>的支持，ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（Self-Healing）能力。这样做的好处是只有第一次访问旧对象会陷入转发，也就是只慢一次，对比Shenandoah的Brooks转发指针，那是每次对象访问都必须付出的固定开销，简单地说就是每次都慢，因此ZGC对用户程序的运行时负载要比Shenandoah来得更低一些。还有另外一个直接的好处是由于染色指针的存在，一旦重分配集中某个Region的存活对象都复制完毕后，这个Region就可以立即释放用于新对象的分配（但是转发表还得留着不能释放掉），哪怕堆中还有很多指向这个对象的未更新指针也没有关系，这些旧指针一旦被使用，它们都是可以自愈的。</li><li>并发重映射（Concurrent Remap）：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，这一点从目标角度看是与Shenandoah并发引用更新阶段一样的，但是ZGC的并发重映射并不是一个必须要“迫切”去完成的任务，因为前面说过，即使是旧引用，它也是可以自愈的，最多只是第一次使用时多一次转发和修正操作。重映射清理这些旧引用的主要目的是为了不变慢（还有清理结束后可以释放转发表这样的附带收益），所以说这并不是很“迫切”。因此，ZGC很巧妙地把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图[插图]的开销。一旦所有指针都被修正之后，原来记录新旧对象关系的转发表就可以释放掉了。</li></ol><hr><ul><li><em>《深入理解Java虚拟机》</em></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CMS收集器的工作过程&quot;&gt;&lt;a href=&quot;#CMS收集器的工作过程&quot; class=&quot;headerlink&quot; title=&quot;CMS收集器的工作过程&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMS&lt;/a&gt;收集器的工作过程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;span class=&quot;label danger&quot;&gt;初始标记&lt;/span&gt;：仅仅只是标记一下GC Roots能直接关联到的对象，需要暂停应用程序线程，该阶段完成后，应用程序线程再次启动。&lt;/li&gt;
&lt;li&gt;并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。&lt;/li&gt;
&lt;li&gt;并发预清理：改变当运行第二阶段时，由应用程序线程运行引用关系改变导致没有标记到的存活对象，以更新第二阶段的结果。
    
    </summary>
    
    
      <category term="JAVA" scheme="http://xiaojiaC.github.io/blog/categories/JAVA/"/>
    
      <category term="读书笔记" scheme="http://xiaojiaC.github.io/blog/categories/JAVA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://xiaojiaC.github.io/blog/tags/java/"/>
    
      <category term="gc" scheme="http://xiaojiaC.github.io/blog/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop集群搭建</title>
    <link href="http://xiaojiac.github.io/blog/Hadoop%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA.html"/>
    <id>http://xiaojiac.github.io/blog/Hadoop%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA.html</id>
    <published>2020-05-28T06:15:05.000Z</published>
    <updated>2023-10-18T13:45:27.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hadoop集群搭建"><a href="#Hadoop集群搭建" class="headerlink" title="Hadoop集群搭建"></a>Hadoop集群搭建</h2><h3 id="虚拟机准备"><a href="#虚拟机准备" class="headerlink" title="虚拟机准备"></a>虚拟机准备</h3><ol><li>安装<a href="https://download.virtualbox.org/virtualbox/6.1.8/VirtualBox-6.1.8-137981-Win.exe" target="_blank" rel="noopener">Visual Box</a></li><li>准备<a href="http://isoredirect.centos.org/centos/7/isos/x86_64/" target="_blank" rel="noopener">CentOS 7镜像文件</a></li><li><a href="https://jingyan.baidu.com/article/4dc4084868a1e4c8d946f133.html" target="_blank" rel="noopener">创建虚拟机</a></li><li><a href="https://www.linuxidc.com/Linux/2018-04/151924.htm" target="_blank" rel="noopener">设置虚拟机固定IP</a></li></ol><a id="more"></a><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-enp0s3</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------</span></span><br><span class="line">BOOTPROTO=<span class="string">"static"</span></span><br><span class="line">IPADDR=<span class="string">"192.168.56.101"</span></span><br></pre></td></tr></table></figure></code></pre><ol start="5"><li><p>设置虚拟机主机名</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/network</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------</span></span><br><span class="line">NETWORKING=yes</span><br><span class="line">HOSTNAME=linux101</span><br></pre></td></tr></table></figure></li><li><p>设置虚拟机域名映射</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------</span></span><br><span class="line">192.168.56.101 linux101</span><br></pre></td></tr></table></figure></li><li><p>复制虚拟机：设置名称，选择为所有网卡重新生成MAC地址，完全复制</p></li><li><p>按上述1~6配置准备linux102、linux103虚拟机</p></li><li><p>配置Windows本机域名映射</p><blockquote><p>便于之后访问集群Web UI</p></blockquote> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">code C:\Windows\System32\drivers\etc\hosts</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------</span></span><br><span class="line">192.168.56.101 linux101</span><br><span class="line">192.168.56.102 linux102</span><br><span class="line">192.168.56.103 linux103</span><br></pre></td></tr></table></figure></li></ol><h3 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h3><ol><li><p>创建hadoop用户</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd -m hadoop -s /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>修改hadoop用户密码</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd hadoop</span><br></pre></td></tr></table></figure></li><li><p>设置hadoop用户组</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -a -G hadoop hadoop</span><br></pre></td></tr></table></figure></li><li><p>为hadoop用户增加管理员权限</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vim sudoers</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------</span></span><br><span class="line">hadoop ALL=(ALL) ALL</span><br></pre></td></tr></table></figure></li><li><p>设置机器免密登录</p><blockquote><p>便于在集群间执行管理脚本</p></blockquote> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -P <span class="string">''</span> -f ~/.ssh/id_rsa <span class="comment"># 生成rsa密钥</span></span><br><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys <span class="comment"># 加入授权</span></span><br><span class="line">chmod 0600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh hadoop@linux101 <span class="comment"># 测试免密登录</span></span><br></pre></td></tr></table></figure><p> 仍需要密码登陆问题解决:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------</span></span><br><span class="line">PermitRootLogin yes <span class="comment"># 禁用root账户登录</span></span><br><span class="line"></span><br><span class="line">StrictModes no <span class="comment"># 是否让sshd去检查用户家目录或相关档案的权限数据</span></span><br><span class="line"></span><br><span class="line">PubkeyAuthentication yes <span class="comment"># 是否允许用户自行使用成对的密钥系统进行登入行为</span></span><br><span class="line">AuthorizedKeysFile  .ssh/authorized_keys</span><br><span class="line"><span class="comment"># ----------</span></span><br><span class="line"></span><br><span class="line">service sshd restart <span class="comment"># 重启sshd服务</span></span><br></pre></td></tr></table></figure></li><li><p>关闭防火墙</p><blockquote><p>为了访问集群Web UI和集群各结点互联互通（eg: NameNode和DataNode, …）</p></blockquote> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service   <span class="comment"># 停止防火墙</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service  <span class="comment"># 禁止防火墙开机启动</span></span><br></pre></td></tr></table></figure></li><li><p>下载<a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html" target="_blank" rel="noopener">jdk8</a>并解压</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zvxf jdk-8u251-linux-x64.tar.gz -C ~/module</span><br></pre></td></tr></table></figure></li><li><p>配置环境变量</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意：这里由于虚拟机资源紧张我暂不使用hadoop用户</span></span><br><span class="line">sudo vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------</span></span><br><span class="line"><span class="comment"># JAVA</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/home/bob/module/jdk1.8.0_251</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line"><span class="comment"># ----------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></li><li><p>准备辅助脚本</p><ul><li><p>集群多节点互传差异文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取输入参数个数，如果没有参数直接退出</span></span><br><span class="line">args_count=<span class="variable">$#</span></span><br><span class="line"><span class="keyword">if</span> ((args_count==0)); <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> no args;</span><br><span class="line">  <span class="built_in">exit</span>;</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取待分发文件名称</span></span><br><span class="line">arg1=<span class="variable">$1</span></span><br><span class="line">fname=`basename <span class="variable">$arg1</span>`</span><br><span class="line"><span class="built_in">echo</span> fname=<span class="variable">$fname</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取上级目录到绝对路径</span></span><br><span class="line">pdir=`<span class="built_in">cd</span> -P $(dirname <span class="variable">$arg1</span>); <span class="built_in">pwd</span>`</span><br><span class="line"><span class="built_in">echo</span> pdir=<span class="variable">$pdir</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前用户名称</span></span><br><span class="line">user=`whoami`</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始分发</span></span><br><span class="line"><span class="keyword">for</span> ((host=101; host&lt;104; host++)); <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> --------------------linux<span class="variable">$host</span>--------------------</span><br><span class="line">  rsync -rvl <span class="variable">$pdir</span>/<span class="variable">$fname</span> <span class="variable">$user</span>@linux<span class="variable">$host</span>:<span class="variable">$pdir</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>查看集群各节点java进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前用户名称</span></span><br><span class="line">user=`whoami`</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((host=101; host&lt;104; host++)); <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> --------------------linux<span class="variable">$host</span>--------------------</span><br><span class="line">  ssh <span class="variable">$user</span>@linux<span class="variable">$host</span> <span class="string">"<span class="variable">$JAVA_HOME</span>/bin/jps"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><ul><li><p>集群规划</p><table><thead><tr><th>linux101</th><th>linux102</th><th>linux103</th></tr></thead><tbody><tr><td>NameNode</td><td>SecondaryNameNode</td><td>-</td></tr><tr><td>DataNode</td><td>DataNode</td><td>DataNode</td></tr><tr><td>-</td><td>-</td><td>ResourceManager</td></tr><tr><td>NodeManager</td><td>NodeManager</td><td>NodeManager</td></tr><tr><td>-</td><td>JobHistoryServer</td><td>-</td></tr></tbody></table></li></ul><ol><li><p>下载<a href="https://www.apache.org/dyn/closer.cgi/hadoop/common/hadoop-3.2.1/hadoop-3.2.1.tar.gz" target="_blank" rel="noopener">hadoop-3.2.1</a>并解压</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zvxf hadoop-3.2.1/hadoop-3.2.1.tar.gz -C ~/module</span><br></pre></td></tr></table></figure><p> 设置环境变量:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------</span></span><br><span class="line"><span class="comment"># Hadoop</span></span><br><span class="line"><span class="built_in">export</span> HADOOP_HOME=/home/bob/module/hadoop-3.2.1</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HADOOP_HOME</span>/bin:<span class="variable">$HADOOP_HOME</span>/sbin</span><br><span class="line"><span class="comment"># ----------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></li><li><p>配置<code>hadoop-env.sh</code></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/home/bob/module/jdk1.8.0_251</span><br></pre></td></tr></table></figure></li><li><p><a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/core-default.xml" target="_blank" rel="noopener">配置</a><code>core-site.xml</code></p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://linux101:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///home/bob/module/hadoop-3.2.1/data/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml" target="_blank" rel="noopener">配置</a><code>hdfs-site.xml</code></p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///home/bob/module/hadoop-3.2.1/data/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///home/bob/module/hadoop-3.2.1/data/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>linux102:9868<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><a href="https://hadoop.apache.org/docs/stable/hadoop-yarn/hadoop-yarn-common/yarn-default.xml" target="_blank" rel="noopener">配置</a><code>yarn-site.xml</code></p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>linux103<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.env-whitelist<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAPRED_HOME<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log-aggregation-enable<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log-aggregation.retain-seconds<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>7200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log.server.url<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>http://linux102:19888/jobhistory/logs<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><a href="https://hadoop.apache.org/docs/stable/hadoop-mapreduce-client/hadoop-mapreduce-client-core/mapred-default.xml" target="_blank" rel="noopener">配置</a><code>mapred-site.xml</code></p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.application.classpath<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/*:$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/lib/*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>linux102:10020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>linux102:19888<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置<code>workers</code>工作节点</p><blockquote><p>供集群启动、停止等管理脚本使用（eg: start-dfs.sh, …）</p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux101</span><br><span class="line">linux102</span><br><span class="line">linux103</span><br></pre></td></tr></table></figure></li><li><p>将配置好的hadoop目录分发给其他节点</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xsync ~/module/hadoop-3.2.1</span><br></pre></td></tr></table></figure></li></ol><h3 id="集群启动"><a href="#集群启动" class="headerlink" title="集群启动"></a>集群启动</h3><ol><li><p>格式化dfs文件系统</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure><p> 注意：若二次格式化，则需要先删除各节点之前的<code>data</code>和<code>logs</code>目录，再启动dfs。</p></li><li><p>启动<code>NameNode</code>和<code>DataNode</code>守护进程</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start-dfs.sh</span><br></pre></td></tr></table></figure><p> <code>xjps</code>确认进程存活，访问NameNode Web UI：<a href="http://linux101:9870/" target="_blank" rel="noopener">http://linux101:9870/</a></p><p> 测试：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -mkdir -p /user/bob/wc/input    <span class="comment"># 创建wordcount输入文件夹</span></span><br><span class="line">hdfs dfs -put wc.iput /user/bob/wc/input <span class="comment"># 将准备好的单词文件放入输入文件夹</span></span><br></pre></td></tr></table></figure></li><li><p>启动<code>ResourceManager</code>和<code>NodeManager</code>守护进程</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start-yarn.sh</span><br></pre></td></tr></table></figure><p> <code>xjps</code>确认进程存活，访问ResourceManager Web UI：<a href="http://linux103:8088/" target="_blank" rel="noopener">http://linux103:8088/</a></p></li><li><p>启动作业历史记录服务器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mr-jobhistory-daemon.sh start historyserver</span><br></pre></td></tr></table></figure><p> <code>xjps</code>确认进程存活，访问HistoryServer Web UI：<a href="http://linux102:19888/" target="_blank" rel="noopener">http://linux102:19888/</a></p></li><li><p>运行MapReduce任务</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-3.2.1.jar wordcount /user/bob/wc/input /user/bob/wc/output <span class="comment"># 执行wordcount</span></span><br><span class="line"></span><br><span class="line">hdfs dfs -cat output/p* <span class="comment"># 查看运行结果</span></span><br></pre></td></tr></table></figure></li><li><p>停止集群</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stop-dfs.sh <span class="comment"># linux101上执行</span></span><br><span class="line">stop-yarn.sh <span class="comment"># linux103上执行</span></span><br><span class="line">mr-jobhistory-daemon.sh stop historyserver <span class="comment"># linux102上执行</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：以上启动/停止均需在对应节点执行，eg: NameNode-&gt;linux101 JobHistory-&gt;linux102 ResourceManager-&gt;linux103 </p></blockquote></li></ol><h2 id="Spark-On-Yarn"><a href="#Spark-On-Yarn" class="headerlink" title="Spark On Yarn"></a>Spark On Yarn</h2><ul><li><p>集群规划</p><table><thead><tr><th>linux101</th><th>linux102</th><th>linux103</th></tr></thead><tbody><tr><td>Master</td><td>-</td><td>-</td></tr><tr><td>Worker</td><td>Worker</td><td>Worker</td></tr><tr><td>-</td><td>HistoryServer</td><td>-</td></tr></tbody></table></li></ul><ol><li><p>下载<a href="https://www.apache.org/dyn/closer.lua/spark/spark-2.4.5/spark-2.4.5-bin-hadoop2.7.tgz" target="_blank" rel="noopener">spark-2.4.5</a>并解压</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zvxf spark-2.4.5-bin-hadoop2.7.tgz -C ~/module</span><br><span class="line">mv spark-2.4.5-bin-hadoop2.7 spark-2.4.5</span><br></pre></td></tr></table></figure><p> 设置环境变量:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------</span></span><br><span class="line"><span class="comment"># Spark</span></span><br><span class="line"><span class="built_in">export</span> SPARK_HOME=/home/bob/module/spark-2.4.5</span><br><span class="line"><span class="comment">#export PATH=$PATH:$SPARK_HOME/bin:$SPARK_HOME/sbin</span></span><br><span class="line"><span class="comment"># ----------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></li><li><p><a href="https://spark.apache.org/docs/2.4.5/running-on-yarn.html" target="_blank" rel="noopener">配置</a><code>spark-env.sh</code></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mv spark-env.sh.template spark-env.sh</span><br><span class="line">vim spark-env.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------</span></span><br><span class="line">HADOOP_CONF_DIR=/home/bob/module/hadoop-3.2.1/etc/hadoop</span><br><span class="line">SPARK_MASTER_HOST=linux101</span><br><span class="line">SPARK_MASTER_PORT=7077</span><br></pre></td></tr></table></figure></li><li><p>配置<code>slaves</code></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mv slaves.template slaves</span><br><span class="line">vim slaves</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------</span></span><br><span class="line">linux101</span><br><span class="line">linux102</span><br><span class="line">linux103</span><br></pre></td></tr></table></figure></li><li><p>将配置好的spark目录分发给其他节点</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xsync ~/module/spark-2.4.5</span><br></pre></td></tr></table></figure></li><li><p>启动spark集群</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbin/start-all.sh</span><br></pre></td></tr></table></figure><p> <code>xjps</code>确认spark进程存活，访问Spark Web UI：<a href="http://linux101:19888/" target="_blank" rel="noopener">http://linux101:19888/</a></p></li><li><p>配置作业历史服务器</p><blockquote><p>便于在Hadoop Web UI中查看Spark Job History</p></blockquote> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mv spark-default.conf.template spark-default.conf</span><br><span class="line">vim spark-default.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------</span></span><br><span class="line">spark.eventLog.enabled           <span class="literal">true</span>  <span class="comment"># 记录事件日志</span></span><br><span class="line">spark.eventLog.dir               hdfs://linux101:9000/spark/jobhistory <span class="comment"># 事件日志保存路径（需预先在hdfs创建）</span></span><br><span class="line">spark.eventLog.compress          <span class="literal">true</span>  <span class="comment"># 压缩事件日志</span></span><br><span class="line">spark.yarn.historyServer.address linux102:18080 <span class="comment"># Hadoop Web UI 'TarckingUI'指向的Spark HistoryServer的地址</span></span><br></pre></td></tr></table></figure> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim spark-env.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------</span></span><br><span class="line"><span class="comment"># Spark HistoryServer的访问端口，HistoryServer显示的最大应用程序数量，HistoryServer日志存放目录</span></span><br><span class="line">SPARK_HISTORY_OPTS=<span class="string">"-Dspark.history.ui.port=18080</span></span><br><span class="line"><span class="string">-Dspark.history.retainedApplications=3</span></span><br><span class="line"><span class="string">-Dspark.history.fs.logDirectory=hdfs://linux101:9000/spark/jobhistory"</span> <span class="comment">#</span></span><br></pre></td></tr></table></figure> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分发配置到其他节点</span></span><br><span class="line">xsync spark-default.conf</span><br><span class="line">xsync spark-env.sh</span><br></pre></td></tr></table></figure></li><li><p>启动作业历史服务器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbin/start-history-server.sh <span class="comment"># 启动Spark HistoryServer</span></span><br></pre></td></tr></table></figure><p> <code>xjps</code>确认进程存活</p></li><li><p>执行测试</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit --class org.apache.spark.examples.SparkPi \</span><br><span class="line">    --master yarn \</span><br><span class="line">    --deploy-mode cluster \</span><br><span class="line">    --driver-memory 2g \</span><br><span class="line">    --executor-memory 1g \</span><br><span class="line">    --executor-cores 1 \</span><br><span class="line">    examples/jars/spark-examples*.jar \</span><br><span class="line">    10</span><br></pre></td></tr></table></figure></li></ol><h2 id="Flink-On-Yarn"><a href="#Flink-On-Yarn" class="headerlink" title="Flink On Yarn"></a>Flink On Yarn</h2><ol><li><p>下载<a href="https://www.apache.org/dyn/closer.lua/flink/flink-1.9.3/flink-1.9.3-bin-scala_2.12.tgz" target="_blank" rel="noopener">flink-1.9.3</a>并解压</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zvxf flink-1.9.3-bin-scala_2.12.tgz -C ~/module</span><br><span class="line">mv flink-1.9.3-bin-scala_2.12 flink-1.9.3</span><br></pre></td></tr></table></figure><p> 设置环境变量（可选）:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------</span></span><br><span class="line"><span class="comment"># Flink</span></span><br><span class="line"><span class="built_in">export</span> FLINK_HOME=/home/bob/module/flink-1.9.3</span><br><span class="line"><span class="comment">#export PATH=$PATH:$FLINK_HOME/bin</span></span><br><span class="line"><span class="comment"># ----------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></li><li><p>下载<a href="https://repo.maven.apache.org/maven2/org/apache/flink/flink-shaded-hadoop-2-uber/2.8.3-10.0/flink-shaded-hadoop-2-uber-2.8.3-10.0.jar" target="_blank" rel="noopener">hadoop</a>支持组件</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv flink-shaded-hadoop-2-uber-2.8.3-10.0.jar ~/module/flink-1.9.3/lib</span><br></pre></td></tr></table></figure></li><li><p>配置<code>yarn-site.xml</code></p><blockquote><p>提交应用程序的最大尝试次数</p></blockquote> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.am.max-attempts<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>4<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/zh/ops/jobmanager_high_availability.html" target="_blank" rel="noopener">配置</a><code>flink-conf.yaml</code></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim conf/flink-conf.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------</span></span><br><span class="line">high-availability: zookeeper</span><br><span class="line">high-availability.storageDir: hdfs:///linux101:9000/flink/ha/</span><br><span class="line">high-availability.zookeeper.quorum: linux101:2181,linux102:2181,linux103:2181</span><br><span class="line">high-availability.zookeeper.path.root: /flink</span><br></pre></td></tr></table></figure></li><li><p>配置ZooKeeper服务器</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim conf/zoo.cfg</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------</span></span><br><span class="line">server.1=linux101:2888:3888</span><br><span class="line">server.2=linux102:2888:3888</span><br><span class="line">server.3=linux103:2888:3888</span><br></pre></td></tr></table></figure></li><li><p>将配置好的flink目录分发给其他节点</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xsync ~/module/flink-1.9.3</span><br></pre></td></tr></table></figure></li><li><p>启动ZooKeeper仲裁</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/start-zookeeper-quorum.sh</span><br></pre></td></tr></table></figure></li><li><p>启动Flink Yarn Session</p><ul><li><p>分离模式</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bin/yarn-session.sh -n 3 -s 2 -nm flink-yarn-detach -d <span class="comment"># 后台启动</span></span><br><span class="line">./bin/flink run ./examples/batch/WordCount.jar <span class="comment"># 运行任务</span></span><br></pre></td></tr></table></figure></li><li><p>客户端模式</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/flink run -m yarn-cluster -yn 3 -ys 2 -ynm flink-yarn-client ./examples/batch/WordCount.jar <span class="comment"># 启动运行</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>测试HA</p><p> <code>xjps</code>查看YarnSessionClusterEntrypoint进程所在节点，到对应机器上kill掉该进程id</p><p> 访问 <a href="http://linux103:8088/" target="_blank" rel="noopener">http://linux103:8088/</a> 点击查看<code>flink-yarn-detach</code>应用，会发现多出现一次appattempt，在Flink UI的JobManager选项卡下也可查看，再次提交flink job仍可运行。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Hadoop集群搭建&quot;&gt;&lt;a href=&quot;#Hadoop集群搭建&quot; class=&quot;headerlink&quot; title=&quot;Hadoop集群搭建&quot;&gt;&lt;/a&gt;Hadoop集群搭建&lt;/h2&gt;&lt;h3 id=&quot;虚拟机准备&quot;&gt;&lt;a href=&quot;#虚拟机准备&quot; class=&quot;headerlink&quot; title=&quot;虚拟机准备&quot;&gt;&lt;/a&gt;虚拟机准备&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;安装&lt;a href=&quot;https://download.virtualbox.org/virtualbox/6.1.8/VirtualBox-6.1.8-137981-Win.exe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Visual Box&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;准备&lt;a href=&quot;http://isoredirect.centos.org/centos/7/isos/x86_64/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CentOS 7镜像文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jingyan.baidu.com/article/4dc4084868a1e4c8d946f133.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;创建虚拟机&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.linuxidc.com/Linux/2018-04/151924.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;设置虚拟机固定IP&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="BigData" scheme="http://xiaojiaC.github.io/blog/categories/BigData/"/>
    
    
      <category term="hadoop" scheme="http://xiaojiaC.github.io/blog/tags/hadoop/"/>
    
      <category term="hdfs" scheme="http://xiaojiaC.github.io/blog/tags/hdfs/"/>
    
      <category term="yarn" scheme="http://xiaojiaC.github.io/blog/tags/yarn/"/>
    
      <category term="mapreduce" scheme="http://xiaojiaC.github.io/blog/tags/mapreduce/"/>
    
      <category term="spark" scheme="http://xiaojiaC.github.io/blog/tags/spark/"/>
    
      <category term="flink" scheme="http://xiaojiaC.github.io/blog/tags/flink/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程实战</title>
    <link href="http://xiaojiac.github.io/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98.html"/>
    <id>http://xiaojiac.github.io/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98.html</id>
    <published>2020-03-22T12:47:30.000Z</published>
    <updated>2023-10-18T13:45:27.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><p>要编写线程安全的代码，核心在于<span class="label primary">要对状态访问操作进行管理</span>，特别是对<strong>共享的</strong>和<strong>可变的</strong>状态的访问。</p><p>当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。</p><p>如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：</p><ul><li>不在线程之间共享该状态变量。</li><li>将状态变量修改为不可变的变量。</li><li>在访问状态变量时使用同步。</li></ul><a id="more"></a><p>在编写并发程序时，一种正确的编程方法就是：<span class="label success">首先使代码正确运行，然后再提高代码的速度。</span>即便如此，最好也只是当性能测试结果和应用需求告诉你必须提高性能，以及测量结果表明这种优化在实际环境中确实能带来性能提升时，才进行优化。</p><h3 id="线程安全性-1"><a href="#线程安全性-1" class="headerlink" title="线程安全性"></a>线程安全性</h3><p>在线程安全性的定义中，最核心的概念是<span class="label primary">正确性</span>（某个类的行为与其规范完全一致）。</p><blockquote><p>当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。</p></blockquote><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>竞态条件：</p><ul><li><span class="label info">先检查后执行</span> eg: 单例延迟初始化</li><li><span class="label info">读取-修改-写入</span> eg: i++</li></ul><p>原子操作：对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。</p><p>当在无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的。在实际情况中，应尽可能地使用现有的线程安全对象（eg: <code>AtomicLong</code>）来管理类的状态。</p><h3 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h3><p>当在不变性条件涉及多个变量时，各个变量之间并不是彼此独立的，而是某个变量的值会对其他变量的值产生约束。因此，当更新某一个变量时，需要在同一个原子操作中对其他变量同时进行更新。</p><span class="label danger">要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。</span><h3 id="用锁来保护状态"><a href="#用锁来保护状态" class="headerlink" title="用锁来保护状态"></a>用锁来保护状态</h3><span class="label warning">如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步。而且，当使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同一个锁。</span><p>每个共享的和可变的变量都应该只由一个锁类保护，从而使维护人员知道是哪一个锁。</p><span class="label danger">每个包含多个变量的不变性条件，其中涉及的所有变量都需要同一个锁来保护。</span><h3 id="活跃性与性能"><a href="#活跃性与性能" class="headerlink" title="活跃性与性能"></a>活跃性与性能</h3><span class="label warning">通常，在简单性与性能之间存在着相互制约因素。当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性（这可能会破坏安全性）。</span><p>当使用锁时，你应该清楚代码块中实现的功能，以及在执行该代码块时是否需要很长的时间，无论是执行计算密集的操作，还是执行某个可能阻塞的操作，如果锁持有的时间过长，那么都会带来活跃性或性能问题。</p><span class="label danger">当执行时间较长的计算或可能无法快速完成的操作(eg: I/O)时，一定不要持有锁。</span><h2 id="对象的共享"><a href="#对象的共享" class="headerlink" title="对象的共享"></a>对象的共享</h2><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，想要对内存操作的执行顺序进行判断，几乎无法得出正确的结论。有一种简单的方法能避免这些复杂的问题：<span class="label success">只要有数据在多个线程间共享，就使用正确的同步。</span></p><p>当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证称为最低安全性。它适用于绝大多数变量，但是存在一个例外：<span class="label primary">非volatile类型的64位数值变量。</span></p><p>JMM要求变量的读取和写入操作都必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读或写操作分解为两个32位的操作。因此在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非用volatile来声明它们，或用锁保护起来。</p><p>加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。</p><span class="label danger">加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。</span><p>什么时候使用volatile变量？仅当同时满足以下<strong>所有</strong>条件时。</p><ul><li>对变量的写入操作不依赖变量的当前值，或者能确保只有单个线程更新变量的值。</li><li>该变量不会与其他变量一起纳入不变性条件中。</li><li>在访问变量时不需要加锁。</li></ul><h3 id="发布与逸出"><a href="#发布与逸出" class="headerlink" title="发布与逸出"></a>发布与逸出</h3><p>发布：使对象能够在当前作用域之外的代码中使用。</p><p>发布的方式：</p><ul><li>将对象引用保存到一个公有的静态变量。</li><li>发布对象时间接地发布了其他对象（eg:非私有域中引用的所有对象）。</li><li>发布一个内部类实例。</li></ul><p>逸出：某个不应该发布的对象被发布。当某个对象逸出时，你必须假设某个类或线程可能会误用该对象，误用该引用的风险始终存在。</p><p>逸出的例子：</p><ul><li>构造函数中发布内部类实例，导致<code>this</code>引用逸出。</li><li>构造函数中创建线程后使用<code>start()</code>启动，导致<code>this</code>引用逸出。</li></ul><span class="label danger">不要在构造过程中使this引用逸出。</span><h3 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h3><p>当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步，这种技术被称为线程封闭。</p><ul><li>Ad-hoc线程封闭：维护封闭性的职责完全由程序实现来承担。<blockquote><span class="label warning">在volatile变量上存在一种特殊的线程封闭。只要你能确保只有单个线程对共享的volatile变量执行写入操作，那么就可以安全地在这些共享的volatile变量上执行“读取-修改-写入”的操作。</span></blockquote></li><li>栈封闭</li><li><code>ThreadLocal</code></li></ul><h3 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h3><p>不可变的对象一定是线程安全的。</p><p>不可变性并不等于将对象中所有的域都声明为final类型，即使对象中所有的域都是final类型的，这个对象也仍然是可变的，因为final类型的域中可以保存对可变对象的引用。</p><p>当满足以下所有条件时，对象才是不可变的：</p><ul><li>对象创建以后其状态就不能修改。</li><li>对象的所有域都是final类型。</li><li>对象是正确创建的（在对象的创建期间，this引用没有逸出）。</li></ul><span class="label success">除非需要更高的可见性，否则应将所有的域都声明为私有域。除非需要某个域是可变的，否则应将其声明为final域。</span><h3 id="安全发布"><a href="#安全发布" class="headerlink" title="安全发布"></a>安全发布</h3><p>安全发布：要安全发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象，可以通过以下方式安全发布：</p><ul><li>在静态初始化函数中初始化一个对象引用。</li><li>将对象的引用保存到volatile类型的域或<code>AtomicReferance</code>对象中。</li><li>将对象的引用保存到某个正确构造对象的final类型域中。</li><li>将对象的引用保存到一个由锁保护的域中。</li></ul><p>在没有额外同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。</p><p>对象的发布取决于它的可变性：</p><ul><li>不可变对象可以通过任意机制来发布。</li><li>事实不可变对象必须通过安全方式来发布。</li><li>可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。</li></ul><span class="label warning">如果final类型的域指向的是可变对象，那么在访问这些域所指向的对象的状态时仍然需要同步。</span><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>并发程序中使用和共享对象时，有以下一些实用的策略，包括：</p><ul><li><strong>线程封闭</strong>。线程封闭的对象只能有一个线程持有，对象被封闭在该线程中，并且只能由这个线程修改。</li><li><strong>只读共享</strong>。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。</li><li><strong>线程安全共享</strong>。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来访问而不需要进一步的同步。</li><li><strong>保护对象</strong>。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。</li></ul><h2 id="对象的组合"><a href="#对象的组合" class="headerlink" title="对象的组合"></a>对象的组合</h2><h3 id="设计线程安全类"><a href="#设计线程安全类" class="headerlink" title="设计线程安全类"></a>设计线程安全类</h3><p>在设计线程安全类的过程中，需要包含以下三个基本要素：</p><ol><li>找出构成对象状态的所有变量。</li><li>找出约束变量的不变性条件。</li><li>建立对象状态的并发访问管理策略。</li></ol><p>同步策略定义了如何在不违背对象不变条件或后验条件的情况下对其状态的访问操作进行协同。同步策略规定了如何将不可变性，线程封闭与加锁机制等结合起来以维护线程的安全性，并且还规定了哪些变量由哪些锁来保护。要确保开发人员可以对这个类进行分析与维护，就必须将同步策略写为正式文档。</p><span class="label warning">如果在一个不变性条件中包含多个变量，那么在执行任何访问相关变量的操作时，都必须持有保护这些变量的锁。</span><p>类的不变性条件与后验条件约束了在对象上有哪些状态和状态转换是有效的。在某些对象的方法中还包含一些基于状态的先验条件（例如：不能从空队列移除一个元素）。如果某个操作中包含有基于状态的先验条件，那么这个操作就称为依赖状态的操作。</p><h3 id="实例封闭"><a href="#实例封闭" class="headerlink" title="实例封闭"></a>实例封闭</h3><p>封装可简化线程安全类的实现过程。通过将封闭机制与合适的加锁策略结合起来，可以确保以线程安全的方式来使用非线程安全的对象。</p><p>将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。</p><span class="label success">优先使用私有的锁对象而不是对象的内置锁（或任何其他可通过公有方式访问的锁）。</span><h3 id="线程安全性委托"><a href="#线程安全性委托" class="headerlink" title="线程安全性委托"></a>线程安全性委托</h3><p>线程安全性委托：</p><ul><li>单个状态变量：可以将线程的安全性委托给单个线程安全的状态变量。</li><li>独立的多个状态变量：可以将线程的安全性委托给多个线程安全的状态变量，只要这些变量是彼此独立的，即组合而成的类并不会在其包含的多个状态变量上增加任何不变性条件。</li><li>有不变性条件的多个状态变量：<span class="label warning">某个类含有复合操作，那么仅靠委托并不足以实现线程安全性。这个类必须提供自己的加锁机制以保证这些复合操作都是原子操作，除非整个复合操作都可以委托给状态变量。</span></li></ul><p>如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全地发布这个变量。</p><h3 id="在现有的线程安全类中添加功能"><a href="#在现有的线程安全类中添加功能" class="headerlink" title="在现有的线程安全类中添加功能"></a>在现有的线程安全类中添加功能</h3><p>在现有的线程安全类中添加功能有以下几种方式：</p><ul><li>修改原始的类：通常无法做到。</li><li><del>扩展这个类</del>：比较脆弱，底层类改变同步策略选择不同的锁来保护它的状态变量时，子类会被破坏。</li><li><del>将扩展代码放入一个辅助类</del>：更加脆弱，必须谨慎确保和线程安全类使用同一个锁，客户端加锁还会破坏同步策略的封装性。</li><li>使用组合构建自己的锁</li></ul><h3 id="将同步策略文档化"><a href="#将同步策略文档化" class="headerlink" title="将同步策略文档化"></a>将同步策略文档化</h3><p>在文档中说明客户代码需要了解的线程安全性保证，以及代码维护人员需要了解的同步策略。</p><h2 id="基础构建模块"><a href="#基础构建模块" class="headerlink" title="基础构建模块"></a>基础构建模块</h2><h3 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h3><p>同步容器类都是线程安全的，但在某些情况下可能需要额外的客户端加锁来保护复合操作。</p><p>同步容器类通过其<strong>自身的锁</strong>来保护它的每个方法。</p><p>虽然加锁可以防止迭代器抛出<code>ConcurrentModificationException</code>，但你必须记住在所有对共享容器进行迭代的地方都需要加锁。尤其要小心隐式迭代器的场景（容器的<code>toString</code>方法，以及<code>hasCode</code>和<code>equals</code>方法会间接地执行迭代器）。</p><span class="label success">正如封装对象的状态有助于维持不变性条件一样，封装对象的同步机制同样有助于确保实施同步策略。</span><h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><p>通过并发容器来代替同步容器，可以极大地提高伸缩性并降低风险。</p><p><code>ConcurrentHashMap</code>：只有当应用程序需要加锁Map以进行独占访问时，才应该放弃使用<code>ConcurrentHashMap</code>。<br><code>CopyOnWriteArrayList</code>：仅当迭代操作远远多于修改操作时，才应该使用“写时复制”容器。<br><code>ArrayBlockingQueue</code>：在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于<code>LinkedBlockingQueue</code>。<br><code>LinkedBlockingQueue</code>：对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<br><code>SynchronousQueue</code>：仅当有足够多的的消费者，并且总是有一个消费者准备好获取交付的工作时，才适合用同步队列。<br><code>LinkedBlockingDeque</code>：双端队列，适用于工作密取。</p><span class="label success">在设计初期就使用阻塞队列建立对资源的管理</span>（提早做这件事会比以后再修复容易的多）。<p>在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具：它们能抑制防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮。</p><h3 id="阻塞和可中断的方法"><a href="#阻塞和可中断的方法" class="headerlink" title="阻塞和可中断的方法"></a>阻塞和可中断的方法</h3><p>当一个方法能够抛出<code>InterruptedException</code>时，是在告诉你这个方法是一个可阻塞方法，进一步看，如果它被中断，将可以提前结束阻塞状态。<br>当你在代码中调用了一个会抛出<code>InterruptedException</code>的方法时，你自己的方法就成为了一个阻塞方法，要为响应中断做好准备。在类库代码中，有两种基本选择：</p><ul><li><strong>传递<code>InterruptedException</code></strong>：1. 不捕获继续抛出。2. 先捕获，然后对其中特定活动进行简洁清理后，再抛出。</li><li><strong>恢复中断</strong>：有时候不能抛出<code>InterruptedException</code>，比如当你的代码是<code>Runnable</code>的一部分时。在这种情况下，你必须捕获<code>InterruptedException</code>，并且在当前线程中调用<code>interrupt</code>从中断中恢复，这样调用栈中更高层的代码才可以发现中断已经发生。</li></ul><span class="label warning">你不应该捕获InterruptedException，但不做任何响应。只有一种情况允许掩盖中断：你扩展了Thread，并因此控制了所有处于调用栈上层的代码。</span><h3 id="同步工具"><a href="#同步工具" class="headerlink" title="同步工具"></a>同步工具</h3><p>闭锁(<code>CountDownLatch</code>/<code>FutureTask</code>)：可以用来确保特定活动直到其他的活动完成后才发生。</p><ul><li>确保一个计算不会执行，直到它需要的资源被初始化。</li><li>确保一个服务不会开始，直到它依赖的其他服务都已经开始。</li><li>等待，直到活动的所有部分都为继续处理做好充分准备，比如：多玩家游戏中的所有玩家是否都准备就绪。</li></ul><p>信号量(<code>Semaphore</code>)：控制同时访问某个特定资源的线程数量或同时执行某个指定操作的数量。还可以用来实现某种资源池，或者对容器施加边界。</p><p>屏障(<code>CyclicBarrier</code>)：与闭锁类似，都能阻塞一组线程，直到某些事件发生。它们的不同之处在于：所有线程必须同时到达同步点，才能够继续处理。<span class="label primary">闭锁等待的是事件，屏障等待的是其他线程。</span></p><p>交换机(<code>Exchanger</code>)：用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>可变状态是至关重要的。<blockquote><p>所有并发问题都可以归结为如何协调对并发状态的访问。可变状态越少就越容易确保线程安全性。</p></blockquote></li><li>尽量将域声明为final类型，除非需要它们是可变的。</li><li>不可变对象一定是线程安全的。<blockquote><p>不可变对象能极大地降低并发编程的复杂性。它们更为简单而且安全，可以任意共享而无需使用加锁或保护性复制等机制。</p></blockquote></li><li>封装有助于管理复杂性。<blockquote><p>在编写线程安全的程序时，虽然可以将所有数据都保存在全局变量中，但为什么要这样做？将数据封装在对象中，更易于维持不变性条件：将同步机制封装在对象中，更易于遵循同步策略。</p></blockquote></li><li>用锁来保护每个可变变量。</li><li>当保护同一个不变性条件中的所有变量时，要使用同一个锁。</li><li>在执行复合操作时，要持有锁。</li><li>如果从多个线程中访问同一个可变变量时没有同步机制，那么程序会出现问题。</li><li>不要故作聪明地推断出不需要使用同步。</li><li>在设计过程中考虑线程安全，或者在文档中明确地指出它不是线程安全的。</li><li>将同步策略文档化。</li></ul><h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><p><code>Executor</code>：一个简单的接口，它提供了一种标准的方法将任务的提交过程与执行过程解耦开来，并用<code>Runnable</code>来表示任务。</p><p><code>Executor</code>的实现通常会创建线程来执行任务，但JVM只有在所有非守护线程全部终止才会退出。因此，如果无法正确的关闭<code>Executor</code>，那么JVM将无法结束。</p><p><code>ExecutorService</code>扩展了<code>Executor</code>接口，添加了一些用于生命周期管理的方法（同时还提供一些用于任务提交的便利方法）。</p><p><code>ExecutorService</code>的生命周期有三种状态：运行、关闭和终止。<code>ExecutorService</code>最初创建后的初始状态是运行状态。当它被关闭后提交到<code>ExecutorService</code>的任务，会被拒绝执行处理器处理。它可能只是简单抛弃任务，或者引起<code>execute</code>方法抛出一个<code>RejectedExecutionException</code>等。一旦所有的任务全部完成后，<code>ExecutorService</code>会进入终止状态。可以调用<code>awaitTermination</code>来等待<code>ExecutorService</code>到达终止状态，或者通过<code>isTerminated</code>来轮询检查<code>ExecutorService</code>是否已经终止。通常在调用<code>shutdown</code>之后会立即调用<code>awaitTermination</code>阻塞等待，从而产生同步地关闭<code>ExecutorService</code>的效果。</p><blockquote><p><code>shutdown</code>方法将执行平缓的关闭过程：<span class="label primary">不再接受新的任务，同时等待已经提交的任务执行完毕——包括尚未开始执行的任务。</span><br><code>shutdownNow</code>方法将执行粗暴的关闭过程：<span class="label primary">尝试取消所有运行中的任务，并且不再启动排在队列中尚未开始的任务。</span></p></blockquote><p>在Executor框架中，已提交但尚未开始的任务可以取消，但对于那些已经开始执行的任务，只有当它们能够响应中断时，才能取消。取消一个已经完成的任务不会有任何影响。</p><h3 id="Executors中的静态方法"><a href="#Executors中的静态方法" class="headerlink" title="Executors中的静态方法"></a>Executors中的静态方法</h3><p><code>newFixedThreadPool</code>：创建一个定长的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大长度，这时线程池的规模将不再变化（<em>如果某个线程由于发生了未预期的exception而结束，那么线程池会补充一个新的线程</em>）。</p><p><code>newCachedThreadPool</code>：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，当需求增加时，它可以灵活地添加新线程，而并不会对池的长度做任何限制。</p><p><code>newSingleThreadExecutor</code>：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO, LIFO, 优先级）执行。<em>如果这个线程异常结束会创建一个新的线程来替代</em>。</p><p><code>newScheduledThreadPool</code>：创建一个定长线程池，支持定时及周期性任务执行。类似于<code>Timer</code>。</p><blockquote><span class="label warning">Timer存在一些缺陷，你应该考虑使用ScheduledThreadPoolExecutor来替代它。</span><ol><li>只创建唯一的线程来执行所有的任务，如果一个任务执行很耗时，会导致其他任务的时效准确性出现问题。</li><li>如果任务执行中抛出未检查的异常，将产生无法预料的行为（抛出未检查的异常会终止线程，不会重新恢复线程的执行，已经被安排但尚未执行的任务永远不再执行，新的任务也不能被调度，即发生线程泄露）。</li></ol></blockquote><p>如果你向<code>Executor</code>提交了一个批处理任务，并且希望在它们完成后获得结果。为此你可以保存与每个任务相关联的<code>Future</code>，然后不断地调用timeout为零的<code>get</code>，来检验<code>Future</code>是否完成。这样做固然可以，但却相当乏味。幸运的是，还有一个更好的方法：完成服务。</p><p><code>CompletionService</code>整合了<code>Executor</code>和<code>BlockingQueue</code>的功能。你可以将<code>Callable</code>任务提交给它去执行，然后使用类似于队列中的<code>take</code>和<code>poll</code>方法，在结果完整可用时获得这个结果，像一个打包的<code>Future</code>。<code>ExecutorCompletionService</code>是实现<code>CompletionService</code>接口的一个类，并将计算任务委托给一个<code>Executor</code>。</p><h2 id="取消与关闭"><a href="#取消与关闭" class="headerlink" title="取消与关闭"></a>取消与关闭</h2><p>java没有提供任何机制来安全地终止线程。但它提供了中断，这是一种协作机制，能够使一个线程终止另一个线程的当前工作。</p><h3 id="取消策略"><a href="#取消策略" class="headerlink" title="取消策略"></a>取消策略</h3><p>一个可取消的任务必须拥有取消策略，这个策略详细定义取消操作的“How”、“When”、“What”，即代码如何（How）请求取消该任务，任务在何时（When）检查是否已经请求了取消，以及在响应时执行那些（What）操作。</p><p>应用程序可以不间断定期的检查标志位的状态是否被改变，来实现取消。但是 <span class="label warning">如果程序调用了一个阻塞方法（例如：BlockingQueu.put()）那么可能会出现一个严重的问题，即任务可能永远无法检查取消标志。</span></p><h3 id="中断策略"><a href="#中断策略" class="headerlink" title="中断策略"></a>中断策略</h3><p>一个中断策略决定线程如何应对中断请求——当发现中断请求时，应该做哪些工作，哪些工作单元对中断来说是原子操作，以及以多快速度来响应中断。</p><p>每个<code>Thread</code>都有一个boolean类型的中断状态。当中断线程时，该状态会被置为true。<code>Thread</code>中包含的中断方法：<code>inturrept()</code>会将中断状态置为true，<code>isInterrupted()</code>方法会返回当前的中断状态，而<code>interrupted()</code>方法则会清除当前状态，并返回它之前的值。</p><p>阻塞库函数：<code>Object.wait()</code>、<code>Thread.sleep()</code>和<code>Thread.join()</code>等，都会去检查线程何时中断，并且在发生中断时提前返回。它们在响应中断时执行的操作包括：清除中断状态，并抛出<code>InterruptedException</code>异常，表示阻塞操作由于中断而提前结束。</p><p>当线程在非阻塞状态下中断时，它的中断状态将被设置，然后根据将被取消的操作来检查中断状态以判断发生了中断。通过这样的方法，中断操作将变得“有黏性”——如果不触发<code>InterruptedException</code>，那么中断状态将一直保持，直到明确地清除中断状态。</p><span class="label danger">调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。</span><p>对中断的正确理解是：它并不会真正地中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己（这些时刻也被称为取消点）。</p><p>使用<code>interrupted()</code>静态方法应该小心，因为它会清除并发线程的中断状态。如果你调用了interrupted，并且它返回了true，你必须对其进行处理，除非你想掩盖这个中断——你可以抛出<code>InterruptedException</code>，或者通过再次调用<code>interrupt</code>来恢复中断状态。</p><span class="label success">通常中断是实现取消的最合理方式。</span><h3 id="响应中断"><a href="#响应中断" class="headerlink" title="响应中断"></a>响应中断</h3><p>在调用可中断的阻塞函数时，例如<code>Thread.sleep</code>或<code>BlockingQueue.put</code>等，有两种实用策略可用于处理<code>InterruptedException</code>：</p><ul><li>传递异常（可能在执行某个特定于任务的清除操作之后），从而使你的方法也称为可中断的阻塞方法。</li><li>恢复中断状态，从而使调用栈中的上层代码能够对其进行处理。</li></ul><p>只有实现了线程中断策略的代码才可以屏蔽中断请求。在常规的任务和库代码中都不应该屏蔽中断请求。</p><p>对于一些<strong>不支持取消</strong>但仍可以调用可中断阻塞方法的操作，它们必须在循环中调用这些方法，并在发现中断后重新尝试。在这种情况下，它们应该在本地保存中断状态，并在返回前恢复状态而不是在捕获<code>InterruptedException</code>时恢复状态。</p><p>如果代码不会调用可中断的阻塞方法，那么仍然可以通过在任务代码中轮询当前线程的中断状态来响应中断。</p><p>执行任务的线程拥有自己的执行策略，即使任务不响应中断，限时运行的方法仍然能返回到它的调用者。</p><h3 id="通过Future取消"><a href="#通过Future取消" class="headerlink" title="通过Future取消"></a>通过Future取消</h3><p><code>ExecutorService.submit</code>会返回一个<code>Future</code>来描述任务。<code>Future</code>有一个<code>cancel</code>方法,它需要一个<code>boolean</code>类型的参数: <code>mayInterruptIfRunning</code>，它的返回值表示取消尝试是否成功（这仅仅告诉你它是否能够接收中断，而不是任务是否检测并处理了中断）。当<code>mayInterruptIfRunning</code>为true，并且任务当前正在某个线程中运行，那么这个线程能被中断。把这个参数设置成false意味着“如果还没有启动的话，不要运行这个任务”，这应该用于那些不处理中断的任务中。</p><p>当<code>Future.get</code>抛出<code>InterruptedException</code>或<code>TimeoutException</code>时，如果你知道不再需要结果，那么就可以调用<code>Future.cancel</code>来取消任务。</p><h3 id="处理不可中断阻塞"><a href="#处理不可中断阻塞" class="headerlink" title="处理不可中断阻塞"></a>处理不可中断阻塞</h3><p><strong>java.io中的同步Socket I/O</strong>：Socket中的<code>InputStream</code>和<code>OutputStream</code>中的read和write方法都不响应中断，但是通过关闭底层的Socket，可以让read或write所阻塞的线程抛出一个<code>SocketException</code>。</p><p><strong>java.nio中的同步I/O</strong>：中断一个等待<code>InterruptibleChannel</code>的线程，会导致抛出<code>ClosedByInterruptException</code>，并关闭链路（也会导致其他线程在这条链路的阻塞，抛出<code>ClosedByInterruptException</code>）。关闭一个<code>InterruptibleChannel</code>导致多个阻塞在链路操作上的线程抛出<code>AsynchronousCloseException</code>。大多数标准<code>Channel</code>都实现了<code>InterruptibleChannel</code>。</p><p><strong>Selector的异步I/O</strong>：如果一个线程阻塞于<code>Selector.select</code>方法，<code>close</code>方法会导致它通过抛出<code>ClosedSelectorException</code>提前返回。</p><p><strong>获取某个锁</strong>：如果一个线程由于等待某个内置锁而阻塞，那么将无法响应中断，因为线程认为它肯定会获得锁，所以将不会理会中断请求。然而显式<code>Lock</code>类提供了<code>lockInterruptibly</code>方法，允许你等待一个锁，并仍然能够响应中断。</p><p>采用<code>newTaskFor</code>来封装非标准的取消：<br><code>newTaskFor</code>是一个工厂方法，它将创建<code>Future</code>来代表任务。<code>newTaskFor</code>还能返回一个<code>RunnableFuture</code>接口，该接口扩展了<code>Future</code>和<code>Runnable</code>（并由<code>FutureTask</code>实现）。</p><h3 id="停止基于线程的服务"><a href="#停止基于线程的服务" class="headerlink" title="停止基于线程的服务"></a>停止基于线程的服务</h3><p>线程池拥有它的工作者线程，如果需要中断这些线程，那么应该由线程池负责。<code>ExecutorService</code>提供两种关闭方法：使用<code>shutdown</code>平滑关闭，以及使用<code>shutdownNow</code>强行关闭。在进行强行关闭时，会首先关闭当前正在执行的任务，然后返回所有尚未启动的任务清单。</p><p>配合使用<code>exec.shutdown()</code>和<code>exec.awaitTermination(timeout,unit)</code>来关闭线程服务。</p><p>另一种关闭生产者消费者服务的方法是使用“毒丸”对象。“毒丸”是指一个放在队列上的对象，其含义是：当你得到它时，停止一切工作。注意只有在无界队列中，毒丸对象才能够可靠地工作（要保证一定会被放置进去）。</p><h3 id="处理非正常的线程终止"><a href="#处理非正常的线程终止" class="headerlink" title="处理非正常的线程终止"></a>处理非正常的线程终止</h3><p>导致线程提前死亡的最主要原因是<code>RuntimeException</code>。由于这些异常表示出现了某种编程错误或者其他不可修复的错误，因此它们通常不会被捕获。它们不会在调用栈中逐层传递，而是默认地在控制台输出栈追踪消息，并终止线程。</p><span class="label primary">当一个线程因为未捕获异常而退出时，JVM会把这个事件报告给应用程序提供的UncaughtExceptionHandler。如果处理器不存在，默认的行为是向System.err打印出栈追踪信息。</span><p>为了给线程池设置<code>UncaughtExceptionHandler</code>，需要向<code>ThreadPoolExecutor</code>的构造函数提供一个<code>ThreadFactory</code>。标准线程池允许未捕获的任务异常去结束池线程，但是使用一个<code>try-finally</code>块来接收通知的话，当池线程被终结后，能够有新的线程取代它。如果没有非捕获异常的处理器，或者其他失败通知机制，任务会无声无息地失败，这会导致混乱。如果你想在任务因为异常而失败时获得通知，并且执行一些特定于任务的恢复操作，那么可以将任务封装在能捕获异常的<code>Runnable</code>与<code>Callable</code>中，或者改写<code>ThreadPoolExecutor</code>的<code>afterExecute</code>方法。</p><p><strong>令人困惑的是</strong>：只有通过<code>execute</code>提交的任务，才能将它抛出的异常送交给未捕获异常的处理器；而通过<code>submit</code>提交的任务，抛出的任何异常无论是否为受检查的，都被认为是任务返回状态的一部分。如果有<code>submit</code>提交的任务由于抛出了异常而结束，那么这个异常将被<code>Future.get</code>包装在<code>ExecutionException</code>中重新抛出。</p><h3 id="JVM关闭"><a href="#JVM关闭" class="headerlink" title="JVM关闭"></a>JVM关闭</h3><p>JVM的关闭方式可以分为三种：</p><ul><li>正常关闭：当最后一个非守护线程结束或者调用了<code>System.exit</code>或者通过其他特定平台的方法关闭（发送<code>SIGINT</code>，<code>SIGTERM</code>信号或者键入<code>Ctrl-C</code>等）。</li><li>强制关闭：通过调用<code>Runtime.halt</code>方法或者是在操作系统中直接(发送<code>SIGKILL</code>信号)kill掉JVM进程。</li><li>异常关闭：运行中遇到<code>RuntimeException</code>异常，OOM等。</li></ul><h4 id="关闭钩子"><a href="#关闭钩子" class="headerlink" title="关闭钩子"></a>关闭钩子</h4><p>在正常关闭中，JVM首先调用所有已注册的关闭钩子，关闭钩子是指通过<code>Runtime.addShutdownHook</code>注册的但尚未开始的线程。JVM并不能保证关闭钩子的调用顺序。在关闭应用程序线程时，如果有（守护或非守护）线程仍然在运行，那么这些线程接下来将与关闭进程并发执行。当所有关闭钩子都执行结束时，如果<code>runFinalizersOnExit</code>为true，那么JVM将运行终结器，然后再停止。JVM并不会停止或中断任何在关闭时仍然运行的应用程序线程。当JVM最终结束时，这些线程将被强行结束。如果关闭钩子或终结器没有执行完成，那么正常关闭进程“挂起”并且JVM必须被强行关闭。当被强行关闭时，只是关闭JVM，而不会运行关闭钩子。</p><span class="label danger">关闭钩子应该是线程安全的：它们在访问共享数据时必须使用同步，并应该小心地避免死锁。</span><p>关闭钩子可以用于实现服务或应用程序的清理工作（比如：删除临时文件，清除无法由操作系统自动清除的资源等）。</p><span class="label warning">关闭钩子不应该依赖于可能被应用程序或其他关闭钩子关闭的服务。</span>因为所有钩子都是并发执行的且不能保证顺序，如果关闭一个服务依赖于另一个服务的时候这会出现竞态条件或死锁等问题。对所有的服务使用唯一的关闭钩子，让它执行一系列的关闭操作，而不是每个服务使用一个可以避免这个问题。<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>线程可分为两种：普通线程和守护线程。在JVM启动时创建的所有线程中，除了主线程以外，其它的线程都是守护线程（例如：垃圾回收器以及其它执行辅助工作的线程）。当创建一个新线程时，新线程将继承创建它的线程的守护状态。因此在默认情况下，主线程创建的所有线程都是普通线程。</p><p>普通线程与守护线程之间的差异仅在于当线程退出时发生的操作。当一个线程退出时，JVM会检查其他正在运行的线程，如果这些线程都是守护线程，那么JVM会正常退出操作。<span class="label warning">当JVM停止时，所有仍然存在的守护线程都将被抛弃——既不会执行finally代码块，也不会执行回卷栈，而JVM只是直接退出。</span></p><p>我们应尽可能少地使用守护线程——很少有操作能够在不进行清理的情况下被安全地抛弃。特别是，<span class="label danger">如果在守护线程中执行可能包含I/O操作的任务，那么将是一种危险的行为。</span>守护线程最好用于执行“内部任务”，例如：周期性地从内存的缓存中移除逾期的数据。</p><h4 id="终结器"><a href="#终结器" class="headerlink" title="终结器"></a>终结器</h4><p>由于终结器可以在某个由JVM管理的线程中运行，因此终结器访问的任何状态都可能被多个线程访问，这样就<span class="label danger">必须对其访问操作进行同步。终结器并不能保证它们将在何时运行甚至是否会运行，</span>并且复杂的终结器通常还会在对象上产生巨大的性能开销。要编写正确的终结器是非常困难的。在大多数情况下，通过使用finally代码块和显示的close方法，能够比使用终结器更好地管理资源。唯一例外情况在于：<span class="label info">当需要管理对象，并且该对象持有的资源是通过本地方法获得的。</span></p><span class="label success">避免使用终结器。</span><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="在任务与执行策略之间的隐性耦合"><a href="#在任务与执行策略之间的隐性耦合" class="headerlink" title="在任务与执行策略之间的隐性耦合"></a>在任务与执行策略之间的隐性耦合</h3><span class="label warning">只有当线程本地值的生命周期受限于任务的生命周期时，在线程池的线程中使用ThreadLocal才有意义，而在线程池的线程中不应该使用ThreadLocal在任务之间传递值。</span><br/><span class="label primary">只有当任务是同类型的并且相互独立时，线程池的性能才能达到最佳。</span>如果将运行时间较长的与运行时间较短的任务混合在一起，那么除非线程池很大，否则将可能造成<span class="label danger">拥塞</span>。如果提交的任务依赖于其他任务，那么除非线程池无限大，否则将可能造成<span class="label danger">死锁</span>。<p>只要线程池中的任务需要无限期地等待一些必须由池中其他任务才能提供的资源或条件，例如某个任务等待另一个任务的返回值或执行结果，那么除非线程池足够大，否则将发生线程<span class="label danger">饥饿死锁</span>。</p><p>执行时间较长的任务不仅会造成线程池堵塞，甚至还会增加执行时间较短任务的服务时间。有一项技术可以缓解执行时间较长任务造成的影响，即限定任务等待资源的时间，而不要无限地等待。如果在线程池中总是充满了被阻塞的任务，那么也可能表明线程池的规模过小。</p><h3 id="设置线程池的大小"><a href="#设置线程池的大小" class="headerlink" title="设置线程池的大小"></a>设置线程池的大小</h3><p>对于<strong>计算密集型任务</strong>，在拥有Ncpu个处理器的系统上，当线程池的大小为Ncpu+1时，通常能实现最优的利用率（即使当计算密集型的线程偶尔由于页缺失故障或其他原因而暂停时，这个额外的线程也能确保CPU的时钟周期不会被浪费）。</p><p>对于<strong>包含I/O操作或其他阻塞操作的任务</strong>，由于线程并不会一直执行，因此线程池的规模应该更大。要正确的设置线程池的大小，你必须估算出任务的等待时间与计算时间的比值。这种估算不需要很精确，并且可以通过分析或监控工具获得。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ncpu &#x3D; cpu的数量</span><br><span class="line">Ucpu &#x3D; 目标cpu的利用率，0 ≤ Ucpu ≤ 1</span><br><span class="line">W&#x2F;C &#x3D; 等待时间与计算时间的比率</span><br><span class="line">为保持处理器达到期望的利用率，最优的线程池大小等于：Nthreads &#x3D; Ncpu * Ucpu * (1 + W&#x2F;C)</span><br></pre></td></tr></table></figure><p>也可以通过另一种方法来调节线程池大小：在某个基准负载下，分别设置不同大小的线程池来运行应用程序，并观察CPU利用率的水平。</p><p>当然，CPU周期并不是唯一影响线程池大小的资源，还包括内存、文件句柄、套接字句柄、数据库连接等。计算这些资源对线程池的约束条件更容易：计算每个任务对该资源的需求量，然后用该资源的可用总量除以每个任务的需求量，所得结果就是线程池大小的上限。</p><h3 id="配置ThreadPoolExecutor"><a href="#配置ThreadPoolExecutor" class="headerlink" title="配置ThreadPoolExecutor"></a>配置ThreadPoolExecutor</h3><p>对于<code>Executor</code>，<code>newCachedThreadPool</code>工厂方法是一种很好的默认选择，它能提供比固定大小的线程池更好的排队性能。当需要限制当前任务的数量以满足资源管理需求时，那么可以选择固定大小的线程池，就像在接受网络客户请求的服务器应用程序中，如果不进行限制，那么很容易发生过载问题。</p><span class="label primary">只有任务相互独立时，为线程池或者工作队列设置界限才是合理的。</span>如果任务之间存在依赖性，那么有界的线程池或队列就可能导致线程“饥饿”死锁问题。此时应该使用无界的线程池。<h4 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h4><p>中止（Abort）策略：是默认的饱和策略，该策略将抛出未检查的<code>RejectedExecutionException</code>。<br>抛弃（Discard）策略：会悄悄抛弃该任务。<br>抛弃最旧的（Discard-Oldest）策略：则会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。（<span class="label warning">如果工作队列是一个优先队列，那么“抛弃最旧的”策略将导致抛弃优先级最高的任务，因此最好不要将“抛弃最旧的”饱和策略和优先级队列放在一起使用</span>）。<br>调用者运行（Caller-Runs）策略：实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。它不会在线程池的某个线程中执行新提交的任务，而是在一个调用了<code>execute</code>的线程中执行该任务。由于执行任务需要一定的时间，因此主线程至少在一段时间内不能提交任何任务，从而使得工作者线程有时间来处理正在执行的任务。在这期间，主线程不会调用<code>accept</code>，因此到达的请求将被保存在TCP层的队列而不是在应用程序的队列中。如果持续过载，那么TCP层将最终发现它的请求队列被填满，因此同样会开始抛弃请求。当服务器过载时，这种过载情况会逐渐向外蔓延开来，从线程池到工作队列到应用程序再到TCP层，最终达到客户端，导致服务器在高负载下实现一种平缓的性能降低。</p><h4 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h4><p>线程池需要创建一个线程，都要通过线程工厂方法来完成。默认的线程工厂创建一个新的、非守护的线程，并且不包含特殊的配置信息。<code>ThreadFactory</code>只有唯一的方法：<code>newThread</code>，每当线程池需要创建一个新线程时都会调用该方法。</p><p>许多情况下都需要使用定制的线程工厂方法：为线程池中的线程指定<code>UncaughtExceptionHandler</code>；实例化一个定制的<code>Thread</code>类用于执行调试信息的记录；给线程取一个更有意义的名称等。</p><p>如果在应用程序中需要利用安全策略来控制对某些特殊代码库的访问权限，那么可以通过<code>Executor</code>中的<code>privilegedThreadFactory</code>工厂来定制自己的线程工厂。</p><p>如果<code>Executor</code>是通过<code>Executors</code>中的某个工厂方法创建的，那么可以将结果的类型强转为<code>ThreadPoolExecutor</code>以访问设置器，在构造后更改其属性。</p><p>在<code>Executors</code>中包含一个<code>unconfigurableExecutorService</code>工厂方法，该方法对一个现有的<code>ExecutorService</code>进行包装，使其只暴露出<code>ExecutorService</code>的方法，因此不能对其进行配置。</p><h3 id="扩展ThreadPoolExecutor"><a href="#扩展ThreadPoolExecutor" class="headerlink" title="扩展ThreadPoolExecutor"></a>扩展ThreadPoolExecutor</h3><p><code>ThreadPoolExecutor</code>是可扩展的，它提供了<code>beforeExecute</code>，<code>afterExecute</code>和<code>terminated</code>方法可用于扩展其行为。</p><p>无论任务是从<code>run</code>中正常返回，还是抛出一个异常而返回，<code>afterExecute</code>都会被调用（如果任务在完成后带有一个<code>Error</code>，那么就不会调用<code>afterExecute</code>）。如果<code>beforeExecute</code>抛出一个<code>RuntimeException</code>，那么任务将不被执行，并且<code>afterExecute</code>也不会被调用。</p><span class="label success">当串行循环中的各个迭代操作之间彼此独立，并且每个迭代操作执行的工作量比管理一个新任务时带来的开销更多，那么这个串行循环就适合并行化。</span><h2 id="性能与可伸缩性"><a href="#性能与可伸缩性" class="headerlink" title="性能与可伸缩性"></a>性能与可伸缩性</h2><h3 id="对性能的思考"><a href="#对性能的思考" class="headerlink" title="对性能的思考"></a>对性能的思考</h3><p>要想通过并发来获得更好的性能，需要努力做好两件事情：更有效地利用现有处理资源，以及在出现新的处理资源时使程序尽可能地利用这些新资源。</p><p>可伸缩性：当增加计算资源时（例如CPU、内存、存储容量或I\O带宽），程序的吞吐量或者处理能力能相应地增加。</p><p>避免不成熟的优化。首先使程序正确，然后再提高运行速度——如果它运行得还不够快。</p><p>在大多数性能决策中都包含有多个变量，并且非常依赖于运行环境。<span class="label primary">在使某个方案比其他方案“更快”之前，首先问自己一些问题：</span></p><ul><li>“更快”的含义是什么？</li><li>该方法在什么条件下运行得更快？在低负载还是高负载的情况下？大数据集还是小数据集？能否通过测试结果来验证你的答案？</li><li>这些条件在运行环境中的发生频率？能否通过测试结果来验证你的答案？</li><li>在其他不同条件的环境中能否使用这里的代码？</li><li>在实现这种性能提升时需要付出哪些隐含地代价，例如增加开发风险或维护开销？这种权衡是否合适？</li></ul><p>在对性能的调优时，一定要有明确的性能需求（这样才能知道什么时候需要调优，以及什么时候应该停止），此外还需要一个测试程序以及真实地配置和负载等环境。在对性能调优后，你需要再次测量以验证是否到达了预期的性能提升目标。</p><span class="label warning">以测试为基准，不要猜测。</span><h3 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h3><p>Amdahl定律：在增加计算资源的情况下，程序在理论上能够实现最高加速比，这个值取决于程序中可并行组件与串行组件所占的比重。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">最高加速比：Speedup &lt;&#x3D; 1 &#x2F; (F + (1 - F) &#x2F; N)</span><br><span class="line">处理器利用率：Speedup &#x2F; N</span><br><span class="line"></span><br><span class="line">N: 处理器的个数</span><br><span class="line">F: 必须被串行执行的部分</span><br></pre></td></tr></table></figure><p>当N趋近无穷大时，最大的加速比趋近于1/F。程序串行的部分越少，增加计算资源时，能够达到的最高加速比越大。</p><p>在所有并发程序中都包含一些串行部分。如果你认为你的程序中不存在串行部分，那么可以再仔细检查一遍。</p><p>Amdahl定律告诉我们：<span class="label primary">程序的可伸缩性取决于所有代码中必须被串行执行的代码比例。</span></p><h3 id="线程引入的开销"><a href="#线程引入的开销" class="headerlink" title="线程引入的开销"></a>线程引入的开销</h3><ul><li><p>上下文切换<br>  在程序中发生越多的阻塞（包括阻塞I/O，等待获取发生竞争的锁，或者在条件变量上等待），与CPU密集型的程序就会发生越多的上下文交换，从而增加调度开销，并因此而降低吞吐量。</p></li><li><p>内存同步<br>  现代的JVM能够通过优化去掉一些不会发生竞争的锁，从而减少不必要的同步开销。</p><p>  不要过度担心非竞争同步带来的开销。这个基本的机制已经非常快了，并且JVM还能进行额外的优化以进一步降低或消除开销。因此，<span class="label success">我们应该将优化重点放在那些发生锁竞争的地方。</span></p></li><li><p>阻塞<br>  非竞争的同步可以完全在JVM中进行处理，而竞争的同步可能需要操作系统的介入，从而增加开销。</p></li></ul><h3 id="减少锁的竞争"><a href="#减少锁的竞争" class="headerlink" title="减少锁的竞争"></a>减少锁的竞争</h3><span class="label danger">在并发程序中，对可伸缩性的最主要威胁就是独占方式的资源锁。</span><p>有两个因素将影响在锁上发生竞争的可能性：<strong>锁的请求频率</strong>，以及<strong>每次持有该锁的时间</strong>。如果二者的乘积很小，那么大多数获取锁的操作都不会发生竞争，因此在该锁上的竞争不会对可伸缩性造成严重的影响。然而，如果在锁上的请求量很高，那么需要获取该锁的线程被阻塞等等待。在极端的情况下，即使仍有大量工作等待完成，处理器也会被闲置。</p><span class="label primary">有3种方式可以降低锁的竞争程度：</span><ul><li>减少锁的持有时间。</li><li>降低锁的请求频率。</li><li>使用带有协调机制的独占锁（非独占/非阻塞锁），这些机制允许更高的并发性。</li></ul><h4 id="缩小锁的范围"><a href="#缩小锁的范围" class="headerlink" title="缩小锁的范围"></a>缩小锁的范围</h4><p>降低发生竞争可能性的一种有效方式就是<strong>尽可能缩短锁的持有时间</strong>。例如，可以将一些与锁无关的代码移除同步代码块，尤其是那些开销比较大的操作，以及可能被阻塞的操作，例如I/O操作。</p><p>尽管缩小同步代码块能提高可伸缩性，但同步代码快也不能过小——一些需要采用原子方式执行的操作（例如对某个不变性条件中的多个变量进行更新）必须包含在一个同步块中。此外，同步需要一定的开销，当把一个同步代码块分解为多个同步代码块时（在确保正确性的情况下），反而会对性能提升产生负面影响。在分解同步代码块时，理想的平衡点将与平台相关，但在实际情况中，仅当可以将一些“大量”的计算或阻塞操作从同步代码块中移出时，才应该考虑同步代码块的大小。</p><h4 id="减小锁的粒度"><a href="#减小锁的粒度" class="headerlink" title="减小锁的粒度"></a>减小锁的粒度</h4><p>另一种减小锁的持有时间的方式是<strong>降低线程请求锁的频率</strong>（从而减小发生竞争的可能性）。这可以通过<strong>锁分解</strong>和<strong>锁分段</strong>技术来实现，在这些技术中将采用多个相互独立的锁来保护独立的状态变量，从而改变这些变量在之前由单个锁来保护的情况。这些技术能减小锁操作的粒度，并能实现更高的可伸缩性，然而，使用的锁越多那么发生死锁的风险也越高。</p><p>如果一个锁需要保护多个相互独立的状态变量，那么可以将这个锁分解为多个锁，并且每个锁只保护一个变量，从而提高可伸缩性，并最终降低每个锁被请求的频率。</p><h4 id="锁分段"><a href="#锁分段" class="headerlink" title="锁分段"></a>锁分段</h4><p>锁分段的一个劣势在于：<span class="label warning">与采用单个锁来实现独占访问相比，要获取多个锁来实现独占访问将更加困难并且开销更高。</span>例如：java7 ConcurrentHashMap扩容重哈希时需要获取分段锁集合中的所有锁。</p><h4 id="避免热点域"><a href="#避免热点域" class="headerlink" title="避免热点域"></a>避免热点域</h4><p>当每个操作都请求多个变量时，锁的粒度将很难降低。这是在性能与可伸缩性之间相互制衡的另一个方面，一些常见的优化措施，例如将一些反复计算的结果缓存起来，都会引入一些“热点域”，而这些热点域往往会限制可伸缩性。</p><h4 id="一些替代独占锁的方法"><a href="#一些替代独占锁的方法" class="headerlink" title="一些替代独占锁的方法"></a>一些替代独占锁的方法</h4><p>第三种降低竞争锁的影响的技术就是<strong>放弃使用独占锁</strong>，从而有助于使用一种友好并发的方式来管理共享状态。例如，使用并发容器、读-写锁、不可变对象以及原子变量。</p><p>如果在类中只包含少量的热点域，并且这些域不会与其他变量参与到不变性条件中，那么用原子变量来替代他们能提高可伸缩性。（通过减少算法中的热点域，可以提高可伸缩性——虽然原子变量能降低热点域的更新开销，但并不能完全消除。）</p><h4 id="监测CPU的利用率"><a href="#监测CPU的利用率" class="headerlink" title="监测CPU的利用率"></a>监测CPU的利用率</h4><p>当测试可伸缩性时，通常要确保处理器得到充分利用。可用工具如：UNIX系统上的<code>vmstat</code>和<code>mpstat</code>，或者Windows系统上的<code>perfmon</code>。</p><p>如果所有CPU的利用率并不均匀（有些CPU在忙碌地运行，而其他CPU却并非如此），那么你的首要目标就是进一步找出程序中的并行性。不均匀的利用率表明大多数计算都是由一小组线程完成的，并且应用程序没有利用其他的处理器。如果CPU没有得到充分利用，那么需要找出其中的原因。通常由以下几种原因：</p><ul><li>负载不充足</li><li>I/O密集</li><li>外部限制</li><li>锁竞争</li></ul><blockquote><p>在<code>vmstat</code>命令的输出中，有一栏信息是当前处于可运行状态但并没有运行（由于没有足够的CPU）的线程数量。</p></blockquote><h4 id="向对象池说“不”"><a href="#向对象池说“不”" class="headerlink" title="向对象池说“不”"></a>向对象池说“不”</h4><span class="label primary">通常，对象分配操作的开销比同步的开销更低。</span><h3 id="减少上下文切换的开销"><a href="#减少上下文切换的开销" class="headerlink" title="减少上下文切换的开销"></a>减少上下文切换的开销</h3><p>当任务在<em>运行</em>和<em>阻塞</em>这两个状态之间转换时，就相当于一次上下文切换。在锁获取操作上发生竞争时将导致更多的上下文切换。</p><h2 id="并发程序的测试"><a href="#并发程序的测试" class="headerlink" title="并发程序的测试"></a>并发程序的测试</h2><p>并发测试大致分为两类：安全性测试和活跃性测试。</p><p>安全性：不发生任何错误的行为。<br>活跃性：某个良好的行为终究会发生。<br>吞吐量：指一组并发任务中已完成任务所占的比例。<br>响应性：指请求从发出到完成之间的时间（也被称为延迟）。<br>可伸缩性：指在增加更多资源的情况下（通常指CPU），吞吐量的提升情况。</p><h3 id="正确性测试"><a href="#正确性测试" class="headerlink" title="正确性测试"></a>正确性测试</h3><p>在为某个并发类设计单元测试时，首先需要执行与测试串行类时相同的分析——<span class="label primary">找出需要检查的不变性条件和后验条件。</span></p><p>要测试在生产者—消费者模式中使用的类，一种有效的方法就是检查放入队列中和从队列中取出的各个元素。</p><p>测试单生产者—单消费者方法：通过一个对顺序敏感的检验和和计算函数来计算所有入队元素以及出队元素的校验和，并进行比较。如果两者相等，则测试就是成功的。</p><p>测试多生产者—多消费者方法：通过一个对元素入列/出列顺序不敏感的校验和计算函数，从而在测试程序运行完以后，可以将多个校验和以不同的顺序组合起来。</p><p>对于任何持有或管理其他对象的对象，都应该在不需要这些对象时销毁对它们的引用。这种存储资源泄露不仅会妨碍垃圾回收器回收内存（或线程、文件句柄、套接字、数据库连接或其他有限资源），而且还会导致资源耗尽以及应用程序失败。</p><p>在构造测试案例时，对客户提供的代码进行回调是非常有帮助的。回调函数的执行通常是在对象生命周期的一些已知位置上，并且在这些位置上非常适合判断不变性条件是否被破坏。例如，在<code>ThreadPoolExecutor</code>中将调用任务的<code>Runnable</code>和<code>ThreadFactory</code>。</p><p>由于并发代码中的大多数错误都是一些低概率事件，因此在测试并发错误时需要反复地执行许多次，但有些方法可以提高发现这些错误的概率。有一种有用的方法可以提高交替操作的数量，以便能更有效地搜索程序的状态空间：在访问共享状态的操作中，使用<code>Thread.yield</code>将产生更多的上下文切换。</p><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>性能测试将衡量典型测试用例中的端到端性能。通常要获得一组合理的使用场景并不容易，理想情况下，在测试中应该反映出被测试对象在应用程序中的实际用法。</p><p>根据经验值来调整各种不同的限值，如线程数，缓存容量等。这些限值可能依赖于具体平台的特性（例如：处理器的类型、处理器的步进级别、CPU的数量、内存大小等），因此需要动态地进行配置，而我们通常需要合理地选择这些值，从而使程序能够在更多的系统上良好地运行。</p><h3 id="避免性能测试陷阱"><a href="#避免性能测试陷阱" class="headerlink" title="避免性能测试陷阱"></a>避免性能测试陷阱</h3><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>防止垃圾回收操作对测试结果产生偏差：</p><ul><li>确保垃圾回收操作在测试的整个期间都不会执行（可以在调用JVM时指定<code>-verbose: gc</code>来判断是否执行了垃圾回收操作）。</li><li>确保垃圾回收操作在测试期间执行多次，这样测试程序就能充分反映出运行期间的内存分配与垃圾回收的开销（更长的测试时间）。</li></ul><h4 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h4><p>当某个类第一次被加载时，JVM会通过解释字节码的方式来执行它，在某个时刻，如果一个方法运行的次数足够多，那么动态编译器会将它编译为机器代码，当编译完成后，代码的执行方式将从解释执行变成直接执行。</p><p>基于各种原因，代码还可能被反编译（退回到解释执行）以及重新编译，例如加载了一个会是编译假设无效的类，或者在收集了足够的分析信息后，决定采用不同的优化措施来重新编译某条代码路径。</p><p>防止动态编译对测试结果产生偏差：</p><ul><li>使程序运行足够长的时间（至少数分钟），这样编译过程以及解释执行都只是总运行时间的很小一部分。</li><li>使代码预先运行一段时间并且不测试这段时间内的代码性能，这样在开始计时前代码就已经被完全编译了。</li></ul><h4 id="对代码路径的不真实采样"><a href="#对代码路径的不真实采样" class="headerlink" title="对代码路径的不真实采样"></a>对代码路径的不真实采样</h4><p>运行时编译器根据收集到的信息对已编译的代码进行优化。例如，如果当前已加载的类都没有改写某个方法，那么JVM会通过单一调用转换将虚拟方法调用转换为直接方法调用。但如果后来加载了一个改写了该方法的类，那么之前已编译的代码将失效。</p><h4 id="不真实的竞争程度"><a href="#不真实的竞争程度" class="headerlink" title="不真实的竞争程度"></a>不真实的竞争程度</h4><p>要获得有实际意义的测试结果，就需要模拟最接近正式环境的并发量和竞争程度。</p><h4 id="无用的代码消除"><a href="#无用的代码消除" class="headerlink" title="无用的代码消除"></a>无用的代码消除</h4><p>优化编译器能找出并消除那些不会对输出结果产生任何影响的无用代码。</p><p>避免算法被优化掉而又不会引入过高的开销：</p><ul><li>计算某个派生对象中域的散列值，并将它与一个任意值进行比较。如<code>System.nanoTime</code>的当前值，如果二者碰巧相等，那么就输出一个无用并且可以被忽略的消息。</li></ul><p>不仅每个计算结果都应该被使用，而且还应该是不可预测的，否则，一个智能的动态优化编译器将用预先计算的结果来代替计算过程。</p><h3 id="其他的测试方法"><a href="#其他的测试方法" class="headerlink" title="其他的测试方法"></a>其他的测试方法</h3><p>质量保证的目标应该是<span class="label primary">在给定的测试资源下实现最高的可信度。</span></p><p>代码审查、静态分析工具（如FindBugs）、面向切面的测试技术、分析与监测工具（如JMX的<code>ThreadInfo</code>）。</p><hr><ul><li><em>《Java并发编程实战》</em></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程安全性&quot;&gt;&lt;a href=&quot;#线程安全性&quot; class=&quot;headerlink&quot; title=&quot;线程安全性&quot;&gt;&lt;/a&gt;线程安全性&lt;/h2&gt;&lt;p&gt;要编写线程安全的代码，核心在于&lt;span class=&quot;label primary&quot;&gt;要对状态访问操作进行管理&lt;/span&gt;，特别是对&lt;strong&gt;共享的&lt;/strong&gt;和&lt;strong&gt;可变的&lt;/strong&gt;状态的访问。&lt;/p&gt;
&lt;p&gt;当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。&lt;/p&gt;
&lt;p&gt;如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不在线程之间共享该状态变量。&lt;/li&gt;
&lt;li&gt;将状态变量修改为不可变的变量。&lt;/li&gt;
&lt;li&gt;在访问状态变量时使用同步。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="http://xiaojiaC.github.io/blog/categories/JAVA/"/>
    
      <category term="读书笔记" scheme="http://xiaojiaC.github.io/blog/categories/JAVA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://xiaojiaC.github.io/blog/tags/java/"/>
    
      <category term="concurrency" scheme="http://xiaojiaC.github.io/blog/tags/concurrency/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程的艺术</title>
    <link href="http://xiaojiac.github.io/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF.html"/>
    <id>http://xiaojiac.github.io/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF.html</id>
    <published>2020-03-14T11:55:32.000Z</published>
    <updated>2023-10-18T13:45:27.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发编程的挑战"><a href="#并发编程的挑战" class="headerlink" title="并发编程的挑战"></a>并发编程的挑战</h2><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>上下文切换：CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</p><a id="more"></a><div class="tabs" id="上下文切换"><ul class="nav-tabs"><li class="tab active"><a href="#上下文切换-1">减少方法</a></li><li class="tab"><a href="#上下文切换-2">实践案例</a></li><li class="tab"><a href="#上下文切换-3">分析工具</a></li></ul><div class="tab-content"><div class="tab-pane active" id="上下文切换-1"><ul><li>无锁并发编程</li><li>CAS算法</li><li>使用最少线程</li><li>使用协程</li></ul></div><div class="tab-pane" id="上下文切换-2"><ul><li>减少<span class="label warning">WAITTING</span>线程数，因为每一次从<span class="label warning">WAITTING</span>到<span class="label danger">RUNNABLE</span>都会进行一次上下文的切换。</li></ul></div><div class="tab-pane" id="上下文切换-3"><p><code>vmstat</code></p></div></div></div><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁：多个进程在执行过程中，因争夺同类资源且资源分配不当而造成的一种互相等待的现象，若无外力作用，它们都将永远无法继续执行，这种状态称为死锁。</p><div class="tabs" id="死锁"><ul class="nav-tabs"><li class="tab active"><a href="#死锁-1">产生原因</a></li><li class="tab"><a href="#死锁-2">必要条件</a></li><li class="tab"><a href="#死锁-3">规避方法</a></li><li class="tab"><a href="#死锁-4">分析工具</a></li></ul><div class="tab-content"><div class="tab-pane active" id="死锁-1"><ul><li>不可剥夺资源的竞争<blockquote><p>可剥夺资源：某进程在获得该类资源时，该资源同样可以被其他进程或系统剥夺。<br>不可剥夺资源：系统把该类资源分配给某个进程时不能强制收回，只能在该进程使用完成后自动释放。</p></blockquote></li><li>进程推进顺序不当</li></ul></div><div class="tab-pane" id="死锁-2"><ul><li>互斥条件：一个资源每次只能被一个进程使用。</li><li>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li></ul></div><div class="tab-pane" id="死锁-3"><ul><li>避免一个线程同时获取多个锁</li><li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源</li><li>尝试使用定时锁来替代使用内部锁机制</li><li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况</li><li>避免对长时间的计算任务和阻塞的I/O操作加锁</li></ul></div><div class="tab-pane" id="死锁-4"><p><code>jps</code>, <code>jstack $pid</code></p></div></div></div><h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>活锁：任务或者执行者没有被阻塞，但由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败，……</p><p>规避方法:</p><ul><li>引入一些随机性</li><li>约定重试机制避免再次冲突</li></ul><h3 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h3><p>硬件资源限制：可以考虑使用集群并行执行程序。<br>软件资源限制：可以考虑使用资源池将资源复用。</p><h2 id="java并发机制的底层实现原理"><a href="#java并发机制的底层实现原理" class="headerlink" title="java并发机制的底层实现原理"></a>java并发机制的底层实现原理</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><table><thead><tr><th>术语</th><th>释义</th></tr></thead><tbody><tr><td>内存屏障</td><td>一组处理器指令，由于实现对内存操作的顺序限制。</td></tr><tr><td>原子操作</td><td>不可中断的一个或一系列操作。</td></tr><tr><td>缓存行</td><td>缓存中可以分配的最小存储单位。处理器填写缓存线时会加载整个缓存线，需要使用多个主内存读周期。</td></tr><tr><td>缓存行填充</td><td>当处理器识别到从主存中读取的操作数是可缓存的，处理器读取整个缓存行到适当的缓存中（L1,L2,L3或所有）。</td></tr><tr><td>缓存命中</td><td>如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的内存地址，处理器从缓存中读取操作数，而不是从主存中读取。</td></tr><tr><td>写命中</td><td>当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存，这个操作被称为写命中。</td></tr><tr><td>写缺失</td><td>一个有效的缓存行被写入到不存在的内存区域。</td></tr><tr><td>CPU流水线</td><td>工作方式就像工业生产中的装配流水线，在CPU中由5<del>6个不同功能的电路单元组成一条指令处理流水线，然后将一条x86指令拆分为5</del>6步再由这些电路单元分别执行，这样就能实现一个CPU时钟周期内完成一条指令，因此提高CPU的运算速度。</td></tr><tr><td>内存顺序冲突</td><td>一般由假共享引起，假共享是指多个CPU同时修改同一个缓存行的不同部分而引起其中一个CPU操作无效，当出现这个内存顺序冲突时，CPU必须清空流水线。</td></tr></tbody></table><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p><code>volatile</code>变量修饰的共享变量进行写操作的时候会多出一个<em>lock前缀的指令</em>，该指令在多核处理器下会引发：</p><ol><li>将当前处理器缓存行的数据回写到系统内存。</li><li>这个回写内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li></ol><p>实现原理：</p><blockquote><p>声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p></blockquote><p>为什么<code>LinkedTransferQueue</code>中头、尾volatile变量追加64字节能够提高并发编程的效率呢？</p><p>大部分处理器高速缓存行是64个字节宽，且不支持部分填充缓存行。使用追加到64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，使头、尾节点在修改时不会互相锁定。</p><p>是不是在使用<code>volatile</code>变量时都应该追加到64字节呢？<strong>并非如此</strong>，在两种场景下不应该使用这种方式：</p><ul><li>缓存行非64字节宽的处理器</li><li>共享变量不会被频繁地写</li></ul><div class="note warning">            <p>不过这种追加字节的方式在Java 7下可能不生效，因为Java 7变得更加智慧，它会淘汰或重新排列无用字段，需要使用其他追加字节的方式。</p>          </div><div class="note info">            <p>你可能想看这里: <a href="https://blog.csdn.net/aigoogle/article/details/41517213" target="_blank" rel="noopener">神奇的缓存行填充</a></p>          </div><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>实现原理：</p><blockquote><p>JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用<code>monitorenter</code>和<code>monitorexit</code>指令实现的，而方法同步是使用另外一种方式实现的（方法修饰符上的<code>ACC_SYNCHRONIZED</code>），细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。<code>monitorenter</code>指令是在编译后插入到同步代码块的开始位置，而<code>monitorexit</code>是插入到方法结束处和异常处，JVM要保证每个<code>monitorenter</code>必须有对应的<code>monitorexit</code>与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到<code>monitorenter</code>指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。</p></blockquote><p><code>synchronized</code>用的锁是存在Java对象头里的。其存储结构如下示：</p><p>第一部分：</p><img src="/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/markword-32bit-vm.PNG" class=""><img src="/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/markword-64bit-vm.PNG" class=""><p>第二部分：<br>类型指针，即对象指向类元数据的指针，虚拟机通过这个指针来确定对象是哪个类的实例。但并不是所有虚拟机实现都需要在对象头上保持类型指针。因为有的虚拟机使用<em>句柄</em>进行对象访问定位，而不是<em>直接指针</em>访问。</p><p>第三部分：<br>如果对象是一个java数组，那么在对象头中还必须有一块用于记录数组长度的数据。可能是对齐填充，并不是必要存在的，也没有特别含义，仅起占位符的作用。</p><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：<strong>无锁状态</strong>、<strong>偏向锁状态</strong>、<strong>轻量级锁状态</strong>和<strong>重量级锁</strong>状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。</p><img src="/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/synchonized.png" class=""><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>原子操作：不可被中断的一个或一系列操作。</p><p>处理器如何实现原子操作：</p><ul><li>通过总线锁保证原子性（总线上声明<code>lock#</code>信号）</li><li>通过缓存锁定来保证原子性（修改内部的内存地址+缓存一致性机制使<em>单个</em>缓存行无效）</li></ul><p>Java如何实现原子操作：</p><ul><li>使用循环CAS<ul><li>ABA问题：解决方法追加版本号，可参考<code>AtomicStampedReference</code></li><li>循环时间长开销大</li><li>只能保证一个共享变量的原子操作：解决方法使用锁替换或把多个共享变量合并成一个共享变量来操作，可参考<code>AtomicReference</code></li></ul></li><li>使用锁机制</li></ul><h2 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h2><h3 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h3><p>命令式编程中，线程之间的通信机制有两种：<strong>共享内存</strong>和<strong>消息传递</strong>。</p><p>从源代码到指令序列可能发生哪些重排序？</p><ul><li>编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序：如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。<blockquote><p>如果两个操作访问<em>同一个变量</em>，且这两个操作中<em>有一个为写操作</em>，此时这两个操作之间就存在数据依赖性。</p></blockquote></li><li>内存系统的重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ul><img src="/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/code-to-instruction-reorder.PNG" class="" title="源代码到指令序列的重排序"><p>Java线程之间的通信由<em>Java内存模型</em>控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。确保在不同的编译器和不同的处理器平台之上，为程序员提供一致的内存可见性保证。</p><p>对于编译器重排序，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。<br>对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入内存屏障指令来禁止特定类型的处理器重排序。</p><div class="note info">            <p>常见的处理器（基本都有写缓冲区）都允许Store-Load重排序；都不允许对存在数据依赖的操作做重排序。</p>          </div><h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><p>as-if-serial语义：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</p><h3 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h3><p>顺序一致性内存模型有哪些特性？</p><ul><li>一个线程中的所有操作必须按照程序的顺序串行执行。</li><li>（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li></ul><p>在JMM中，临界区内的代码可以重排序（但JMM不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。<br>JMM不保证对64位的long型和double型变量的写操作具有原子性。</p><h3 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h3><p>理解volatile特性的一个好方法是：把对volatile变量的单个读/写，看成是使用<strong>同一个锁</strong>对这些<strong>单个</strong>读/写操作做了同步。</p><p>这意味着，1. 对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。2. 即使是64位的long型和double型变量，只要它是volatile变量，对该变量的单个读/写就具有原子性。</p><p>内存屏障：</p><p>硬件层的内存屏障分为两种：<code>Load Barrier</code> 和 <code>Store Barrier</code> 即读屏障和写屏障。</p><div class="tabs" id="内存屏障"><ul class="nav-tabs"><li class="tab active"><a href="#内存屏障-1">作用</a></li><li class="tab"><a href="#内存屏障-2">分类</a></li><li class="tab"><a href="#内存屏障-3">java中的分类</a></li></ul><div class="tab-content"><div class="tab-pane active" id="内存屏障-1"><ol><li>阻止屏障两侧的指令重排序；</li><li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效（必须从主内存从新加载）。</li></ol></div><div class="tab-pane" id="内存屏障-2"><ul><li>对于<code>Load Barrier</code>来说，在指令前插入<code>Load Barrier</code>，可以让高速缓存中的数据失效，强制从新从主内存加载数据；</li><li>对于<code>Store Barrier</code>来说，在指令后插入<code>Store Barrier</code>，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。</li></ul></div><div class="tab-pane" id="内存屏障-3"><img src="/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/java-memory-barrier.PNG" class=""></div></div></div><p>volatile的编译器重排序规则：</p><ul><li>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</li><li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。</li><li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。</li></ul><p>volatile的处理器内存屏障插入策略：</p><ul><li>在每个volatile写操作的前面插入一个<code>StoreStore</code>屏障。</li><li>在每个volatile写操作的后面插入一个<code>StoreLoad</code>屏障。</li><li>在每个volatile读操作的后面插入一个<code>LoadLoad</code>屏障。</li><li>在每个volatile读操作的后面插入一个<code>LoadStore</code>屏障。</li></ul><div class="note ">            <p>我的疑惑：为什么不需要在每个volatile写操作的前面插入一个LoadStore屏障，来防止第一个普通读和第二个volatile写操作重排序？？？</p><p>假设volatile写之前如果加上LoadStore屏障的效果是什么？</p><ol><li>普通读–volatile写 禁止重排序</li><li>volatile读–volatile写 禁止重排序</li></ol><p>对于第2点，因为volatile读之后有LoadStore屏障，就已经达到了禁止重排序的效果。<br>对于第1点，volatile的写操作的内存语义与释放锁相同，即会刷新该线程的写缓冲到内存中，而普通变量读根本不涉及到写缓冲，所以即使重排序了也不会破坏volatile的内存语义。<br>所以，不需要在volatile的写操作前加LoadStore屏障。</p>          </div><h3 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h3><p>在<code>ReentrantLock</code>中，调用<code>lock()</code>方法获取锁；调用<code>unlock()</code>方法释放锁。</p><p>加锁方法首先读volatile变量<code>state</code>，在释放锁的最后写volatile变量<code>state</code>。根据volatile的happens-before规则，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变得对获取锁的线程可见。</p><p>获取锁中的CAS又如何同时具有volatile读和volatile写的内存语义？</p><p>从编译器角度：<br>编译器不会对volatile读与volatile读后面的任意内存操作重排序；编译器不会对volatile写与volatile写前面的任意内存操作重排序。组合这两个条件，意味着为了同时实现volatile读和volatile写的内存语义，编译器不能对CAS与CAS前面和后面的任意内存操作重排序。</p><p>从处理器角度：<br>在常见的intel X86处理器中，源码中会根据当前处理器的类型来决定是否为<code>cmpxchg</code>指令添加<code>lock</code>前缀。lock前缀的第2点和第3点所具有的内存屏障效果，足以同时实现volatile读和volatile写的内存语义。</p><blockquote><p>intel的手册对lock前缀的说明: 1. 确保对内存的读-改-写操作原子执行。2. 禁止该指令，与之前和之后的读和写指令重排序。3. 把写缓冲区中的所有数据刷新到内存中。</p></blockquote><p>综上述，可见<code>ReentrantLock</code>内存语义实现利用了volatile变量的写-读所具有的内存语义和CAS所附带的volatile读和volatile写的内存语义。</p><h3 id="final域的内存语义"><a href="#final域的内存语义" class="headerlink" title="final域的内存语义"></a>final域的内存语义</h3><p>final域的编译器重排序规则：</p><ul><li>在构造函数内对一个final域/final域引用的对象成员域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li><li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</li></ul><p>final域的处理器内存屏障插入策略：</p><ul><li>编译器会在final域的写之后，构造函数return之前，插入一个<code>StoreStore</code>屏障。禁止处理器把final域的写重排序到构造函数之外。</li><li>编译器会在读final域操作的前面插入一个<code>LoadLoad</code>屏障。禁止处理器把存在间接依赖关系的操作做重排序。</li></ul><p>final域为引用类型时，若多个线程同时访问其内的可变状态变量，仍需要使用同步原语（lock或volatile）来确保内存可见性。</p><div class="note danger">            <p><code>final</code>引用不能从构造函数内“逸出”。</p>          </div><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>happens-before定义：</p><p>JMM对程序员的<span class="label danger">承诺</span>：如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</p><p>JMM对编译器和处理器重排序的<span class="label danger">约束原则</span>：两个操作之间存在happens-before关系，<u>并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行</u>。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（即JMM允许这种重排序）。</p><p>happens-before规则：</p><ul><li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li><li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li><li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li><li><code>start()</code>规则：如果线程A执行操作<code>ThreadB.start()</code>（启动线程B），那么A线程的<code>ThreadB.start()</code>操作happens-before于线程B中的任意操作。</li><li><code>join()</code>规则：如果线程A执行操作<code>ThreadB.join()</code>并成功返回，那么线程B中的任意操作happens-before于线程A从<code>ThreadB.join()</code>操作成功返回。</li><li>中断法则：一个线程调用另一个线程的<code>interrupt()</code> happens-before于被中断的线程发现中断。</li><li>终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。</li><li>传递性规则：如果A happens-before B，且B happens-before C，那么A happens-before C。</li></ul><a class="btn" href="#as-if-serial语义">            as-if-serial语义          </a>保证单线程内程序的执行结果不被改变，<a class="btn" href="#happens-before">            happens-before关系          </a>保证正确同步的多线程程序的执行结果不被改变。<h2 id="java并发编程的基础"><a href="#java并发编程的基础" class="headerlink" title="java并发编程的基础"></a>java并发编程的基础</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><div class="note danger">            <p>线程优先级不能作为程序正确性的依赖，因为操作系统可以完全不用理会Java线程对于优先级的设定。</p>          </div><h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><table><thead><tr><th><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html" target="_blank" rel="noopener">线程状态</a></th><th>含义</th><th>诱发动作</th></tr></thead><tbody><tr><td>NEW</td><td>新建线程对象，但尚未启动（<code>start()</code>）</td><td><code>new Thread()</code></td></tr><tr><td>RUNNABLE</td><td>一个可运行的线程，包含就绪（等待系统调度分配cpu时间片）和运行中（获得cpu时间片开始运行）两种状态。</td><td>Ready: <code>Thread.yield()</code>, Running: 被线程调度器选择</td></tr><tr><td>BLOCKED</td><td>被阻塞等待监视器锁。</td><td>IO阻塞, 等待进入同步代码块或方法</td></tr><tr><td>WAITING</td><td>无限期等待另一个线程执行一个特定操作（通知或中断）。</td><td><code>Object.wait()</code>, <code>Thread.join()</code>, <code>LockSupport.park()</code></td></tr><tr><td>TIMED_WAITING</td><td>具有指定等待时间，可以在指定的时间内自行返回。</td><td><code>Thread.sleep(long)</code>,  <code>Object.wait(long timeout)</code>,  <code>Thread.join(long timeout)</code>,  <code>LockSupport.parkNanos(Object blocker, long nanos)</code>, <code>LockSupport.parkUntil(Object blocker, long deadline)</code></td></tr><tr><td>TERMINATED</td><td>线程已经执行完毕。</td><td><code>run()</code>退出, <code>Thread.stop()</code>, 线程中断退出,  阻塞IO被关闭</td></tr></tbody></table><img src="/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/thread-state-transition.png" class="" title="线程状态变迁图"><h4 id="Daemon线程"><a href="#Daemon线程" class="headerlink" title="Daemon线程"></a>Daemon线程</h4><p>可以通过调用<code>Thread.setDaemon(true)</code>将线程设置为Daemon线程，<u>但需要在启动线程之前设置</u>。</p><p>当Java虚拟机中不存在非Daemon线程时，虚拟机将会退出。Java虚拟机中的所有Daemon线程都需要立即终止。因此在构建Daemon线程时，<u>不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑</u>。</p><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p><code>thread.start()</code>：启动线程。启动一个线程前，<span class="label primary">最好为这个线程设置线程名称</span>，因为这样便于使用jstack分析程序或者进行问题排查。<br><code>thread.isInterrupted()</code>：判断线程是否被中断。</p><ul><li>如果线程已经处于终结状态，即使被中断过，在调用该线程对象的<code>isInterrupted()</code>时依旧会返回false。</li><li>从Java的API中可以看到，许多声明抛出<code>InterruptedException</code>的方法（例如：<code>Thread.sleep(long millis)</code>方法）在抛出<code>InterruptedException</code>之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出<code>InterruptedException</code>，此时调用<code>isInterrupted()</code>方法将会返回false。</li></ul><p><code>Thread.interrupted()</code>：对当前线程的中断标识位进行复位。<br><del><code>thread.suspend()</code></del>：在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。<br><del><code>thread.stop()</code></del>：在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。<br><del><code>thread.sleep()</code></del>：也是占有着资源进入睡眠状态，而<code>Object.wait()</code>则相反。<br><code>thread.yield()</code>：使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。cpu调度器会从众多的可执行态里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到了。<br>threadA执行<code>threadB.join()</code>：当前线程A等待线程B终止之后才从<code>threadB.join()</code>返回。原理利用了等待/通知机制，threadB终止之后会调用线程自身的<code>notifyAll()</code>方法，通知所有等待在该线程对象上的线程。</p><h4 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h4><ol><li>使用<code>wait()</code>、<code>notify()</code>和<code>notifyAll()</code>时需要先对调用对象加锁。</li><li>调用<code>wait()</code>方法后，线程状态由<code>RUNNING</code>变为<code>WAITING</code>，并将当前线程放置到对象的<strong>等待队列</strong>。</li><li><code>notify()</code>或<code>notifyAll()</code>方法调用后，等待线程依旧不会从<code>wait()</code>返回，需要调用<code>notify()</code>或<br><code>notifAll()</code>的线程释放锁之后，等待线程才有机会从<code>wait()</code>返回。</li><li><code>notify()</code>方法将等待队列中的一个等待线程从<strong>等待队列</strong>中移到<strong>同步队列</strong>中，而<code>notifyAll()</code>方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由<code>WAITING</code>变为<code>BLOCKED</code>。</li><li>从<code>wait()</code>方法返回的前提是获得了调用对象的锁。</li></ol><p>等待/通知的经典范式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (对象) &#123;</span><br><span class="line">    <span class="keyword">while</span> (条件不满足) &#123; <span class="comment">// 防止虚假唤醒（线程由于某些特殊情况，不是被notify或者notifyAll所唤醒）</span></span><br><span class="line">        对象.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    对应的处理逻辑</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (对象) &#123;</span><br><span class="line">    改变条件</span><br><span class="line">    对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="管道输入-输出流"><a href="#管道输入-输出流" class="headerlink" title="管道输入/输出流"></a>管道输入/输出流</h4><p>管道输入/输出流主要用于线程之间的数据传输，而传输的媒介为内存。</p><p>对于Piped类型的流，必须先要进行绑定，也就是调用<code>connect()</code>方法，如果没有将输入/输出流绑定起来，对于该流的访问将会抛出异常。</p><h2 id="java中的锁"><a href="#java中的锁" class="headerlink" title="java中的锁"></a>java中的锁</h2><p>锁的经典范式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    对应的处理逻辑</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放。<span class="label danger">不要</span>将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致莫名的锁释放。</p><h3 id="显示锁和隐式锁的区别"><a href="#显示锁和隐式锁的区别" class="headerlink" title="显示锁和隐式锁的区别"></a>显示锁和隐式锁的区别</h3><table><thead><tr><th>synchronized</th><th><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/Lock.html" target="_blank" rel="noopener">Lock</a></th></tr></thead><tbody><tr><td>关键字，隐式获取/释放锁</td><td>接口，显式获取/释放锁</td></tr><tr><td>代码简单，被大多程序员广泛使用，默认推荐</td><td>代码稍复杂，在try块外获取锁，在finally块中释放锁，迫于性能调优时再用</td></tr><tr><td>-</td><td>可尝试非阻塞获取锁（线程尝试获取锁，若锁未被其他线程持有，则成功获取并持有锁）</td></tr><tr><td>-</td><td>可中断获取锁（获取到锁的线程能够响应中断，当该线程被中断时，中断异常将被抛出，同时锁释放）</td></tr><tr><td>-</td><td>可超时获取锁（在指定的截止时间之前获取锁，若超时仍无法获取锁，则返回）</td></tr></tbody></table><p>锁是<strong>面向使用者</strong>的，它定义了使用者与锁交互的接口(比如可以允许两个线程并行访问),隐藏了实现细节;<br>同步器<strong>面向锁的实现者</strong>,它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。</p><img src="/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/concurrent-pkg-impl.png" class="" title="concurrent包的实现示意图"><h3 id="同步器可重写的方法"><a href="#同步器可重写的方法" class="headerlink" title="同步器可重写的方法"></a>同步器可重写的方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>boolean tryAcquire(int arg)</code></td><td>独占式获取同步状态。实现该方法需要查询当前同步状态并判断是否符合预期，然后再进行CAS设置同步状态。</td></tr><tr><td><code>boolean tryRelease(int arg)</code></td><td>独占式释放同步状态。等待获取同步状态的线程将有机会获取同步状态。</td></tr><tr><td><code>int tryAcquireShared(int arg)</code></td><td>共享式获取同步状态。返回大于等于0的值表示获取成功，否则获取失败。</td></tr><tr><td><code>boolean tryReleaseShared(int arg)</code></td><td>共享式释放同步状态。</td></tr><tr><td><code>boolean isHeldExclusively()</code></td><td>同步状态是否在独占模式下被线程占用。</td></tr></tbody></table><h3 id="同步器提供的便捷方法"><a href="#同步器提供的便捷方法" class="headerlink" title="同步器提供的便捷方法"></a>同步器提供的便捷方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>void acquire(int arg)</code></td><td>独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回。否则，将会进入同步队列等待，该方法<strong>忽略中断</strong>。</td></tr><tr><td><code>void acquireInterruptibly(int arg) throws InterruptedException</code></td><td>同上，但该方法响应中断，在同步队列中等待的线程可以被中断，会抛出InterruptedException并返回。</td></tr><tr><td><code>boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException</code></td><td>同上且增加了超时限制，如果在超时时间内没有获取到同步状态将返回false，否则返回true。</td></tr><tr><td><code>boolean release(int arg)</code></td><td>独占式释放同步状态。释放后会唤醒同步队列中的第一个节点所包含的线程。</td></tr><tr><td><code>void acquireShared(int arg)</code></td><td>共享式获取同步状态，若同步未获取获取成功则会进入同步队列等待。与独占式获取主要区别在<strong>同一时刻可以有多个线程</strong>获取同步状态。</td></tr><tr><td><code>void acquireSharedInterruptibly(int arg) throws InterruptedException</code></td><td>同上，但该方法响应中断</td></tr><tr><td><code>boolean tryAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException</code></td><td>同上且增加了超时限制</td></tr><tr><td><code>boolean releaseShared(int arg)</code></td><td>共享式释放同步状态。</td></tr></tbody></table><h3 id="同步器中节点的含义"><a href="#同步器中节点的含义" class="headerlink" title="同步器中节点的含义"></a>同步器中节点的含义</h3><table><thead><tr><th><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html" target="_blank" rel="noopener">AQS</a>#Node的属性</th><th>含义</th></tr></thead><tbody><tr><td><code>int waitStatus</code></td><td>状态字段，仅可能取以下几种值：状态字段，仅可能取以下几种值：<br/><br/><code>0</code>: 初始化状态。<br/><code>CANCELLED(1)</code>: 由于取消或中断，节点取消获取同步状态，节点进入该状态后将不会再发生变化。注意取消节点的线程永远不会再阻塞。<br/><code>SIGNAL(-1)</code>: 当前节点的后继节点是(或不久的将来)阻塞的(通过park)，因此当前节点释放或取消同步状态时必须通知(通过unpark)后继节点，为了避免竞争激烈，acquire方法必须首先表明他们需要一个启动信号，然后原子性重试获取同步状态，最后在失败时阻塞。<br/><code>CONDITION(-2)</code>: 此节点当前处于条件队列中。直到被转移(signal/signalAll)才会被加入到同步队列中，转移后状态将被设置为0。<br/><code>PROPAGATE(-3)</code>: releaseShared应该传播给其他节点。在doReleaseShared中设置（仅限头节点）以确保继续传播，即使其他操作已经介入。</td></tr><tr><td><code>Node prev</code></td><td>前驱节点，当节点加入到同步队列时被设置（CAS尾部加入）</td></tr><tr><td><code>Node next</code></td><td>后继节点</td></tr><tr><td><code>Thread thread</code></td><td>获取同步状态的线程</td></tr><tr><td><code>Node nextWaiter</code></td><td>条件队列中的后继节点，或特殊值<code>SHARED</code>。因为条件队列只有在保持独占模式时才被访问，所以我们只需要一个简单的链接队列来在节点等待条件时保存节点。然后将它们转移到同步队列中以重新获取同步状态。并且因为condition只能是独占的，所以我们通过使用SHARED特殊值来指示共享模式。</td></tr></tbody></table><h3 id="Object的监视器方法与Condition接口对比"><a href="#Object的监视器方法与Condition接口对比" class="headerlink" title="Object的监视器方法与Condition接口对比"></a>Object的监视器方法与Condition接口对比</h3><table><thead><tr><th>对比项</th><th>Object监视器方法</th><th><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/Condition.html" target="_blank" rel="noopener">Condition</a></th></tr></thead><tbody><tr><td>前置条件</td><td>获取对象的监视器锁</td><td>调用<code>Lock.lock()</code>获取锁<br/> 调用<code>Lock.newCondition()</code>获取<code>Condition</code>对象</td></tr><tr><td>调用方法</td><td>直接调用，如：<code>object.wait()</code></td><td>直接调用，如：<code>condition.await()</code></td></tr><tr><td>等待队列个数</td><td>一个</td><td>多个</td></tr><tr><td>当前线程释放锁并进入等待队列</td><td>支持</td><td>支持</td></tr><tr><td>当前线程释放锁并进入等待队列，在等待状态中<em>不</em>响应中断</td><td>不支持</td><td>支持</td></tr><tr><td>当前线程释放锁并进入超时等待状态</td><td>支持</td><td>支持</td></tr><tr><td>当前线程释放锁并进入等待状态到将来的某个时间</td><td>不支持</td><td>支持</td></tr><tr><td>唤醒等待队列中的一个线程</td><td>支持</td><td>支持</td></tr><tr><td>唤醒等待队列中的全部线程</td><td>支持</td><td>支持</td></tr></tbody></table><img src="/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/sync-and-wait-queue.png" class="" title="同步队列和等待队列的模样"><h3 id="通过源码看世界"><a href="#通过源码看世界" class="headerlink" title="通过源码看世界"></a>通过源码看世界</h3><h4 id="AQS超时获取锁的源代码"><a href="#AQS超时获取锁的源代码" class="headerlink" title="AQS超时获取锁的源代码"></a>AQS超时获取锁的源代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// acquire，acquireInterruptibly与此大同小异</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) || <span class="comment">// 先尝试获取一次</span></span><br><span class="line">        doAcquireNanos(arg, nanosTimeout); <span class="comment">// 尝试失败，将其包装成Node，放入等待队列，并等待前驱节点唤醒</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE); <span class="comment">// 包装成独占模式等待者</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 若是头节点，尝试获取同步状态，成功则将自己设置成头节点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// 释放前驱节点引用，便于GC回收原头节点</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) <span class="comment">// 超时仍未获取到，则返回fasle</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">// 如果前驱节点状态(SIGNAL)正常，则等待；若已取消(CANCELLED)为其寻找一个正常的前驱节点；否则CAS设置前驱节点状态为正常态</span></span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold) <span class="comment">// 超时时间大于阈值，则使用parkNanos超时等待；否则采用高速自旋重试</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) <span class="comment">// 被唤醒发现线程中断，则抛出中断异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) </span><br><span class="line">            cancelAcquire(node); <span class="comment">// 超时或中断退出时，则取消获取同步状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/aqs-doAcquireNanos.png" class="" title="AQS超时获取锁的流程图"><h4 id="AQS释放锁的源代码"><a href="#AQS释放锁的源代码" class="headerlink" title="AQS释放锁的源代码"></a>AQS释放锁的源代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">// 尝试释放同步状态</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h); <span class="comment">// 释放成功，唤醒头节点的后继节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) </span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);　<span class="comment">// 将头节点状态修改为0</span></span><br><span class="line"></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123; <span class="comment">// 头节点不存在后继节点或后继节点已取消获取同步状态</span></span><br><span class="line">        s = <span class="keyword">null</span>;　</span><br><span class="line">        <span class="comment">// 从前往后寻找不一定能找到刚刚加入队列的后继节点, 因为在Node addWaiter(Node mode)中，是先CAS设置尾节点，再设置前驱节点和尾节点的引用关系</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev) </span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) <span class="comment">// 从队尾往前找，找到第一个需要唤醒的节点</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread); <span class="comment">// 唤醒线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReentrantLock非公平获取锁源代码"><a href="#ReentrantLock非公平获取锁源代码" class="headerlink" title="ReentrantLock非公平获取锁源代码"></a>ReentrantLock非公平获取锁源代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NonfairSync类中</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">// 非公平锁直接尝试获取锁</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync父类中</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 目前没有其他线程获得锁，当前线程就可以尝试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">// CAS修改同步状态</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// 当前线程持有锁，支持重入</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc); <span class="comment">// 已持有锁，可直接修改</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 修改失败返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReentrantLock公平获取锁源代码"><a href="#ReentrantLock公平获取锁源代码" class="headerlink" title="ReentrantLock公平获取锁源代码"></a>ReentrantLock公平获取锁源代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FairSync类中</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">// 多了这个判断，需要判断队列中是否还有前驱节点线程</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReentrantLock释放锁的源代码"><a href="#ReentrantLock释放锁的源代码" class="headerlink" title="ReentrantLock释放锁的源代码"></a>ReentrantLock释放锁的源代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) <span class="comment">// 当前线程未持有锁，不可释放</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 由于锁可重入，当同步状态等于0时，才代表真正释放掉</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReentrantReadWriteLock获取释放锁源代码"><a href="#ReentrantReadWriteLock获取释放锁源代码" class="headerlink" title="ReentrantReadWriteLock获取释放锁源代码"></a>ReentrantReadWriteLock获取释放锁源代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*以高16位表示所有线程获取读锁数，以低16位表示单个线程获取写锁数 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT); <span class="comment">// 0x00010000</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>; <span class="comment">// 低16位全为1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125; <span class="comment">// 根据同步状态计算已持有的读锁数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125; <span class="comment">// 根据同步状态计算已持有的写锁数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123; <span class="comment">// 获取独占锁（写锁）</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 持有的写锁数</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="comment">// 如果同步状态不为0但是写锁数为0,代表持有读锁(不为0)</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread()) <span class="comment">// 已持有读锁或不是当前线程持有写锁，均不可再获取写锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT) <span class="comment">// 获取写锁数超限</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(c + acquires); <span class="comment">// 是当前线程持有写锁，可重入获取</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() || <span class="comment">// 公平模式下需要判断同步队列中是否有前驱节点在等待</span></span><br><span class="line">        !compareAndSetState(c, c + acquires)) <span class="comment">// 无线程获取写锁，CAS获取锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current); <span class="comment">// 获取成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively()) <span class="comment">// 非持有写锁的线程不可释放写锁</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>; <span class="comment">// 因为可重入，当同步状态低16位全为0，才代表成功释放</span></span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(nextc); </span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123; <span class="comment">// 获取共享锁(读锁)</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)　<span class="comment">// 写锁已被持有但不是当前线程，获取读锁阻塞</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);　<span class="comment">// 持有的读锁数</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp; <span class="comment">// 公平模式下需要判断同步队列中是否有前驱节点在等待</span></span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123; <span class="comment">// 无线程持有写锁，所有线程都可获取读锁</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123; <span class="comment">// 无线程持有读锁，标记当前线程首次获取读锁1次</span></span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// 有线程持有读锁，若当前线程是首次获取读锁的线程，则增加读锁持有数</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 有线程持有读锁，但不是首次获取读锁的线程，则初始化线程相应读锁持有数</span></span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) <span class="comment">// 无缓存或缓存的计数不是当前线程</span></span><br><span class="line">                cachedHoldCounter = rh = readHolds.get(); <span class="comment">// 获取线程本地缓存</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)  <span class="comment">// 有缓存且当前线程第一次获取锁，则初始化线程(锁计数)本地缓存</span></span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++; <span class="comment">// 当前线程持有读锁数加1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current); <span class="comment">// 自旋获取读锁，用于应对首次尝试CAS未命中和重入读锁的情况</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// 当前线程是第一个获取读锁的线程</span></span><br><span class="line">        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>) <span class="comment">// 线程仅持有1个读锁，释放后即无第一个读线程</span></span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            firstReaderHoldCount--; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123; <span class="comment">// 只获取一次读锁，则直接移除，</span></span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count; <span class="comment">// 减少缓存计数信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 自旋释放读锁</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">            <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">            <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java中的阻塞队列"><a href="#java中的阻塞队列" class="headerlink" title="java中的阻塞队列"></a>java中的阻塞队列</h2><p>插入和移除操作的4种处理方式：</p><table><thead><tr><th>方法/处理方式</th><th>抛出异常</th><th>返回特殊值</th><th>一直阻塞</th><th>超时退出</th></tr></thead><tbody><tr><td>插入方法</td><td><code>add(e)</code></td><td><code>offer(e)</code></td><td><code>put(e)</code></td><td><code>offer(e, time, unit)</code></td></tr><tr><td>移除方法</td><td><code>remove()</code></td><td><code>poll()</code></td><td><code>take()</code></td><td><code>poll(time, unit)</code></td></tr><tr><td>检查方法</td><td><code>element()</code></td><td><code>peek()</code></td><td>不可用</td><td>不可用</td></tr></tbody></table><p>提供了哪些阻塞队列？</p><ul><li><code>ArrayBlockingQueue</code>：由数组结构组成的有界阻塞队列。</li><li><code>LinkedBlockingQueue</code>：由链表结构组成的有界阻塞队列。</li><li><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列。</li><li><code>DelayQueue</code>：使用优先级队列实现的无界阻塞延时队列。（延迟队列中的元素到了延迟时间则可以从中取出，否则无法取出）</li><li><code>SynchronousQueue</code>：不存储元素的阻塞队列。</li><li><code>LinkedTransferQueue</code>：由链表结构组成的无界阻塞队列。</li><li><code>LinkedBlockingDeque</code>：由链表结构组成的双向阻塞队列。</li></ul><h2 id="java中的原子操作类"><a href="#java中的原子操作类" class="headerlink" title="java中的原子操作类"></a>java中的原子操作类</h2><ul><li><code>AtomicBoolean</code>：原子更新布尔类型。</li><li><code>AtomicInteger</code>：原子更新整型。</li><li><code>AtomicLong</code>：原子更新长整型。</li><li><code>AtomicIntegerArray</code>：原子更新整型数组里的元素。（对内部的数组元素(将传入数组复制一份)进行修改，不会影响传入的数组）</li><li><code>AtomicLongArray</code>：原子更新长整型数组里的元素。</li><li><code>AtomicReferenceArray</code>：原子更新引用类型数组里的元素。</li><li><code>AtomicReference</code>：原子更新引用类型。</li><li><code>AtomicIntegerFieldUpdater</code>：原子更新整型字段的更新器。</li><li><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器。</li><li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型字段的更新器。</li><li><code>AtomicMarkableReference</code>：原子更新带有boolean标记位的引用类型。</li><li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。</li></ul><h2 id="java中的并发工具类"><a href="#java中的并发工具类" class="headerlink" title="java中的并发工具类"></a>java中的并发工具类</h2><ul><li><code>CountDownLatch</code>（倒计数器/闭锁）：一个或多个线程等待其他线程完成操作。<span class="label info">用于等待事件。是一次性对象，一旦进入终止状态就不能被重置，只能使用一次。</span></li><li><code>CyclicBarrier</code>（循环屏障/栅栏）：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。<span class="label info">用于等待其他线程。可以使用reset()方法重置，多次使用。</span></li><li><code>Semaphore</code>（信号量）：控制同时访问某个特定资源的线程数量或同时执行某个指定操作的数量。还可以用来实现某种资源池，或者对容器施加边界。二值信号量可以用作互斥体，具备不可重入的加锁语义。</li><li><code>Exchanger</code>（交换者）：用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。</li><li>Guava <code>RateLimiter</code>（限流器）：使用漏桶算法（利用一个缓存区，请求进入系统时，无论请求的速率如何都先保存在缓存区内，然后以固定的流速流出缓存区进行处理）或令牌桶算法（桶中存放的不再是请求，而是令牌，处理程序只有拿到令牌后才能对请求进行处理，无令牌时程序要么等待令牌，要么丢弃请求，为了限制流速，会在每个单位时间产生一定量的令牌放入桶中）对请求进行限流。</li></ul><h2 id="java中的线程池"><a href="#java中的线程池" class="headerlink" title="java中的线程池"></a>java中的线程池</h2><img src="/blog/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/thread-pool-processing.png" class=""><ol><li>如果当前运行的线程少于<code>corePoolSize</code>，则创建新线程来执行任务（<span class="label danger">注意：执行这一步骤需要获取全局锁</span>）。</li><li>如果运行的线程等于或多于<code>corePoolSize</code>，则将任务加入<code>BlockingQueue</code>。</li><li>如果无法将任务加入<code>BlockingQueue</code>（队列已满），则创建新的线程来处理任务（<span class="label danger">注意：执行这一步骤需要获取全局锁</span>）。</li><li>如果创建新线程将使当前运行的线程超出<code>maximumPoolSize</code>，任务将被拒绝，并调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li></ol><h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h3><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, // 核心线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize, // 最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime, // 线程数量超过核心线程时，多余的空闲线程的最大存活时间</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit, // 时间的单位</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue, // 阻塞队列，暂存被提交但尚未执行的任务</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory, // 创建工作线程的工厂</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123; <span class="comment">// 拒绝策略，任务太多来不及处理时如何拒绝</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BlockingQueue</code>（阻塞队列）：</p><ul><li><code>ArrayBlockingQueue</code>：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。</li><li><code>LinkedBlockingQueue</code>：一个基于链表结构的阻塞队列，此队列按FIFO（先进先出）排序元素，吞吐量通常要高于<code>ArrayBlockingQueue</code>。</li><li><code>SynchronousQueue</code>：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于<code>LinkedBlockingQueue</code>。<blockquote><p>仅当有足够多的消费者，并且总是有一个消费者准备好获取交付的工作时，才适合使用同步队列。</p></blockquote></li><li><code>PriorityBlockingQueue</code>：一个具有优先级的无限阻塞队列。<blockquote><p>当需要按照某种顺序而不是FIFO来处理元素时，非常适用。既可以使用元素的自然顺序来比较（它们实现了<code>Comparable</code>），也可以使用<code>Comparator</code>来比较。</p></blockquote></li></ul><p><code>RejectedExecutionHandler</code>（饱和策略）：</p><ul><li><code>AbortPolicy</code>：直接抛出异常。</li><li><code>CallerRunsPolicy</code>：只用调用者所在线程来运行任务。</li><li><code>DiscardOldestPolicy</code>：丢弃下一个将被执行的任务，然后尝试重新提交新的任务。<blockquote><span class="label warning">如果工作队列是一个优先队列，那么“抛弃最旧的”策略将导致抛弃优先级最高的任务，因此最好不要将“抛弃最旧的”饱和策略和优先级队列放在一起使用。</span></blockquote></li><li><code>DiscardPolicy</code>：不处理悄悄丢弃掉。</li></ul><h4 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h4><ul><li><code>execute()</code>：用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。</li><li><code>submit()</code>：用于提交需要返回值的任务。</li></ul><h4 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h4><ul><li><code>shutdown()</code>：只是将线程池的状态设置成<code>SHUTDOWN</code>状态，然后中断所有没有正在执行任务的线程。</li><li><code>shutdownNow()</code>：首先将线程池的状态设置成<code>STOP</code>，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。</li></ul><h3 id="合理配置线程池"><a href="#合理配置线程池" class="headerlink" title="合理配置线程池"></a>合理配置线程池</h3><p>线程数配置：</p><ul><li><p>按任务的性质拆分：<br><u>CPU密集型任务</u>应配置尽可能小的线程，如配置<code>Ncpu+1</code>个线程的线程池。由于<u>IO密集型任务</u>线程并不是一直在执行任务，则应配置尽可能多的线程，如<code>2*Ncpu</code>。<u>混合型的任务</u>，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过<code>Runtime.getRuntime().availableProcessors()</code>方法获得当前设备的CPU个数。</p></li><li><p>按任务优先级拆分：<br>优先级不同的任务可以使用优先级队列<code>PriorityBlockingQueue</code>来处理。它可以让优先级高的任务先执行。但需要注意如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。</p></li><li><p>按任务执行时间拆分：<br>执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。</p></li><li><p>按任务的依赖性拆分:<br>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，等待的时间越长，则CPU空闲时间就越长，那么线程数应该设置得越大，这样才能更好地利用CPU。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ncpu &#x3D; cpu的数量</span><br><span class="line">Ucpu &#x3D; 目标cpu的使用率，0 ≤ Ucpu ≤ 1</span><br><span class="line">W&#x2F;C &#x3D; 等待时间与计算时间的比率</span><br><span class="line">为保持处理器达到期望的使用率，最优的线程池大小等于：Nthreads &#x3D; Ncpu * Ucpu * (1 + W&#x2F;C)</span><br></pre></td></tr></table></figure><p>队列配置：</p><ul><li><span class="label primary">建议使用有界队列</span></li><li>吞吐量比较：<br><code>SynchronousQueue(Executors.newCachedThreadPool)</code>&gt;<code>LinkedBlockingQueue(Executors.newFixedThreadPool())</code>&gt;<code>ArrayBlockingQueue</code></li></ul><p>拒绝策略配置：</p><ul><li>也可以根据应用场景需要来实现<code>RejectedExecutionHandler</code>接口自定义策略。如记录日志或持久化存储不能处理的任务。</li></ul><p>空闲存活时间配置：</p><ul><li>任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。</li></ul><h3 id="监控线程池"><a href="#监控线程池" class="headerlink" title="监控线程池"></a>监控线程池</h3><p>通过线程池提供的参数进行监控，在监控线程池的时候可以使用以下属性：</p><ul><li><code>taskCount</code>：线程池需要执行的任务数量。</li><li><code>completedTaskCount</code>：线程池在运行过程中已完成的任务数量，小于或等于<code>taskCount</code>。</li><li><code>largestPoolSize</code>：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。</li><li><code>getPoolSize</code>：线程池的线程数量。</li><li><code>getActiveCount</code>：获取活动的线程数量。</li></ul><p>通过继承线程池来自定义线程池，重写线程池的<code>beforeExecute</code>、<code>afterExecute</code>和<code>terminated</code>方法，在任务执行前、执行后和线程池关闭前执行一些代码来进行监控。</p><h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><ul><li><code>FixedThreadPool</code>：容量为<code>Integer.MAX_VALUE</code>的<code>LinkedBlockingQueue</code>。由于使用无界队列，因此<code>maximumPoolSize</code>和<code>keepAliveTime</code>将是无效参数。运行中的FixedThreadPool（未执行方法<code>shutdown()</code>或<code>shutdownNow()</code>）也不会拒绝任务。这意味着如果主线程提交任务的速度高于池中线程处理任务的速度时，它会不断积压任务。<u>极端情况下，会因为积压过多的任务而耗尽内存资源。</u><blockquote><p>适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，它适用于负载比较重的服务器。</p></blockquote></li><li><code>SingleThreadExecutor</code>：<code>corePoolSize</code>和<code>maximumPoolSize</code>被设置为<code>1</code>，容量为<code>Integer.MAX_VALUE</code>的<code>LinkedBlockingQueue</code>。使用无界队列带来的影响与上述相同。<blockquote><p>适用于需要保证顺序地执行各个任务；并且在任意时间点，不会有多个线程是活动的应用场景。</p></blockquote></li><li><code>CachedThreadPool</code>：核心线程数为<code>0</code>,最大线程数为<code>Integer.MAX_VALUE</code>，<code>keepAliveTime</code>设置为<code>60L</code>，没有容量的<code>SynchronousQueue</code>，是大小无界的线程池，这意味着如果主线程提交任务的速度高于池中线程处理任务的速度时，它会不断创建新线程。<u>极端情况下，会因为创建过多线程而耗尽CPU和内存资源。</u><blockquote><p>适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器。</p></blockquote></li><li><code>ScheduledThreadPoolExecutor</code>：<code>DelayedQueue</code>无界队列，其内保存的<code>ScheduledFutureTask</code>任务会先按照任务的执行时间升序排列，其次按照任务提交的序列号升序排列。<blockquote><p>适用于需要多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程的数量的应用场景。</p></blockquote></li><li><code>SingleThreadScheduledExecutor</code>：只有一个核心线程的<code>ScheduledThreadPoolExecutor</code>。<blockquote><p>适用于需要单个后台线程执行周期任务，同时需要保证顺序地执行各个任务的应用场景。</p></blockquote></li></ul><hr><ul><li><em>《Java并发编程的艺术》</em></li><li><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization" target="_blank" rel="noopener">Synchronization</a></li><li><a href="https://blog.dreamtobe.cn/2015/11/13/java_synchronized/" target="_blank" rel="noopener">Java Synchronised机制</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;并发编程的挑战&quot;&gt;&lt;a href=&quot;#并发编程的挑战&quot; class=&quot;headerlink&quot; title=&quot;并发编程的挑战&quot;&gt;&lt;/a&gt;并发编程的挑战&lt;/h2&gt;&lt;h3 id=&quot;上下文切换&quot;&gt;&lt;a href=&quot;#上下文切换&quot; class=&quot;headerlink&quot; title=&quot;上下文切换&quot;&gt;&lt;/a&gt;上下文切换&lt;/h3&gt;&lt;p&gt;上下文切换：CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="http://xiaojiaC.github.io/blog/categories/JAVA/"/>
    
      <category term="读书笔记" scheme="http://xiaojiaC.github.io/blog/categories/JAVA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://xiaojiaC.github.io/blog/tags/java/"/>
    
      <category term="concurrency" scheme="http://xiaojiaC.github.io/blog/tags/concurrency/"/>
    
  </entry>
  
</feed>
